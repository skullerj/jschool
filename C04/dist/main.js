/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/index.js!./src/styles.css":
/*!**************************************************!*\
  !*** ./node_modules/css-loader!./src/styles.css ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"\\n* {\\n  box-sizing: border-box;\\n}\\nhtml {\\n  font-family: 'Merriweather', serif;\\n  font-size: 16px;\\n}\\nbody{\\n  display: flex;\\n  flex-direction: column;\\n  margin: 0px;\\n  height: 100vh;\\n}\\nheader{\\n  padding: 16px 16px 0 16px;\\n}\\nmain{\\n  flex:1;\\n  padding: 8px;\\n  box-sizing: border-box;\\n  position: relative;\\n}\\n.whites, .blacks{\\n  position: absolute;\\n  display: flex;\\n  flex-grow: 1;\\n  flex-direction: column;\\n  height: 95%;\\n  width: 90%;\\n}\\n.whites div , .blacks div{\\n  display: flex;\\n  flex:1;\\n}\\n.whites div{\\n  background: white;\\n  border: 1px solid black;\\n}\\n.blacks div{\\n  width: 40%;\\n  align-self: flex-end;\\n}\\n.blacks div[playable]{\\n  background: black;\\n  flex:2;\\n}\\n/* typography */\\nh1,p{\\n  margin: 0;\\n  font-family: 'Merriweather', serif;\\n}\\nh1{\\n  font-size: 2rem;\\n}\\n\\ndiv[playable] p {\\n  display: none;\\n}\\n\\n#octaveDisplayer {\\n  color: rgb(111,148,182);\\n  font-size: 1.5rem;\\n  margin-right: 3rem;\\n}\\n\\n@media screen and (max-width:460px){\\n  .desktop-legend, #toneDisplayer{\\n    display: none;\\n  }\\n}\\n\\n@media screen and (min-width:461px){\\n  .whites, .blacks{\\n    flex-direction: row;\\n  }\\n  .blacks div{\\n    height: 40%;\\n    width: inherit;\\n    align-self: flex-start;\\n  }\\n  .mobile-legend{\\n    display: none;\\n  }\\n  div[playable] p {\\n    display: block;\\n    bottom: 10px;\\n    left: 10px;\\n    font-size: 2rem;\\n    position: absolute;\\n  }\\n  div.whites div p{\\n    color: black;\\n  }\\n  div.blacks div p{\\n    color: white;\\n  }\\n}\\n\\n/* Animations */\\ndiv[playable]{\\n  position:relative;\\n  z-index: 200;\\n}\\ndiv[playable]::after {\\n\\tbackground: rgba(111,148,182,0.5);\\n  position: absolute;\\n\\twidth: 100%;\\n\\theight: 100%;\\n\\tcontent: '';\\n\\topacity: 0;\\n\\tpointer-events: none;\\n}\\n\\ndiv[playable].playing::after {\\n\\t-webkit-animation: tap 0.1s forwards;\\n\\tanimation: tap 0.2s forwards;\\n}\\n\\n@keyframes tap {\\n\\t0% {\\n\\t\\t-webkit-transform: scale3d(0.3, 0.3, 1);\\n\\t\\ttransform: scale3d(0.3, 0.3, 1);\\n\\t}\\n\\t25%, 50% {\\n\\t\\topacity: 1;\\n\\t}\\n\\tto {\\n\\t\\topacity: 0;\\n\\t\\t-webkit-transform: scale3d(1.1, 1.1, 1);\\n\\t\\ttransform: scale3d(1.1, 1.1, 1);\\n\\t}\\n}\\n\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3NyYy9zdHlsZXMuY3NzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlcy5jc3M/NDUwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbioge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG59XFxuaHRtbCB7XFxuICBmb250LWZhbWlseTogJ01lcnJpd2VhdGhlcicsIHNlcmlmO1xcbiAgZm9udC1zaXplOiAxNnB4O1xcbn1cXG5ib2R5e1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBtYXJnaW46IDBweDtcXG4gIGhlaWdodDogMTAwdmg7XFxufVxcbmhlYWRlcntcXG4gIHBhZGRpbmc6IDE2cHggMTZweCAwIDE2cHg7XFxufVxcbm1haW57XFxuICBmbGV4OjE7XFxuICBwYWRkaW5nOiA4cHg7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG4ud2hpdGVzLCAuYmxhY2tze1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZ3JvdzogMTtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBoZWlnaHQ6IDk1JTtcXG4gIHdpZHRoOiA5MCU7XFxufVxcbi53aGl0ZXMgZGl2ICwgLmJsYWNrcyBkaXZ7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleDoxO1xcbn1cXG4ud2hpdGVzIGRpdntcXG4gIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxufVxcbi5ibGFja3MgZGl2e1xcbiAgd2lkdGg6IDQwJTtcXG4gIGFsaWduLXNlbGY6IGZsZXgtZW5kO1xcbn1cXG4uYmxhY2tzIGRpdltwbGF5YWJsZV17XFxuICBiYWNrZ3JvdW5kOiBibGFjaztcXG4gIGZsZXg6MjtcXG59XFxuLyogdHlwb2dyYXBoeSAqL1xcbmgxLHB7XFxuICBtYXJnaW46IDA7XFxuICBmb250LWZhbWlseTogJ01lcnJpd2VhdGhlcicsIHNlcmlmO1xcbn1cXG5oMXtcXG4gIGZvbnQtc2l6ZTogMnJlbTtcXG59XFxuXFxuZGl2W3BsYXlhYmxlXSBwIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbiNvY3RhdmVEaXNwbGF5ZXIge1xcbiAgY29sb3I6IHJnYigxMTEsMTQ4LDE4Mik7XFxuICBmb250LXNpemU6IDEuNXJlbTtcXG4gIG1hcmdpbi1yaWdodDogM3JlbTtcXG59XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDo0NjBweCl7XFxuICAuZGVza3RvcC1sZWdlbmQsICN0b25lRGlzcGxheWVye1xcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgfVxcbn1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjQ2MXB4KXtcXG4gIC53aGl0ZXMsIC5ibGFja3N7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICB9XFxuICAuYmxhY2tzIGRpdntcXG4gICAgaGVpZ2h0OiA0MCU7XFxuICAgIHdpZHRoOiBpbmhlcml0O1xcbiAgICBhbGlnbi1zZWxmOiBmbGV4LXN0YXJ0O1xcbiAgfVxcbiAgLm1vYmlsZS1sZWdlbmR7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICB9XFxuICBkaXZbcGxheWFibGVdIHAge1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgYm90dG9tOiAxMHB4O1xcbiAgICBsZWZ0OiAxMHB4O1xcbiAgICBmb250LXNpemU6IDJyZW07XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIH1cXG4gIGRpdi53aGl0ZXMgZGl2IHB7XFxuICAgIGNvbG9yOiBibGFjaztcXG4gIH1cXG4gIGRpdi5ibGFja3MgZGl2IHB7XFxuICAgIGNvbG9yOiB3aGl0ZTtcXG4gIH1cXG59XFxuXFxuLyogQW5pbWF0aW9ucyAqL1xcbmRpdltwbGF5YWJsZV17XFxuICBwb3NpdGlvbjpyZWxhdGl2ZTtcXG4gIHotaW5kZXg6IDIwMDtcXG59XFxuZGl2W3BsYXlhYmxlXTo6YWZ0ZXIge1xcblxcdGJhY2tncm91bmQ6IHJnYmEoMTExLDE0OCwxODIsMC41KTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG5cXHR3aWR0aDogMTAwJTtcXG5cXHRoZWlnaHQ6IDEwMCU7XFxuXFx0Y29udGVudDogJyc7XFxuXFx0b3BhY2l0eTogMDtcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXFxuZGl2W3BsYXlhYmxlXS5wbGF5aW5nOjphZnRlciB7XFxuXFx0LXdlYmtpdC1hbmltYXRpb246IHRhcCAwLjFzIGZvcndhcmRzO1xcblxcdGFuaW1hdGlvbjogdGFwIDAuMnMgZm9yd2FyZHM7XFxufVxcblxcbkBrZXlmcmFtZXMgdGFwIHtcXG5cXHQwJSB7XFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlM2QoMC4zLCAwLjMsIDEpO1xcblxcdFxcdHRyYW5zZm9ybTogc2NhbGUzZCgwLjMsIDAuMywgMSk7XFxuXFx0fVxcblxcdDI1JSwgNTAlIHtcXG5cXHRcXHRvcGFjaXR5OiAxO1xcblxcdH1cXG5cXHR0byB7XFxuXFx0XFx0b3BhY2l0eTogMDtcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUzZCgxLjEsIDEuMSwgMSk7XFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZTNkKDEuMSwgMS4xLCAxKTtcXG5cXHR9XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js!./src/styles.css\n");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function () {\n    function toString() {\n      return this.map(function (item) {\n        var content = cssWithMappingToString(item, useSourceMap);\n\n        if (item[2]) {\n          return \"@media \" + item[2] + \"{\" + content + \"}\";\n        } else {\n          return content;\n        }\n      }).join(\"\");\n    }\n\n    return toString;\n  }(); // import a list of modules into the list\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === \"string\") modules = [[null, modules, \"\"]];\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      var id = this[i][0];\n      if (typeof id === \"number\") alreadyImportedModules[id] = true;\n    }\n\n    for (i = 0; i < modules.length; i++) {\n      var item = modules[i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      //  when a module is imported multiple times with different media queries.\n      //  I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || '';\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n  return '/*# ' + data + ' */';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MjM1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBQUE7QUFDQTtBQUNBO0FBVUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/lib/css-base.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCwgcGFyZW50KSB7XG4gIGlmIChwYXJlbnQpe1xuICAgIHJldHVybiBwYXJlbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG59O1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXNzaW5nIGZ1bmN0aW9uIGluIG9wdGlvbnMsIHRoZW4gdXNlIGl0IGZvciByZXNvbHZlIFwiaGVhZFwiIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gVXNlZnVsIGZvciBTaGFkb3cgUm9vdCBzdHlsZSBpLmVcbiAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgICAgLy8gICBpbnNlcnRJbnRvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Zvb1wiKS5zaGFkb3dSb290IH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHZhciBzdHlsZVRhcmdldCA9IGdldFRhcmdldC5jYWxsKHRoaXMsIHRhcmdldCwgcGFyZW50KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUsIHRhcmdldCk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cblx0aWYob3B0aW9ucy5hdHRycy5ub25jZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcblx0XHRpZiAobm9uY2UpIHtcblx0XHRcdG9wdGlvbnMuYXR0cnMubm9uY2UgPSBub25jZTtcblx0XHR9XG5cdH1cblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBnZXROb25jZSgpIHtcblx0aWYgKHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHJldHVybiBfX3dlYnBhY2tfbm9uY2VfXztcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSB0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbidcblx0XHQgPyBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKSBcblx0XHQgOiBvcHRpb25zLnRyYW5zZm9ybS5kZWZhdWx0KG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/addStyles.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  } // blank or null?\n\n\n  if (!css || typeof css !== \"string\") {\n    return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\"); // convert each url(...)\n\n  /*\n  This regular expression is just a way to recursively match brackets within\n  a string.\n  \t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n     (  = Start a capturing group\n       (?:  = Start a non-capturing group\n           [^)(]  = Match anything that isn't a parentheses\n           |  = OR\n           \\(  = Match a start parentheses\n               (?:  = Start another non-capturing groups\n                   [^)(]+  = Match anything that isn't a parentheses\n                   |  = OR\n                   \\(  = Match a start parentheses\n                       [^)(]*  = Match anything that isn't a parentheses\n                   \\)  = Match a end parentheses\n               )  = End Group\n               *\\) = Match anything and then a close parens\n           )  = Close non-capturing group\n           *  = Match anything\n        )  = Close capturing group\n   \\)  = Match a close parens\n  \t /gi  = Get all matches, not the first.  Be case insensitive.\n   */\n\n  var fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function (fullMatch, origUrl) {\n    // strip quotes (if they exist)\n    var unquotedOrigUrl = origUrl.trim().replace(/^\"(.*)\"$/, function (o, $1) {\n      return $1;\n    }).replace(/^'(.*)'$/, function (o, $1) {\n      return $1;\n    }); // already a full url? no change\n\n    if (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n      return fullMatch;\n    } // convert the url to a full url\n\n\n    var newUrl;\n\n    if (unquotedOrigUrl.indexOf(\"//\") === 0) {\n      //TODO: should we add protocol?\n      newUrl = unquotedOrigUrl;\n    } else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n      // path should be relative to the base url\n      newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n    } else {\n      // path should be relative to current directory\n      newUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n    } // send back the fixed url(...)\n\n\n    return \"url(\" + JSON.stringify(newUrl) + \")\";\n  }); // send back the fixed css\n\n  return fixedCss;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcz9mNmQzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvfFxccyokKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFDQTs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/urls.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/component/Volume.js":
/*!****************************************************!*\
  !*** ./node_modules/tone/Tone/component/Volume.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/signal/Signal */ \"./node_modules/tone/Tone/signal/Signal.js\"), __webpack_require__(/*! Tone/core/Gain */ \"./node_modules/tone/Tone/core/Gain.js\"), __webpack_require__(/*! Tone/core/AudioNode */ \"./node_modules/tone/Tone/core/AudioNode.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  \"use strict\";\n  /**\n   *  @class Tone.Volume is a simple volume node, useful for creating a volume fader.\n   *\n   *  @extends {Tone.AudioNode}\n   *  @constructor\n   *  @param {Decibels} [volume=0] the initial volume\n   *  @example\n   * var vol = new Tone.Volume(-12);\n   * instrument.chain(vol, Tone.Master);\n   */\n\n  Tone.Volume = function () {\n    var options = Tone.defaults(arguments, [\"volume\"], Tone.Volume);\n    Tone.AudioNode.call(this);\n    /**\n     * the output node\n     * @type {GainNode}\n     * @private\n     */\n\n    this.output = this.input = new Tone.Gain(options.volume, Tone.Type.Decibels);\n    /**\n     * The unmuted volume\n     * @type {Decibels}\n     * @private\n     */\n\n    this._unmutedVolume = options.volume;\n    /**\n     *  The volume control in decibels.\n     *  @type {Decibels}\n     *  @signal\n     */\n\n    this.volume = this.output.gain;\n\n    this._readOnly(\"volume\"); //set the mute initially\n\n\n    this.mute = options.mute;\n  };\n\n  Tone.extend(Tone.Volume, Tone.AudioNode);\n  /**\n   *  Defaults\n   *  @type  {Object}\n   *  @const\n   *  @static\n   */\n\n  Tone.Volume.defaults = {\n    \"volume\": 0,\n    \"mute\": false\n  };\n  /**\n   * Mute the output.\n   * @memberOf Tone.Volume#\n   * @type {boolean}\n   * @name mute\n   * @example\n   * //mute the output\n   * volume.mute = true;\n   */\n\n  Object.defineProperty(Tone.Volume.prototype, \"mute\", {\n    get: function () {\n      function get() {\n        return this.volume.value === -Infinity;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(mute) {\n        if (!this.mute && mute) {\n          this._unmutedVolume = this.volume.value; //maybe it should ramp here?\n\n          this.volume.value = -Infinity;\n        } else if (this.mute && !mute) {\n          this.volume.value = this._unmutedVolume;\n        }\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  clean up\n   *  @returns {Tone.Volume} this\n   */\n\n  Tone.Volume.prototype.dispose = function () {\n    this.input.dispose();\n    Tone.AudioNode.prototype.dispose.call(this);\n\n    this._writable(\"volume\");\n\n    this.volume.dispose();\n    this.volume = null;\n    return this;\n  };\n\n  return Tone.Volume;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvbXBvbmVudC9Wb2x1bWUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvbXBvbmVudC9Wb2x1bWUuanM/OWE0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoW1wiVG9uZS9jb3JlL1RvbmVcIiwgXCJUb25lL3NpZ25hbC9TaWduYWxcIiwgXCJUb25lL2NvcmUvR2FpblwiLCBcIlRvbmUvY29yZS9BdWRpb05vZGVcIl0sIGZ1bmN0aW9uKFRvbmUpe1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiAgQGNsYXNzIFRvbmUuVm9sdW1lIGlzIGEgc2ltcGxlIHZvbHVtZSBub2RlLCB1c2VmdWwgZm9yIGNyZWF0aW5nIGEgdm9sdW1lIGZhZGVyLlxuXHQgKlxuXHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHQgKiAgQGNvbnN0cnVjdG9yXG5cdCAqICBAcGFyYW0ge0RlY2liZWxzfSBbdm9sdW1lPTBdIHRoZSBpbml0aWFsIHZvbHVtZVxuXHQgKiAgQGV4YW1wbGVcblx0ICogdmFyIHZvbCA9IG5ldyBUb25lLlZvbHVtZSgtMTIpO1xuXHQgKiBpbnN0cnVtZW50LmNoYWluKHZvbCwgVG9uZS5NYXN0ZXIpO1xuXHQgKi9cblx0VG9uZS5Wb2x1bWUgPSBmdW5jdGlvbigpe1xuXG5cdFx0dmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1widm9sdW1lXCJdLCBUb25lLlZvbHVtZSk7XG5cdFx0VG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblxuXHRcdC8qKlxuXHRcdCAqIHRoZSBvdXRwdXQgbm9kZVxuXHRcdCAqIEB0eXBlIHtHYWluTm9kZX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMub3V0cHV0ID0gdGhpcy5pbnB1dCA9IG5ldyBUb25lLkdhaW4ob3B0aW9ucy52b2x1bWUsIFRvbmUuVHlwZS5EZWNpYmVscyk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdW5tdXRlZCB2b2x1bWVcblx0XHQgKiBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl91bm11dGVkVm9sdW1lID0gb3B0aW9ucy52b2x1bWU7XG5cblx0XHQvKipcblx0XHQgKiAgVGhlIHZvbHVtZSBjb250cm9sIGluIGRlY2liZWxzLlxuXHRcdCAqICBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0ICogIEBzaWduYWxcblx0XHQgKi9cblx0XHR0aGlzLnZvbHVtZSA9IHRoaXMub3V0cHV0LmdhaW47XG5cblx0XHR0aGlzLl9yZWFkT25seShcInZvbHVtZVwiKTtcblxuXHRcdC8vc2V0IHRoZSBtdXRlIGluaXRpYWxseVxuXHRcdHRoaXMubXV0ZSA9IG9wdGlvbnMubXV0ZTtcblx0fTtcblxuXHRUb25lLmV4dGVuZChUb25lLlZvbHVtZSwgVG9uZS5BdWRpb05vZGUpO1xuXG5cdC8qKlxuXHQgKiAgRGVmYXVsdHNcblx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHQgKiAgQGNvbnN0XG5cdCAqICBAc3RhdGljXG5cdCAqL1xuXHRUb25lLlZvbHVtZS5kZWZhdWx0cyA9IHtcblx0XHRcInZvbHVtZVwiIDogMCxcblx0XHRcIm11dGVcIiA6IGZhbHNlXG5cdH07XG5cblx0LyoqXG5cdCAqIE11dGUgdGhlIG91dHB1dC5cblx0ICogQG1lbWJlck9mIFRvbmUuVm9sdW1lI1xuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0ICogQG5hbWUgbXV0ZVxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvL211dGUgdGhlIG91dHB1dFxuXHQgKiB2b2x1bWUubXV0ZSA9IHRydWU7XG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Wb2x1bWUucHJvdG90eXBlLCBcIm11dGVcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy52b2x1bWUudmFsdWUgPT09IC1JbmZpbml0eTtcblx0XHR9LFxuXHRcdHNldCA6IGZ1bmN0aW9uKG11dGUpe1xuXHRcdFx0aWYgKCF0aGlzLm11dGUgJiYgbXV0ZSl7XG5cdFx0XHRcdHRoaXMuX3VubXV0ZWRWb2x1bWUgPSB0aGlzLnZvbHVtZS52YWx1ZTtcblx0XHRcdFx0Ly9tYXliZSBpdCBzaG91bGQgcmFtcCBoZXJlP1xuXHRcdFx0XHR0aGlzLnZvbHVtZS52YWx1ZSA9IC1JbmZpbml0eTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5tdXRlICYmICFtdXRlKXtcblx0XHRcdFx0dGhpcy52b2x1bWUudmFsdWUgPSB0aGlzLl91bm11dGVkVm9sdW1lO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqICBjbGVhbiB1cFxuXHQgKiAgQHJldHVybnMge1RvbmUuVm9sdW1lfSB0aGlzXG5cdCAqL1xuXHRUb25lLlZvbHVtZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCl7XG5cdFx0dGhpcy5pbnB1dC5kaXNwb3NlKCk7XG5cdFx0VG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0XHR0aGlzLl93cml0YWJsZShcInZvbHVtZVwiKTtcblx0XHR0aGlzLnZvbHVtZS5kaXNwb3NlKCk7XG5cdFx0dGhpcy52b2x1bWUgPSBudWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdHJldHVybiBUb25lLlZvbHVtZTtcbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUVBO0FBRUE7Ozs7Ozs7Ozs7O0FBVUE7QUFFQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRkE7QUFLQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFBQTtBQUpBO0FBZUE7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/component/Volume.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/core/AudioNode.js":
/*!**************************************************!*\
  !*** ./node_modules/tone/Tone/core/AudioNode.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/core/Context */ \"./node_modules/tone/Tone/core/Context.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  /**\n   *  @class Tone.AudioNode is the base class for classes which process audio.\n   *         AudioNodes have inputs and outputs.\n   *  @param\t{AudioContext=} context\tThe audio context to use with the class\n   *  @extends {Tone}\n   */\n  Tone.AudioNode = function () {\n    Tone.call(this); //use the default context if one is not passed in\n\n    var options = Tone.defaults(arguments, [\"context\"], {\n      \"context\": Tone.context\n    });\n    /**\n     * The AudioContext of this instance\n     * @private\n     * @type {AudioContext}\n     */\n\n    this._context = options.context;\n  };\n\n  Tone.extend(Tone.AudioNode);\n  /**\n   * Get the audio context belonging to this instance.\n   * @type {Tone.Context}\n   * @memberOf Tone.AudioNode#\n   * @name context\n   * @readOnly\n   */\n\n  Object.defineProperty(Tone.AudioNode.prototype, \"context\", {\n    get: function () {\n      function get() {\n        return this._context;\n      }\n\n      return get;\n    }()\n  });\n  /**\n   *  Create input and outputs for this object.\n   *  @param  {Number}  [input=0]   The number of inputs\n   *  @param  {Number}  [outputs=0]  The number of outputs\n   *  @return  {Tone.AudioNode}  this\n   *  @private\n   */\n\n  Tone.AudioNode.prototype.createInsOuts = function (inputs, outputs) {\n    if (inputs === 1) {\n      this.input = this.context.createGain();\n    } else if (inputs > 1) {\n      this.input = new Array(inputs);\n    }\n\n    if (outputs === 1) {\n      this.output = this.context.createGain();\n    } else if (outputs > 1) {\n      this.output = new Array(outputs);\n    }\n  };\n  /**\n   *  channelCount is the number of channels used when up-mixing and down-mixing\n   *  connections to any inputs to the node. The default value is 2 except for\n   *  specific nodes where its value is specially determined.\n   *\n   *  @memberof Tone.AudioNode#\n   *  @type {Number}\n   *  @name channelCount\n   *  @readOnly\n   */\n\n\n  Object.defineProperty(Tone.AudioNode.prototype, \"channelCount\", {\n    get: function () {\n      function get() {\n        return this.output.channelCount;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(c) {\n        return this.output.channelCount = c;\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  channelCountMode determines how channels will be counted when up-mixing and\n   *  down-mixing connections to any inputs to the node.\n   *  The default value is \"max\". This attribute has no effect for nodes with no inputs.\n   *  @memberof Tone.AudioNode#\n   *  @type {String}\n   *  @name channelCountMode\n   *  @readOnly\n   */\n\n  Object.defineProperty(Tone.AudioNode.prototype, \"channelCountMode\", {\n    get: function () {\n      function get() {\n        return this.output.channelCountMode;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(m) {\n        return this.output.channelCountMode = m;\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  channelInterpretation determines how individual channels will be treated\n   *  when up-mixing and down-mixing connections to any inputs to the node.\n   *  The default value is \"speakers\".\n   *  @memberof Tone.AudioNode#\n   *  @type {String}\n   *  @name channelInterpretation\n   *  @readOnly\n   */\n\n  Object.defineProperty(Tone.AudioNode.prototype, \"channelInterpretation\", {\n    get: function () {\n      function get() {\n        return this.output.channelInterpretation;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(i) {\n        return this.output.channelInterpretation = i;\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  The number of inputs feeding into the AudioNode.\n   *  For source nodes, this will be 0.\n   *  @type {Number}\n   *  @name numberOfInputs\n   *  @memberof Tone.AudioNode#\n   *  @readOnly\n   */\n\n  Object.defineProperty(Tone.AudioNode.prototype, \"numberOfInputs\", {\n    get: function () {\n      function get() {\n        if (this.input) {\n          if (Tone.isArray(this.input)) {\n            return this.input.length;\n          } else {\n            return 1;\n          }\n        } else {\n          return 0;\n        }\n      }\n\n      return get;\n    }()\n  });\n  /**\n   *  The number of outputs coming out of the AudioNode.\n   *  @type {Number}\n   *  @name numberOfOutputs\n   *  @memberof Tone.AudioNode#\n   *  @readOnly\n   */\n\n  Object.defineProperty(Tone.AudioNode.prototype, \"numberOfOutputs\", {\n    get: function () {\n      function get() {\n        if (this.output) {\n          if (Tone.isArray(this.output)) {\n            return this.output.length;\n          } else {\n            return 1;\n          }\n        } else {\n          return 0;\n        }\n      }\n\n      return get;\n    }()\n  });\n  /**\n   * Called when an audio param connects to this node\n   * @private\n   */\n\n  Tone.AudioNode.prototype._onConnect = function () {};\n  /**\n   *  connect the output of a ToneNode to an AudioParam, AudioNode, or ToneNode\n   *  @param  {Tone | AudioParam | AudioNode} unit\n   *  @param {number} [outputNum=0] optionally which output to connect from\n   *  @param {number} [inputNum=0] optionally which input to connect to\n   *  @returns {Tone.AudioNode} this\n   */\n\n\n  Tone.AudioNode.prototype.connect = function (unit, outputNum, inputNum) {\n    if (unit._onConnect) {\n      unit._onConnect(this);\n    }\n\n    if (Tone.isArray(this.output)) {\n      outputNum = Tone.defaultArg(outputNum, 0);\n      this.output[outputNum].connect(unit, 0, inputNum);\n    } else {\n      this.output.connect(unit, outputNum, inputNum);\n    }\n\n    return this;\n  };\n  /**\n   *  disconnect the output\n   *  @param {Number|AudioNode} output Either the output index to disconnect\n   *                                   if the output is an array, or the\n   *                                   node to disconnect from.\n   *  @returns {Tone.AudioNode} this\n   */\n\n\n  Tone.AudioNode.prototype.disconnect = function (destination, outputNum, inputNum) {\n    if (Tone.isArray(this.output)) {\n      if (Tone.isNumber(destination)) {\n        this.output[destination].disconnect();\n      } else {\n        outputNum = Tone.defaultArg(outputNum, 0);\n        this.output[outputNum].disconnect(destination, 0, inputNum);\n      }\n    } else {\n      this.output.disconnect.apply(this.output, arguments);\n    }\n  };\n  /**\n   *  Connect the output of this node to the rest of the nodes in series.\n   *  @example\n   *  //connect a node to an effect, panVol and then to the master output\n   *  node.chain(effect, panVol, Tone.Master);\n   *  @param {...AudioParam|Tone|AudioNode} nodes\n   *  @returns {Tone.AudioNode} this\n   *  @private\n   */\n\n\n  Tone.AudioNode.prototype.chain = function () {\n    var currentUnit = this;\n\n    for (var i = 0; i < arguments.length; i++) {\n      var toUnit = arguments[i];\n      currentUnit.connect(toUnit);\n      currentUnit = toUnit;\n    }\n\n    return this;\n  };\n  /**\n   *  connect the output of this node to the rest of the nodes in parallel.\n   *  @param {...AudioParam|Tone|AudioNode} nodes\n   *  @returns {Tone.AudioNode} this\n   *  @private\n   */\n\n\n  Tone.AudioNode.prototype.fan = function () {\n    for (var i = 0; i < arguments.length; i++) {\n      this.connect(arguments[i]);\n    }\n\n    return this;\n  };\n\n  if (window.AudioNode) {\n    //give native nodes chain and fan methods\n    AudioNode.prototype.chain = Tone.AudioNode.prototype.chain;\n    AudioNode.prototype.fan = Tone.AudioNode.prototype.fan;\n  }\n  /**\n   * Dispose and disconnect\n   * @return {Tone.AudioNode} this\n   */\n\n\n  Tone.AudioNode.prototype.dispose = function () {\n    if (Tone.isDefined(this.input)) {\n      if (this.input instanceof AudioNode) {\n        this.input.disconnect();\n      }\n\n      this.input = null;\n    }\n\n    if (Tone.isDefined(this.output)) {\n      if (this.output instanceof AudioNode) {\n        this.output.disconnect();\n      }\n\n      this.output = null;\n    }\n\n    this._context = null;\n    return this;\n  };\n\n  return Tone.AudioNode;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvQXVkaW9Ob2RlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RvbmUvVG9uZS9jb3JlL0F1ZGlvTm9kZS5qcz8xNTU5Il0sInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbXCJUb25lL2NvcmUvVG9uZVwiLCBcIlRvbmUvY29yZS9Db250ZXh0XCJdLCBmdW5jdGlvbihUb25lKXtcblxuXHQvKipcblx0ICogIEBjbGFzcyBUb25lLkF1ZGlvTm9kZSBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgY2xhc3NlcyB3aGljaCBwcm9jZXNzIGF1ZGlvLlxuXHQgKiAgICAgICAgIEF1ZGlvTm9kZXMgaGF2ZSBpbnB1dHMgYW5kIG91dHB1dHMuXG5cdCAqICBAcGFyYW1cdHtBdWRpb0NvbnRleHQ9fSBjb250ZXh0XHRUaGUgYXVkaW8gY29udGV4dCB0byB1c2Ugd2l0aCB0aGUgY2xhc3Ncblx0ICogIEBleHRlbmRzIHtUb25lfVxuXHQgKi9cblx0VG9uZS5BdWRpb05vZGUgPSBmdW5jdGlvbigpe1xuXHRcdFRvbmUuY2FsbCh0aGlzKTtcblxuXHRcdC8vdXNlIHRoZSBkZWZhdWx0IGNvbnRleHQgaWYgb25lIGlzIG5vdCBwYXNzZWQgaW5cblx0XHR2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXCJjb250ZXh0XCJdLCB7XG5cdFx0XHRcImNvbnRleHRcIiA6IFRvbmUuY29udGV4dFxuXHRcdH0pO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIEF1ZGlvQ29udGV4dCBvZiB0aGlzIGluc3RhbmNlXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAdHlwZSB7QXVkaW9Db250ZXh0fVxuXHRcdCAqL1xuXHRcdHRoaXMuX2NvbnRleHQgPSBvcHRpb25zLmNvbnRleHQ7XG5cdH07XG5cblx0VG9uZS5leHRlbmQoVG9uZS5BdWRpb05vZGUpO1xuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGF1ZGlvIGNvbnRleHQgYmVsb25naW5nIHRvIHRoaXMgaW5zdGFuY2UuXG5cdCAqIEB0eXBlIHtUb25lLkNvbnRleHR9XG5cdCAqIEBtZW1iZXJPZiBUb25lLkF1ZGlvTm9kZSNcblx0ICogQG5hbWUgY29udGV4dFxuXHQgKiBAcmVhZE9ubHlcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB7XG5cdFx0Z2V0IDogZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiB0aGlzLl9jb250ZXh0O1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqICBDcmVhdGUgaW5wdXQgYW5kIG91dHB1dHMgZm9yIHRoaXMgb2JqZWN0LlxuXHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgW2lucHV0PTBdICAgVGhlIG51bWJlciBvZiBpbnB1dHNcblx0ICogIEBwYXJhbSAge051bWJlcn0gIFtvdXRwdXRzPTBdICBUaGUgbnVtYmVyIG9mIG91dHB1dHNcblx0ICogIEByZXR1cm4gIHtUb25lLkF1ZGlvTm9kZX0gIHRoaXNcblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuY3JlYXRlSW5zT3V0cyA9IGZ1bmN0aW9uKGlucHV0cywgb3V0cHV0cyl7XG5cblx0XHRpZiAoaW5wdXRzID09PSAxKXtcblx0XHRcdHRoaXMuaW5wdXQgPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuXHRcdH0gZWxzZSBpZiAoaW5wdXRzID4gMSl7XG5cdFx0XHR0aGlzLmlucHV0ID0gbmV3IEFycmF5KGlucHV0cyk7XG5cdFx0fVxuXG5cdFx0aWYgKG91dHB1dHMgPT09IDEpe1xuXHRcdFx0dGhpcy5vdXRwdXQgPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuXHRcdH0gZWxzZSBpZiAob3V0cHV0cyA+IDEpe1xuXHRcdFx0dGhpcy5vdXRwdXQgPSBuZXcgQXJyYXkob3V0cHV0cyk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiAgY2hhbm5lbENvdW50IGlzIHRoZSBudW1iZXIgb2YgY2hhbm5lbHMgdXNlZCB3aGVuIHVwLW1peGluZyBhbmQgZG93bi1taXhpbmdcblx0ICogIGNvbm5lY3Rpb25zIHRvIGFueSBpbnB1dHMgdG8gdGhlIG5vZGUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDIgZXhjZXB0IGZvclxuXHQgKiAgc3BlY2lmaWMgbm9kZXMgd2hlcmUgaXRzIHZhbHVlIGlzIHNwZWNpYWxseSBkZXRlcm1pbmVkLlxuXHQgKlxuXHQgKiAgQG1lbWJlcm9mIFRvbmUuQXVkaW9Ob2RlI1xuXHQgKiAgQHR5cGUge051bWJlcn1cblx0ICogIEBuYW1lIGNoYW5uZWxDb3VudFxuXHQgKiAgQHJlYWRPbmx5XG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLCBcImNoYW5uZWxDb3VudFwiLCB7XG5cdFx0Z2V0IDogZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiB0aGlzLm91dHB1dC5jaGFubmVsQ291bnQ7XG5cdFx0fSxcblx0XHRzZXQgOiBmdW5jdGlvbihjKXtcblx0XHRcdHJldHVybiB0aGlzLm91dHB1dC5jaGFubmVsQ291bnQgPSBjO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqICBjaGFubmVsQ291bnRNb2RlIGRldGVybWluZXMgaG93IGNoYW5uZWxzIHdpbGwgYmUgY291bnRlZCB3aGVuIHVwLW1peGluZyBhbmRcblx0ICogIGRvd24tbWl4aW5nIGNvbm5lY3Rpb25zIHRvIGFueSBpbnB1dHMgdG8gdGhlIG5vZGUuXG5cdCAqICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBcIm1heFwiLiBUaGlzIGF0dHJpYnV0ZSBoYXMgbm8gZWZmZWN0IGZvciBub2RlcyB3aXRoIG5vIGlucHV0cy5cblx0ICogIEBtZW1iZXJvZiBUb25lLkF1ZGlvTm9kZSNcblx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdCAqICBAbmFtZSBjaGFubmVsQ291bnRNb2RlXG5cdCAqICBAcmVhZE9ubHlcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUsIFwiY2hhbm5lbENvdW50TW9kZVwiLCB7XG5cdFx0Z2V0IDogZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiB0aGlzLm91dHB1dC5jaGFubmVsQ291bnRNb2RlO1xuXHRcdH0sXG5cdFx0c2V0IDogZnVuY3Rpb24obSl7XG5cdFx0XHRyZXR1cm4gdGhpcy5vdXRwdXQuY2hhbm5lbENvdW50TW9kZSA9IG07XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogIGNoYW5uZWxJbnRlcnByZXRhdGlvbiBkZXRlcm1pbmVzIGhvdyBpbmRpdmlkdWFsIGNoYW5uZWxzIHdpbGwgYmUgdHJlYXRlZFxuXHQgKiAgd2hlbiB1cC1taXhpbmcgYW5kIGRvd24tbWl4aW5nIGNvbm5lY3Rpb25zIHRvIGFueSBpbnB1dHMgdG8gdGhlIG5vZGUuXG5cdCAqICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBcInNwZWFrZXJzXCIuXG5cdCAqICBAbWVtYmVyb2YgVG9uZS5BdWRpb05vZGUjXG5cdCAqICBAdHlwZSB7U3RyaW5nfVxuXHQgKiAgQG5hbWUgY2hhbm5lbEludGVycHJldGF0aW9uXG5cdCAqICBAcmVhZE9ubHlcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUsIFwiY2hhbm5lbEludGVycHJldGF0aW9uXCIsIHtcblx0XHRnZXQgOiBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIHRoaXMub3V0cHV0LmNoYW5uZWxJbnRlcnByZXRhdGlvbjtcblx0XHR9LFxuXHRcdHNldCA6IGZ1bmN0aW9uKGkpe1xuXHRcdFx0cmV0dXJuIHRoaXMub3V0cHV0LmNoYW5uZWxJbnRlcnByZXRhdGlvbiA9IGk7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogIFRoZSBudW1iZXIgb2YgaW5wdXRzIGZlZWRpbmcgaW50byB0aGUgQXVkaW9Ob2RlLlxuXHQgKiAgRm9yIHNvdXJjZSBub2RlcywgdGhpcyB3aWxsIGJlIDAuXG5cdCAqICBAdHlwZSB7TnVtYmVyfVxuXHQgKiAgQG5hbWUgbnVtYmVyT2ZJbnB1dHNcblx0ICogIEBtZW1iZXJvZiBUb25lLkF1ZGlvTm9kZSNcblx0ICogIEByZWFkT25seVxuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZSwgXCJudW1iZXJPZklucHV0c1wiLCB7XG5cdFx0Z2V0IDogZnVuY3Rpb24oKXtcblx0XHRcdGlmICh0aGlzLmlucHV0KXtcblx0XHRcdFx0aWYgKFRvbmUuaXNBcnJheSh0aGlzLmlucHV0KSl7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuaW5wdXQubGVuZ3RoO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiAgVGhlIG51bWJlciBvZiBvdXRwdXRzIGNvbWluZyBvdXQgb2YgdGhlIEF1ZGlvTm9kZS5cblx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdCAqICBAbmFtZSBudW1iZXJPZk91dHB1dHNcblx0ICogIEBtZW1iZXJvZiBUb25lLkF1ZGlvTm9kZSNcblx0ICogIEByZWFkT25seVxuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZSwgXCJudW1iZXJPZk91dHB1dHNcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRpZiAodGhpcy5vdXRwdXQpe1xuXHRcdFx0XHRpZiAoVG9uZS5pc0FycmF5KHRoaXMub3V0cHV0KSl7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMub3V0cHV0Lmxlbmd0aDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gYW4gYXVkaW8gcGFyYW0gY29ubmVjdHMgdG8gdGhpcyBub2RlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuX29uQ29ubmVjdCA9IGZ1bmN0aW9uKCl7fTtcblxuXHQvKipcblx0ICogIGNvbm5lY3QgdGhlIG91dHB1dCBvZiBhIFRvbmVOb2RlIHRvIGFuIEF1ZGlvUGFyYW0sIEF1ZGlvTm9kZSwgb3IgVG9uZU5vZGVcblx0ICogIEBwYXJhbSAge1RvbmUgfCBBdWRpb1BhcmFtIHwgQXVkaW9Ob2RlfSB1bml0XG5cdCAqICBAcGFyYW0ge251bWJlcn0gW291dHB1dE51bT0wXSBvcHRpb25hbGx5IHdoaWNoIG91dHB1dCB0byBjb25uZWN0IGZyb21cblx0ICogIEBwYXJhbSB7bnVtYmVyfSBbaW5wdXROdW09MF0gb3B0aW9uYWxseSB3aGljaCBpbnB1dCB0byBjb25uZWN0IHRvXG5cdCAqICBAcmV0dXJucyB7VG9uZS5BdWRpb05vZGV9IHRoaXNcblx0ICovXG5cdFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24odW5pdCwgb3V0cHV0TnVtLCBpbnB1dE51bSl7XG5cdFx0aWYgKHVuaXQuX29uQ29ubmVjdCl7XG5cdFx0XHR1bml0Ll9vbkNvbm5lY3QodGhpcyk7XG5cdFx0fVxuXHRcdGlmIChUb25lLmlzQXJyYXkodGhpcy5vdXRwdXQpKXtcblx0XHRcdG91dHB1dE51bSA9IFRvbmUuZGVmYXVsdEFyZyhvdXRwdXROdW0sIDApO1xuXHRcdFx0dGhpcy5vdXRwdXRbb3V0cHV0TnVtXS5jb25uZWN0KHVuaXQsIDAsIGlucHV0TnVtKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5vdXRwdXQuY29ubmVjdCh1bml0LCBvdXRwdXROdW0sIGlucHV0TnVtKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqICBkaXNjb25uZWN0IHRoZSBvdXRwdXRcblx0ICogIEBwYXJhbSB7TnVtYmVyfEF1ZGlvTm9kZX0gb3V0cHV0IEVpdGhlciB0aGUgb3V0cHV0IGluZGV4IHRvIGRpc2Nvbm5lY3Rcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHRoZSBvdXRwdXQgaXMgYW4gYXJyYXksIG9yIHRoZVxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSB0byBkaXNjb25uZWN0IGZyb20uXG5cdCAqICBAcmV0dXJucyB7VG9uZS5BdWRpb05vZGV9IHRoaXNcblx0ICovXG5cdFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oZGVzdGluYXRpb24sIG91dHB1dE51bSwgaW5wdXROdW0pe1xuXHRcdGlmIChUb25lLmlzQXJyYXkodGhpcy5vdXRwdXQpKXtcblx0XHRcdGlmIChUb25lLmlzTnVtYmVyKGRlc3RpbmF0aW9uKSl7XG5cdFx0XHRcdHRoaXMub3V0cHV0W2Rlc3RpbmF0aW9uXS5kaXNjb25uZWN0KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXROdW0gPSBUb25lLmRlZmF1bHRBcmcob3V0cHV0TnVtLCAwKTtcblx0XHRcdFx0dGhpcy5vdXRwdXRbb3V0cHV0TnVtXS5kaXNjb25uZWN0KGRlc3RpbmF0aW9uLCAwLCBpbnB1dE51bSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMub3V0cHV0LmRpc2Nvbm5lY3QuYXBwbHkodGhpcy5vdXRwdXQsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiAgQ29ubmVjdCB0aGUgb3V0cHV0IG9mIHRoaXMgbm9kZSB0byB0aGUgcmVzdCBvZiB0aGUgbm9kZXMgaW4gc2VyaWVzLlxuXHQgKiAgQGV4YW1wbGVcblx0ICogIC8vY29ubmVjdCBhIG5vZGUgdG8gYW4gZWZmZWN0LCBwYW5Wb2wgYW5kIHRoZW4gdG8gdGhlIG1hc3RlciBvdXRwdXRcblx0ICogIG5vZGUuY2hhaW4oZWZmZWN0LCBwYW5Wb2wsIFRvbmUuTWFzdGVyKTtcblx0ICogIEBwYXJhbSB7Li4uQXVkaW9QYXJhbXxUb25lfEF1ZGlvTm9kZX0gbm9kZXNcblx0ICogIEByZXR1cm5zIHtUb25lLkF1ZGlvTm9kZX0gdGhpc1xuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIGN1cnJlbnRVbml0ID0gdGhpcztcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG5cdFx0XHR2YXIgdG9Vbml0ID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0Y3VycmVudFVuaXQuY29ubmVjdCh0b1VuaXQpO1xuXHRcdFx0Y3VycmVudFVuaXQgPSB0b1VuaXQ7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgY29ubmVjdCB0aGUgb3V0cHV0IG9mIHRoaXMgbm9kZSB0byB0aGUgcmVzdCBvZiB0aGUgbm9kZXMgaW4gcGFyYWxsZWwuXG5cdCAqICBAcGFyYW0gey4uLkF1ZGlvUGFyYW18VG9uZXxBdWRpb05vZGV9IG5vZGVzXG5cdCAqICBAcmV0dXJucyB7VG9uZS5BdWRpb05vZGV9IHRoaXNcblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZmFuID0gZnVuY3Rpb24oKXtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG5cdFx0XHR0aGlzLmNvbm5lY3QoYXJndW1lbnRzW2ldKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0aWYgKHdpbmRvdy5BdWRpb05vZGUpe1xuXHRcdC8vZ2l2ZSBuYXRpdmUgbm9kZXMgY2hhaW4gYW5kIGZhbiBtZXRob2RzXG5cdFx0QXVkaW9Ob2RlLnByb3RvdHlwZS5jaGFpbiA9IFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5jaGFpbjtcblx0XHRBdWRpb05vZGUucHJvdG90eXBlLmZhbiA9IFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5mYW47XG5cdH1cblxuXHQvKipcblx0ICogRGlzcG9zZSBhbmQgZGlzY29ubmVjdFxuXHQgKiBAcmV0dXJuIHtUb25lLkF1ZGlvTm9kZX0gdGhpc1xuXHQgKi9cblx0VG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpe1xuXHRcdGlmIChUb25lLmlzRGVmaW5lZCh0aGlzLmlucHV0KSl7XG5cdFx0XHRpZiAodGhpcy5pbnB1dCBpbnN0YW5jZW9mIEF1ZGlvTm9kZSl7XG5cdFx0XHRcdHRoaXMuaW5wdXQuZGlzY29ubmVjdCgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5pbnB1dCA9IG51bGw7XG5cdFx0fVxuXHRcdGlmIChUb25lLmlzRGVmaW5lZCh0aGlzLm91dHB1dCkpe1xuXHRcdFx0aWYgKHRoaXMub3V0cHV0IGluc3RhbmNlb2YgQXVkaW9Ob2RlKXtcblx0XHRcdFx0dGhpcy5vdXRwdXQuZGlzY29ubmVjdCgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5vdXRwdXQgPSBudWxsO1xuXHRcdH1cblx0XHR0aGlzLl9jb250ZXh0ID0gbnVsbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHRyZXR1cm4gVG9uZS5BdWRpb05vZGU7XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQURBO0FBSUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQURBO0FBTUE7Ozs7Ozs7O0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBSkE7QUFTQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUpBO0FBU0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFKQTtBQVNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFBQTtBQURBO0FBY0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBQUE7QUFEQTtBQWNBOzs7OztBQUlBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/core/AudioNode.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/core/Buffer.js":
/*!***********************************************!*\
  !*** ./node_modules/tone/Tone/core/Buffer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/core/Emitter */ \"./node_modules/tone/Tone/core/Emitter.js\"), __webpack_require__(/*! Tone/type/Type */ \"./node_modules/tone/Tone/type/Type.js\"), __webpack_require__(/*! Tone/shim/AudioBuffer */ \"./node_modules/tone/Tone/shim/AudioBuffer.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  \"use strict\";\n  /**\n   *  @class  Buffer loading and storage. Tone.Buffer is used internally by all\n   *          classes that make requests for audio files such as Tone.Player,\n   *          Tone.Sampler and Tone.Convolver.\n   *\n   *          Aside from load callbacks from individual buffers, Tone.Buffer\n   *  \t\tprovides events which keep track of the loading progress\n   *  \t\tof _all_ of the buffers. These are Tone.Buffer.on(\"load\" / \"progress\" / \"error\")\n   *\n   *  @constructor\n   *  @extends {Tone}\n   *  @param {AudioBuffer|String} url The url to load, or the audio buffer to set.\n   *  @param {Function=} onload A callback which is invoked after the buffer is loaded.\n   *                            It's recommended to use `Tone.Buffer.on('load', callback)` instead\n   *                            since it will give you a callback when _all_ buffers are loaded.\n   *  @param {Function=} onerror The callback to invoke if there is an error\n   *  @example\n   * var buffer = new Tone.Buffer(\"path/to/sound.mp3\", function(){\n   * \t//the buffer is now available.\n   * \tvar buff = buffer.get();\n   * });\n   *  @example\n   * //can load provide fallback extension types if the first type is not supported.\n   * var buffer = new Tone.Buffer(\"path/to/sound.[mp3|ogg|wav]\");\n   */\n\n  Tone.Buffer = function () {\n    var options = Tone.defaults(arguments, [\"url\", \"onload\", \"onerror\"], Tone.Buffer);\n    Tone.call(this);\n    /**\n     *  stores the loaded AudioBuffer\n     *  @type {AudioBuffer}\n     *  @private\n     */\n\n    this._buffer = null;\n    /**\n     *  indicates if the buffer should be reversed or not\n     *  @type {Boolean}\n     *  @private\n     */\n\n    this._reversed = options.reverse;\n    /**\n     *  The XHR\n     *  @type  {XMLHttpRequest}\n     *  @private\n     */\n\n    this._xhr = null;\n    /**\n     * Private callback when the buffer is loaded.\n     * @type {Function}\n     * @private\n     */\n\n    this._onload = Tone.noOp;\n\n    if (options.url instanceof AudioBuffer || options.url instanceof Tone.Buffer) {\n      this.set(options.url); // invoke the onload callback\n\n      if (options.onload) {\n        if (this.loaded) {\n          options.onload(this);\n        } else {\n          this._onload = options.onload;\n        }\n      }\n    } else if (Tone.isString(options.url)) {\n      this.load(options.url).then(options.onload)[\"catch\"](options.onerror);\n    }\n  };\n\n  Tone.extend(Tone.Buffer);\n  /**\n   *  the default parameters\n   *  @type {Object}\n   */\n\n  Tone.Buffer.defaults = {\n    \"url\": undefined,\n    \"reverse\": false,\n    \"onload\": Tone.noOp,\n    \"onerror\": Tone.noOp\n  };\n  /**\n   *  Pass in an AudioBuffer or Tone.Buffer to set the value\n   *  of this buffer.\n   *  @param {AudioBuffer|Tone.Buffer} buffer the buffer\n   *  @returns {Tone.Buffer} this\n   */\n\n  Tone.Buffer.prototype.set = function (buffer) {\n    if (buffer instanceof Tone.Buffer) {\n      if (buffer.loaded) {\n        this._buffer = buffer.get();\n      } else {\n        buffer._onload = function () {\n          this.set(buffer);\n\n          this._onload(this);\n        }.bind(this);\n      }\n    } else {\n      this._buffer = buffer;\n    }\n\n    return this;\n  };\n  /**\n   *  @return {AudioBuffer} The audio buffer stored in the object.\n   */\n\n\n  Tone.Buffer.prototype.get = function () {\n    return this._buffer;\n  };\n  /**\n   *  Makes an xhr reqest for the selected url then decodes\n   *  the file as an audio buffer. Invokes\n   *  the callback once the audio buffer loads.\n   *  @param {String} url The url of the buffer to load.\n   *                      filetype support depends on the\n   *                      browser.\n   *  @returns {Promise} returns a Promise which resolves with the Tone.Buffer\n   */\n\n\n  Tone.Buffer.prototype.load = function (url, onload, onerror) {\n    var promise = new Promise(function (load, error) {\n      this._xhr = Tone.Buffer.load(url, //success\n      function (buff) {\n        this._xhr = null;\n        this.set(buff);\n        load(this);\n\n        this._onload(this);\n\n        if (onload) {\n          onload(this);\n        }\n      }.bind(this), //error\n      function (err) {\n        this._xhr = null;\n        error(err);\n\n        if (onerror) {\n          onerror(err);\n        }\n      }.bind(this));\n    }.bind(this));\n    return promise;\n  };\n  /**\n   *  dispose and disconnect\n   *  @returns {Tone.Buffer} this\n   */\n\n\n  Tone.Buffer.prototype.dispose = function () {\n    Tone.prototype.dispose.call(this);\n    this._buffer = null;\n\n    if (this._xhr) {\n      Tone.Buffer._removeFromDownloadQueue(this._xhr);\n\n      this._xhr.abort();\n\n      this._xhr = null;\n    }\n\n    return this;\n  };\n  /**\n   * If the buffer is loaded or not\n   * @memberOf Tone.Buffer#\n   * @type {Boolean}\n   * @name loaded\n   * @readOnly\n   */\n\n\n  Object.defineProperty(Tone.Buffer.prototype, \"loaded\", {\n    get: function () {\n      function get() {\n        return this.length > 0;\n      }\n\n      return get;\n    }()\n  });\n  /**\n   * The duration of the buffer.\n   * @memberOf Tone.Buffer#\n   * @type {Number}\n   * @name duration\n   * @readOnly\n   */\n\n  Object.defineProperty(Tone.Buffer.prototype, \"duration\", {\n    get: function () {\n      function get() {\n        if (this._buffer) {\n          return this._buffer.duration;\n        } else {\n          return 0;\n        }\n      }\n\n      return get;\n    }()\n  });\n  /**\n   * The length of the buffer in samples\n   * @memberOf Tone.Buffer#\n   * @type {Number}\n   * @name length\n   * @readOnly\n   */\n\n  Object.defineProperty(Tone.Buffer.prototype, \"length\", {\n    get: function () {\n      function get() {\n        if (this._buffer) {\n          return this._buffer.length;\n        } else {\n          return 0;\n        }\n      }\n\n      return get;\n    }()\n  });\n  /**\n   * The number of discrete audio channels. Returns 0 if no buffer\n   * is loaded.\n   * @memberOf Tone.Buffer#\n   * @type {Number}\n   * @name numberOfChannels\n   * @readOnly\n   */\n\n  Object.defineProperty(Tone.Buffer.prototype, \"numberOfChannels\", {\n    get: function () {\n      function get() {\n        if (this._buffer) {\n          return this._buffer.numberOfChannels;\n        } else {\n          return 0;\n        }\n      }\n\n      return get;\n    }()\n  });\n  /**\n   *  Set the audio buffer from the array. To create a multichannel AudioBuffer,\n   *  pass in a multidimensional array.\n   *  @param {Float32Array} array The array to fill the audio buffer\n   *  @return {Tone.Buffer} this\n   */\n\n  Tone.Buffer.prototype.fromArray = function (array) {\n    var isMultidimensional = array[0].length > 0;\n    var channels = isMultidimensional ? array.length : 1;\n    var len = isMultidimensional ? array[0].length : array.length;\n    var buffer = this.context.createBuffer(channels, len, this.context.sampleRate);\n\n    if (!isMultidimensional && channels === 1) {\n      array = [array];\n    }\n\n    for (var c = 0; c < channels; c++) {\n      buffer.copyToChannel(array[c], c);\n    }\n\n    this._buffer = buffer;\n    return this;\n  };\n  /**\n   * \tSums muliple channels into 1 channel\n   *  @param {Number=} channel Optionally only copy a single channel from the array.\n   *  @return {Array}\n   */\n\n\n  Tone.Buffer.prototype.toMono = function (chanNum) {\n    if (Tone.isNumber(chanNum)) {\n      this.fromArray(this.toArray(chanNum));\n    } else {\n      var outputArray = new Float32Array(this.length);\n      var numChannels = this.numberOfChannels;\n\n      for (var channel = 0; channel < numChannels; channel++) {\n        var channelArray = this.toArray(channel);\n\n        for (var i = 0; i < channelArray.length; i++) {\n          outputArray[i] += channelArray[i];\n        }\n      } //divide by the number of channels\n\n\n      outputArray = outputArray.map(function (sample) {\n        return sample / numChannels;\n      });\n      this.fromArray(outputArray);\n    }\n\n    return this;\n  };\n  /**\n   * \tGet the buffer as an array. Single channel buffers will return a 1-dimensional\n   * \tFloat32Array, and multichannel buffers will return multidimensional arrays.\n   *  @param {Number=} channel Optionally only copy a single channel from the array.\n   *  @return {Array}\n   */\n\n\n  Tone.Buffer.prototype.toArray = function (channel) {\n    if (Tone.isNumber(channel)) {\n      return this.getChannelData(channel);\n    } else if (this.numberOfChannels === 1) {\n      return this.toArray(0);\n    } else {\n      var ret = [];\n\n      for (var c = 0; c < this.numberOfChannels; c++) {\n        ret[c] = this.getChannelData(c);\n      }\n\n      return ret;\n    }\n  };\n  /**\n   *  Returns the Float32Array representing the PCM audio data for the specific channel.\n   *  @param  {Number}  channel  The channel number to return\n   *  @return  {Float32Array}  The audio as a TypedArray\n   */\n\n\n  Tone.Buffer.prototype.getChannelData = function (channel) {\n    return this._buffer.getChannelData(channel);\n  };\n  /**\n   *  Cut a subsection of the array and return a buffer of the\n   *  subsection. Does not modify the original buffer\n   *  @param {Time} start The time to start the slice\n   *  @param {Time=} end The end time to slice. If none is given\n   *                     will default to the end of the buffer\n   *  @return {Tone.Buffer} this\n   */\n\n\n  Tone.Buffer.prototype.slice = function (start, end) {\n    end = Tone.defaultArg(end, this.duration);\n    var startSamples = Math.floor(this.context.sampleRate * this.toSeconds(start));\n    var endSamples = Math.floor(this.context.sampleRate * this.toSeconds(end));\n    var replacement = [];\n\n    for (var i = 0; i < this.numberOfChannels; i++) {\n      replacement[i] = this.toArray(i).slice(startSamples, endSamples);\n    }\n\n    var retBuffer = new Tone.Buffer().fromArray(replacement);\n    return retBuffer;\n  };\n  /**\n   *  Reverse the buffer.\n   *  @private\n   *  @return {Tone.Buffer} this\n   */\n\n\n  Tone.Buffer.prototype._reverse = function () {\n    if (this.loaded) {\n      for (var i = 0; i < this.numberOfChannels; i++) {\n        Array.prototype.reverse.call(this.getChannelData(i));\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Reverse the buffer.\n   * @memberOf Tone.Buffer#\n   * @type {Boolean}\n   * @name reverse\n   */\n\n\n  Object.defineProperty(Tone.Buffer.prototype, \"reverse\", {\n    get: function () {\n      function get() {\n        return this._reversed;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(rev) {\n        if (this._reversed !== rev) {\n          this._reversed = rev;\n\n          this._reverse();\n        }\n      }\n\n      return set;\n    }()\n  }); ///////////////////////////////////////////////////////////////////////////\n  // STATIC METHODS\n  ///////////////////////////////////////////////////////////////////////////\n  //statically inherits Emitter methods\n\n  Tone.Emitter.mixin(Tone.Buffer);\n  /**\n   *  the static queue for all of the xhr requests\n   *  @type {Array}\n   *  @private\n   */\n\n  Tone.Buffer._downloadQueue = [];\n  /**\n   *  A path which is prefixed before every url.\n   *  @type  {String}\n   *  @static\n   */\n\n  Tone.Buffer.baseUrl = \"\";\n  /**\n   *  Create a Tone.Buffer from the array. To create a multichannel AudioBuffer,\n   *  pass in a multidimensional array.\n   *  @param {Float32Array} array The array to fill the audio buffer\n   *  @return {Tone.Buffer} A Tone.Buffer created from the array\n   */\n\n  Tone.Buffer.fromArray = function (array) {\n    return new Tone.Buffer().fromArray(array);\n  };\n  /**\n   * Creates a Tone.Buffer from a URL, returns a promise\n   * which resolves to a Tone.Buffer\n   * @param  {String} url The url to load.\n   * @return {Promise<Tone.Buffer>}     A promise which resolves to a Tone.Buffer\n   */\n\n\n  Tone.Buffer.fromUrl = function (url) {\n    var buffer = new Tone.Buffer();\n    return buffer.load(url).then(function () {\n      return buffer;\n    });\n  };\n  /**\n   * Remove an xhr request from the download queue\n   * @private\n   */\n\n\n  Tone.Buffer._removeFromDownloadQueue = function (request) {\n    var index = Tone.Buffer._downloadQueue.indexOf(request);\n\n    if (index !== -1) {\n      Tone.Buffer._downloadQueue.splice(index, 1);\n    }\n  };\n  /**\n   *  Loads a url using XMLHttpRequest.\n   *  @param {String} url\n   *  @param {Function} onload\n   *  @param {Function} onerror\n   *  @param {Function} onprogress\n   *  @return {XMLHttpRequest}\n   */\n\n\n  Tone.Buffer.load = function (url, onload, onerror) {\n    //default\n    onload = Tone.defaultArg(onload, Tone.noOp); // test if the url contains multiple extensions\n\n    var matches = url.match(/\\[(.+\\|?)+\\]$/);\n\n    if (matches) {\n      var extensions = matches[1].split(\"|\");\n      var extension = extensions[0];\n\n      for (var i = 0; i < extensions.length; i++) {\n        if (Tone.Buffer.supportsType(extensions[i])) {\n          extension = extensions[i];\n          break;\n        }\n      }\n\n      url = url.replace(matches[0], extension);\n    }\n\n    function onError(e) {\n      Tone.Buffer._removeFromDownloadQueue(request);\n\n      Tone.Buffer.emit(\"error\", e);\n\n      if (onerror) {\n        onerror(e);\n      } else {\n        throw e;\n      }\n    }\n\n    function onProgress() {\n      //calculate the progress\n      var totalProgress = 0;\n\n      for (var i = 0; i < Tone.Buffer._downloadQueue.length; i++) {\n        totalProgress += Tone.Buffer._downloadQueue[i].progress;\n      }\n\n      Tone.Buffer.emit(\"progress\", totalProgress / Tone.Buffer._downloadQueue.length);\n    }\n\n    var request = new XMLHttpRequest();\n    request.open(\"GET\", Tone.Buffer.baseUrl + url, true);\n    request.responseType = \"arraybuffer\"; //start out as 0\n\n    request.progress = 0;\n\n    Tone.Buffer._downloadQueue.push(request);\n\n    request.addEventListener(\"load\", function () {\n      if (request.status === 200) {\n        Tone.context.decodeAudioData(request.response).then(function (buff) {\n          request.progress = 1;\n          onProgress();\n          onload(buff);\n\n          Tone.Buffer._removeFromDownloadQueue(request);\n\n          if (Tone.Buffer._downloadQueue.length === 0) {\n            //emit the event at the end\n            Tone.Buffer.emit(\"load\");\n          }\n        })[\"catch\"](function () {\n          Tone.Buffer._removeFromDownloadQueue(request);\n\n          onError(\"Tone.Buffer: could not decode audio data: \" + url);\n        });\n      } else {\n        onError(\"Tone.Buffer: could not locate file: \" + url);\n      }\n    });\n    request.addEventListener(\"error\", onError);\n    request.addEventListener(\"progress\", function (event) {\n      if (event.lengthComputable) {\n        //only go to 95%, the last 5% is when the audio is decoded\n        request.progress = event.loaded / event.total * 0.95;\n        onProgress();\n      }\n    });\n    request.send();\n    return request;\n  };\n  /**\n   *  Stop all of the downloads in progress\n   *  @return {Tone.Buffer}\n   *  @static\n   */\n\n\n  Tone.Buffer.cancelDownloads = function () {\n    Tone.Buffer._downloadQueue.slice().forEach(function (request) {\n      Tone.Buffer._removeFromDownloadQueue(request);\n\n      request.abort();\n    });\n\n    return Tone.Buffer;\n  };\n  /**\n   *  Checks a url's extension to see if the current browser can play that file type.\n   *  @param {String} url The url/extension to test\n   *  @return {Boolean} If the file extension can be played\n   *  @static\n   *  @example\n   * Tone.Buffer.supportsType(\"wav\"); //returns true\n   * Tone.Buffer.supportsType(\"path/to/file.wav\"); //returns true\n   */\n\n\n  Tone.Buffer.supportsType = function (url) {\n    var extension = url.split(\".\");\n    extension = extension[extension.length - 1];\n    var response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n    return response !== \"\";\n  };\n  /**\n   *  Returns a Promise which resolves when all of the buffers have loaded\n   *  @return {Promise}\n   */\n\n\n  Tone.loaded = function () {\n    var onload, onerror;\n\n    function removeEvents() {\n      //remove the events when it's resolved\n      Tone.Buffer.off(\"load\", onload);\n      Tone.Buffer.off(\"error\", onerror);\n    }\n\n    return new Promise(function (success, fail) {\n      onload = function onload() {\n        success();\n      };\n\n      onerror = function onerror() {\n        fail();\n      }; //add the event listeners\n\n\n      Tone.Buffer.on(\"load\", onload);\n      Tone.Buffer.on(\"error\", onerror);\n    }).then(removeEvents)[\"catch\"](function (e) {\n      removeEvents();\n      throw new Error(e);\n    });\n  };\n\n  return Tone.Buffer;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvQnVmZmVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RvbmUvVG9uZS9jb3JlL0J1ZmZlci5qcz82ODRjIl0sInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbXCJUb25lL2NvcmUvVG9uZVwiLCBcIlRvbmUvY29yZS9FbWl0dGVyXCIsIFwiVG9uZS90eXBlL1R5cGVcIiwgXCJUb25lL3NoaW0vQXVkaW9CdWZmZXJcIl0sIGZ1bmN0aW9uKFRvbmUpe1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiAgQGNsYXNzICBCdWZmZXIgbG9hZGluZyBhbmQgc3RvcmFnZS4gVG9uZS5CdWZmZXIgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IGFsbFxuXHQgKiAgICAgICAgICBjbGFzc2VzIHRoYXQgbWFrZSByZXF1ZXN0cyBmb3IgYXVkaW8gZmlsZXMgc3VjaCBhcyBUb25lLlBsYXllcixcblx0ICogICAgICAgICAgVG9uZS5TYW1wbGVyIGFuZCBUb25lLkNvbnZvbHZlci5cblx0ICpcblx0ICogICAgICAgICAgQXNpZGUgZnJvbSBsb2FkIGNhbGxiYWNrcyBmcm9tIGluZGl2aWR1YWwgYnVmZmVycywgVG9uZS5CdWZmZXJcblx0ICogIFx0XHRwcm92aWRlcyBldmVudHMgd2hpY2gga2VlcCB0cmFjayBvZiB0aGUgbG9hZGluZyBwcm9ncmVzc1xuXHQgKiAgXHRcdG9mIF9hbGxfIG9mIHRoZSBidWZmZXJzLiBUaGVzZSBhcmUgVG9uZS5CdWZmZXIub24oXCJsb2FkXCIgLyBcInByb2dyZXNzXCIgLyBcImVycm9yXCIpXG5cdCAqXG5cdCAqICBAY29uc3RydWN0b3Jcblx0ICogIEBleHRlbmRzIHtUb25lfVxuXHQgKiAgQHBhcmFtIHtBdWRpb0J1ZmZlcnxTdHJpbmd9IHVybCBUaGUgdXJsIHRvIGxvYWQsIG9yIHRoZSBhdWRpbyBidWZmZXIgdG8gc2V0LlxuXHQgKiAgQHBhcmFtIHtGdW5jdGlvbj19IG9ubG9hZCBBIGNhbGxiYWNrIHdoaWNoIGlzIGludm9rZWQgYWZ0ZXIgdGhlIGJ1ZmZlciBpcyBsb2FkZWQuXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIGBUb25lLkJ1ZmZlci5vbignbG9hZCcsIGNhbGxiYWNrKWAgaW5zdGVhZFxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW5jZSBpdCB3aWxsIGdpdmUgeW91IGEgY2FsbGJhY2sgd2hlbiBfYWxsXyBidWZmZXJzIGFyZSBsb2FkZWQuXG5cdCAqICBAcGFyYW0ge0Z1bmN0aW9uPX0gb25lcnJvciBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGlmIHRoZXJlIGlzIGFuIGVycm9yXG5cdCAqICBAZXhhbXBsZVxuXHQgKiB2YXIgYnVmZmVyID0gbmV3IFRvbmUuQnVmZmVyKFwicGF0aC90by9zb3VuZC5tcDNcIiwgZnVuY3Rpb24oKXtcblx0ICogXHQvL3RoZSBidWZmZXIgaXMgbm93IGF2YWlsYWJsZS5cblx0ICogXHR2YXIgYnVmZiA9IGJ1ZmZlci5nZXQoKTtcblx0ICogfSk7XG5cdCAqICBAZXhhbXBsZVxuXHQgKiAvL2NhbiBsb2FkIHByb3ZpZGUgZmFsbGJhY2sgZXh0ZW5zaW9uIHR5cGVzIGlmIHRoZSBmaXJzdCB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuXG5cdCAqIHZhciBidWZmZXIgPSBuZXcgVG9uZS5CdWZmZXIoXCJwYXRoL3RvL3NvdW5kLlttcDN8b2dnfHdhdl1cIik7XG5cdCAqL1xuXHRUb25lLkJ1ZmZlciA9IGZ1bmN0aW9uKCl7XG5cblx0XHR2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXCJ1cmxcIiwgXCJvbmxvYWRcIiwgXCJvbmVycm9yXCJdLCBUb25lLkJ1ZmZlcik7XG5cdFx0VG9uZS5jYWxsKHRoaXMpO1xuXG5cdFx0LyoqXG5cdFx0ICogIHN0b3JlcyB0aGUgbG9hZGVkIEF1ZGlvQnVmZmVyXG5cdFx0ICogIEB0eXBlIHtBdWRpb0J1ZmZlcn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9idWZmZXIgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogIGluZGljYXRlcyBpZiB0aGUgYnVmZmVyIHNob3VsZCBiZSByZXZlcnNlZCBvciBub3Rcblx0XHQgKiAgQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcmV2ZXJzZWQgPSBvcHRpb25zLnJldmVyc2U7XG5cblx0XHQvKipcblx0XHQgKiAgVGhlIFhIUlxuXHRcdCAqICBAdHlwZSAge1hNTEh0dHBSZXF1ZXN0fVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3hociA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBQcml2YXRlIGNhbGxiYWNrIHdoZW4gdGhlIGJ1ZmZlciBpcyBsb2FkZWQuXG5cdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fb25sb2FkID0gVG9uZS5ub09wO1xuXG5cdFx0aWYgKG9wdGlvbnMudXJsIGluc3RhbmNlb2YgQXVkaW9CdWZmZXIgfHwgb3B0aW9ucy51cmwgaW5zdGFuY2VvZiBUb25lLkJ1ZmZlcil7XG5cdFx0XHR0aGlzLnNldChvcHRpb25zLnVybCk7XG5cdFx0XHQvLyBpbnZva2UgdGhlIG9ubG9hZCBjYWxsYmFja1xuXHRcdFx0aWYgKG9wdGlvbnMub25sb2FkKXtcblx0XHRcdFx0aWYgKHRoaXMubG9hZGVkKXtcblx0XHRcdFx0XHRvcHRpb25zLm9ubG9hZCh0aGlzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9vbmxvYWQgPSBvcHRpb25zLm9ubG9hZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoVG9uZS5pc1N0cmluZyhvcHRpb25zLnVybCkpe1xuXHRcdFx0dGhpcy5sb2FkKG9wdGlvbnMudXJsKS50aGVuKG9wdGlvbnMub25sb2FkKS5jYXRjaChvcHRpb25zLm9uZXJyb3IpO1xuXHRcdH1cblx0fTtcblxuXHRUb25lLmV4dGVuZChUb25lLkJ1ZmZlcik7XG5cblx0LyoqXG5cdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdCAqICBAdHlwZSB7T2JqZWN0fVxuXHQgKi9cblx0VG9uZS5CdWZmZXIuZGVmYXVsdHMgPSB7XG5cdFx0XCJ1cmxcIiA6IHVuZGVmaW5lZCxcblx0XHRcInJldmVyc2VcIiA6IGZhbHNlLFxuXHRcdFwib25sb2FkXCIgOiBUb25lLm5vT3AsXG5cdFx0XCJvbmVycm9yXCIgOiBUb25lLm5vT3Bcblx0fTtcblxuXHQvKipcblx0ICogIFBhc3MgaW4gYW4gQXVkaW9CdWZmZXIgb3IgVG9uZS5CdWZmZXIgdG8gc2V0IHRoZSB2YWx1ZVxuXHQgKiAgb2YgdGhpcyBidWZmZXIuXG5cdCAqICBAcGFyYW0ge0F1ZGlvQnVmZmVyfFRvbmUuQnVmZmVyfSBidWZmZXIgdGhlIGJ1ZmZlclxuXHQgKiAgQHJldHVybnMge1RvbmUuQnVmZmVyfSB0aGlzXG5cdCAqL1xuXHRUb25lLkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oYnVmZmVyKXtcblx0XHRpZiAoYnVmZmVyIGluc3RhbmNlb2YgVG9uZS5CdWZmZXIpe1xuXHRcdFx0aWYgKGJ1ZmZlci5sb2FkZWQpe1xuXHRcdFx0XHR0aGlzLl9idWZmZXIgPSBidWZmZXIuZ2V0KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWZmZXIuX29ubG9hZCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0dGhpcy5zZXQoYnVmZmVyKTtcblx0XHRcdFx0XHR0aGlzLl9vbmxvYWQodGhpcyk7XG5cdFx0XHRcdH0uYmluZCh0aGlzKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fYnVmZmVyID0gYnVmZmVyO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogIEByZXR1cm4ge0F1ZGlvQnVmZmVyfSBUaGUgYXVkaW8gYnVmZmVyIHN0b3JlZCBpbiB0aGUgb2JqZWN0LlxuXHQgKi9cblx0VG9uZS5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2J1ZmZlcjtcblx0fTtcblxuXHQvKipcblx0ICogIE1ha2VzIGFuIHhociByZXFlc3QgZm9yIHRoZSBzZWxlY3RlZCB1cmwgdGhlbiBkZWNvZGVzXG5cdCAqICB0aGUgZmlsZSBhcyBhbiBhdWRpbyBidWZmZXIuIEludm9rZXNcblx0ICogIHRoZSBjYWxsYmFjayBvbmNlIHRoZSBhdWRpbyBidWZmZXIgbG9hZHMuXG5cdCAqICBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSB1cmwgb2YgdGhlIGJ1ZmZlciB0byBsb2FkLlxuXHQgKiAgICAgICAgICAgICAgICAgICAgICBmaWxldHlwZSBzdXBwb3J0IGRlcGVuZHMgb24gdGhlXG5cdCAqICAgICAgICAgICAgICAgICAgICAgIGJyb3dzZXIuXG5cdCAqICBAcmV0dXJucyB7UHJvbWlzZX0gcmV0dXJucyBhIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2l0aCB0aGUgVG9uZS5CdWZmZXJcblx0ICovXG5cdFRvbmUuQnVmZmVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24odXJsLCBvbmxvYWQsIG9uZXJyb3Ipe1xuXG5cdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihsb2FkLCBlcnJvcil7XG5cblx0XHRcdHRoaXMuX3hociA9IFRvbmUuQnVmZmVyLmxvYWQodXJsLFxuXG5cdFx0XHRcdC8vc3VjY2Vzc1xuXHRcdFx0XHRmdW5jdGlvbihidWZmKXtcblx0XHRcdFx0XHR0aGlzLl94aHIgPSBudWxsO1xuXHRcdFx0XHRcdHRoaXMuc2V0KGJ1ZmYpO1xuXHRcdFx0XHRcdGxvYWQodGhpcyk7XG5cdFx0XHRcdFx0dGhpcy5fb25sb2FkKHRoaXMpO1xuXHRcdFx0XHRcdGlmIChvbmxvYWQpe1xuXHRcdFx0XHRcdFx0b25sb2FkKHRoaXMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fS5iaW5kKHRoaXMpLFxuXG5cdFx0XHRcdC8vZXJyb3Jcblx0XHRcdFx0ZnVuY3Rpb24oZXJyKXtcblx0XHRcdFx0XHR0aGlzLl94aHIgPSBudWxsO1xuXHRcdFx0XHRcdGVycm9yKGVycik7XG5cdFx0XHRcdFx0aWYgKG9uZXJyb3Ipe1xuXHRcdFx0XHRcdFx0b25lcnJvcihlcnIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fS5iaW5kKHRoaXMpKTtcblxuXHRcdH0uYmluZCh0aGlzKSk7XG5cblx0XHRyZXR1cm4gcHJvbWlzZTtcblx0fTtcblxuXHQvKipcblx0ICogIGRpc3Bvc2UgYW5kIGRpc2Nvbm5lY3Rcblx0ICogIEByZXR1cm5zIHtUb25lLkJ1ZmZlcn0gdGhpc1xuXHQgKi9cblx0VG9uZS5CdWZmZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpe1xuXHRcdFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0XHR0aGlzLl9idWZmZXIgPSBudWxsO1xuXHRcdGlmICh0aGlzLl94aHIpe1xuXHRcdFx0VG9uZS5CdWZmZXIuX3JlbW92ZUZyb21Eb3dubG9hZFF1ZXVlKHRoaXMuX3hocik7XG5cdFx0XHR0aGlzLl94aHIuYWJvcnQoKTtcblx0XHRcdHRoaXMuX3hociA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJZiB0aGUgYnVmZmVyIGlzIGxvYWRlZCBvciBub3Rcblx0ICogQG1lbWJlck9mIFRvbmUuQnVmZmVyI1xuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQG5hbWUgbG9hZGVkXG5cdCAqIEByZWFkT25seVxuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQnVmZmVyLnByb3RvdHlwZSwgXCJsb2FkZWRcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5sZW5ndGggPiAwO1xuXHRcdH0sXG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBUaGUgZHVyYXRpb24gb2YgdGhlIGJ1ZmZlci5cblx0ICogQG1lbWJlck9mIFRvbmUuQnVmZmVyI1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAbmFtZSBkdXJhdGlvblxuXHQgKiBAcmVhZE9ubHlcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlci5wcm90b3R5cGUsIFwiZHVyYXRpb25cIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRpZiAodGhpcy5fYnVmZmVyKXtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2J1ZmZlci5kdXJhdGlvbjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXHRcdH0sXG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBUaGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgaW4gc2FtcGxlc1xuXHQgKiBAbWVtYmVyT2YgVG9uZS5CdWZmZXIjXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBuYW1lIGxlbmd0aFxuXHQgKiBAcmVhZE9ubHlcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlci5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcblx0XHRnZXQgOiBmdW5jdGlvbigpe1xuXHRcdFx0aWYgKHRoaXMuX2J1ZmZlcil7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9idWZmZXIubGVuZ3RoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cdFx0fSxcblx0fSk7XG5cblx0LyoqXG5cdCAqIFRoZSBudW1iZXIgb2YgZGlzY3JldGUgYXVkaW8gY2hhbm5lbHMuIFJldHVybnMgMCBpZiBubyBidWZmZXJcblx0ICogaXMgbG9hZGVkLlxuXHQgKiBAbWVtYmVyT2YgVG9uZS5CdWZmZXIjXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBuYW1lIG51bWJlck9mQ2hhbm5lbHNcblx0ICogQHJlYWRPbmx5XG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5CdWZmZXIucHJvdG90eXBlLCBcIm51bWJlck9mQ2hhbm5lbHNcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRpZiAodGhpcy5fYnVmZmVyKXtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2J1ZmZlci5udW1iZXJPZkNoYW5uZWxzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cdFx0fSxcblx0fSk7XG5cblx0LyoqXG5cdCAqICBTZXQgdGhlIGF1ZGlvIGJ1ZmZlciBmcm9tIHRoZSBhcnJheS4gVG8gY3JlYXRlIGEgbXVsdGljaGFubmVsIEF1ZGlvQnVmZmVyLFxuXHQgKiAgcGFzcyBpbiBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXkuXG5cdCAqICBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwgdGhlIGF1ZGlvIGJ1ZmZlclxuXHQgKiAgQHJldHVybiB7VG9uZS5CdWZmZXJ9IHRoaXNcblx0ICovXG5cdFRvbmUuQnVmZmVyLnByb3RvdHlwZS5mcm9tQXJyYXkgPSBmdW5jdGlvbihhcnJheSl7XG5cdFx0dmFyIGlzTXVsdGlkaW1lbnNpb25hbCA9IGFycmF5WzBdLmxlbmd0aCA+IDA7XG5cdFx0dmFyIGNoYW5uZWxzID0gaXNNdWx0aWRpbWVuc2lvbmFsID8gYXJyYXkubGVuZ3RoIDogMTtcblx0XHR2YXIgbGVuID0gaXNNdWx0aWRpbWVuc2lvbmFsID8gYXJyYXlbMF0ubGVuZ3RoIDogYXJyYXkubGVuZ3RoO1xuXHRcdHZhciBidWZmZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyKGNoYW5uZWxzLCBsZW4sIHRoaXMuY29udGV4dC5zYW1wbGVSYXRlKTtcblx0XHRpZiAoIWlzTXVsdGlkaW1lbnNpb25hbCAmJiBjaGFubmVscyA9PT0gMSl7XG5cdFx0XHRhcnJheSA9IFthcnJheV07XG5cdFx0fVxuXHRcdGZvciAodmFyIGMgPSAwOyBjIDwgY2hhbm5lbHM7IGMrKyl7XG5cdFx0XHRidWZmZXIuY29weVRvQ2hhbm5lbChhcnJheVtjXSwgYyk7XG5cdFx0fVxuXHRcdHRoaXMuX2J1ZmZlciA9IGJ1ZmZlcjtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogXHRTdW1zIG11bGlwbGUgY2hhbm5lbHMgaW50byAxIGNoYW5uZWxcblx0ICogIEBwYXJhbSB7TnVtYmVyPX0gY2hhbm5lbCBPcHRpb25hbGx5IG9ubHkgY29weSBhIHNpbmdsZSBjaGFubmVsIGZyb20gdGhlIGFycmF5LlxuXHQgKiAgQHJldHVybiB7QXJyYXl9XG5cdCAqL1xuXHRUb25lLkJ1ZmZlci5wcm90b3R5cGUudG9Nb25vID0gZnVuY3Rpb24oY2hhbk51bSl7XG5cdFx0aWYgKFRvbmUuaXNOdW1iZXIoY2hhbk51bSkpe1xuXHRcdFx0dGhpcy5mcm9tQXJyYXkodGhpcy50b0FycmF5KGNoYW5OdW0pKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG91dHB1dEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmxlbmd0aCk7XG5cdFx0XHR2YXIgbnVtQ2hhbm5lbHMgPSB0aGlzLm51bWJlck9mQ2hhbm5lbHM7XG5cdFx0XHRmb3IgKHZhciBjaGFubmVsID0gMDsgY2hhbm5lbCA8IG51bUNoYW5uZWxzOyBjaGFubmVsKyspe1xuXHRcdFx0XHR2YXIgY2hhbm5lbEFycmF5ID0gdGhpcy50b0FycmF5KGNoYW5uZWwpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5uZWxBcnJheS5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdFx0b3V0cHV0QXJyYXlbaV0gKz0gY2hhbm5lbEFycmF5W2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvL2RpdmlkZSBieSB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzXG5cdFx0XHRvdXRwdXRBcnJheSA9IG91dHB1dEFycmF5Lm1hcChmdW5jdGlvbihzYW1wbGUpe1xuXHRcdFx0XHRyZXR1cm4gc2FtcGxlIC8gbnVtQ2hhbm5lbHM7XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuZnJvbUFycmF5KG91dHB1dEFycmF5KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFx0R2V0IHRoZSBidWZmZXIgYXMgYW4gYXJyYXkuIFNpbmdsZSBjaGFubmVsIGJ1ZmZlcnMgd2lsbCByZXR1cm4gYSAxLWRpbWVuc2lvbmFsXG5cdCAqIFx0RmxvYXQzMkFycmF5LCBhbmQgbXVsdGljaGFubmVsIGJ1ZmZlcnMgd2lsbCByZXR1cm4gbXVsdGlkaW1lbnNpb25hbCBhcnJheXMuXG5cdCAqICBAcGFyYW0ge051bWJlcj19IGNoYW5uZWwgT3B0aW9uYWxseSBvbmx5IGNvcHkgYSBzaW5nbGUgY2hhbm5lbCBmcm9tIHRoZSBhcnJheS5cblx0ICogIEByZXR1cm4ge0FycmF5fVxuXHQgKi9cblx0VG9uZS5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbihjaGFubmVsKXtcblx0XHRpZiAoVG9uZS5pc051bWJlcihjaGFubmVsKSl7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRDaGFubmVsRGF0YShjaGFubmVsKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMubnVtYmVyT2ZDaGFubmVscyA9PT0gMSl7XG5cdFx0XHRyZXR1cm4gdGhpcy50b0FycmF5KDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcmV0ID0gW107XG5cdFx0XHRmb3IgKHZhciBjID0gMDsgYyA8IHRoaXMubnVtYmVyT2ZDaGFubmVsczsgYysrKXtcblx0XHRcdFx0cmV0W2NdID0gdGhpcy5nZXRDaGFubmVsRGF0YShjKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiAgUmV0dXJucyB0aGUgRmxvYXQzMkFycmF5IHJlcHJlc2VudGluZyB0aGUgUENNIGF1ZGlvIGRhdGEgZm9yIHRoZSBzcGVjaWZpYyBjaGFubmVsLlxuXHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgY2hhbm5lbCAgVGhlIGNoYW5uZWwgbnVtYmVyIHRvIHJldHVyblxuXHQgKiAgQHJldHVybiAge0Zsb2F0MzJBcnJheX0gIFRoZSBhdWRpbyBhcyBhIFR5cGVkQXJyYXlcblx0ICovXG5cdFRvbmUuQnVmZmVyLnByb3RvdHlwZS5nZXRDaGFubmVsRGF0YSA9IGZ1bmN0aW9uKGNoYW5uZWwpe1xuXHRcdHJldHVybiB0aGlzLl9idWZmZXIuZ2V0Q2hhbm5lbERhdGEoY2hhbm5lbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqICBDdXQgYSBzdWJzZWN0aW9uIG9mIHRoZSBhcnJheSBhbmQgcmV0dXJuIGEgYnVmZmVyIG9mIHRoZVxuXHQgKiAgc3Vic2VjdGlvbi4gRG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBidWZmZXJcblx0ICogIEBwYXJhbSB7VGltZX0gc3RhcnQgVGhlIHRpbWUgdG8gc3RhcnQgdGhlIHNsaWNlXG5cdCAqICBAcGFyYW0ge1RpbWU9fSBlbmQgVGhlIGVuZCB0aW1lIHRvIHNsaWNlLiBJZiBub25lIGlzIGdpdmVuXG5cdCAqICAgICAgICAgICAgICAgICAgICAgd2lsbCBkZWZhdWx0IHRvIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuXHQgKiAgQHJldHVybiB7VG9uZS5CdWZmZXJ9IHRoaXNcblx0ICovXG5cdFRvbmUuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpe1xuXHRcdGVuZCA9IFRvbmUuZGVmYXVsdEFyZyhlbmQsIHRoaXMuZHVyYXRpb24pO1xuXHRcdHZhciBzdGFydFNhbXBsZXMgPSBNYXRoLmZsb29yKHRoaXMuY29udGV4dC5zYW1wbGVSYXRlICogdGhpcy50b1NlY29uZHMoc3RhcnQpKTtcblx0XHR2YXIgZW5kU2FtcGxlcyA9IE1hdGguZmxvb3IodGhpcy5jb250ZXh0LnNhbXBsZVJhdGUgKiB0aGlzLnRvU2Vjb25kcyhlbmQpKTtcblx0XHR2YXIgcmVwbGFjZW1lbnQgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubnVtYmVyT2ZDaGFubmVsczsgaSsrKXtcblx0XHRcdHJlcGxhY2VtZW50W2ldID0gdGhpcy50b0FycmF5KGkpLnNsaWNlKHN0YXJ0U2FtcGxlcywgZW5kU2FtcGxlcyk7XG5cdFx0fVxuXHRcdHZhciByZXRCdWZmZXIgPSBuZXcgVG9uZS5CdWZmZXIoKS5mcm9tQXJyYXkocmVwbGFjZW1lbnQpO1xuXHRcdHJldHVybiByZXRCdWZmZXI7XG5cdH07XG5cblx0LyoqXG5cdCAqICBSZXZlcnNlIHRoZSBidWZmZXIuXG5cdCAqICBAcHJpdmF0ZVxuXHQgKiAgQHJldHVybiB7VG9uZS5CdWZmZXJ9IHRoaXNcblx0ICovXG5cdFRvbmUuQnVmZmVyLnByb3RvdHlwZS5fcmV2ZXJzZSA9IGZ1bmN0aW9uKCl7XG5cdFx0aWYgKHRoaXMubG9hZGVkKXtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5udW1iZXJPZkNoYW5uZWxzOyBpKyspe1xuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUucmV2ZXJzZS5jYWxsKHRoaXMuZ2V0Q2hhbm5lbERhdGEoaSkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmV2ZXJzZSB0aGUgYnVmZmVyLlxuXHQgKiBAbWVtYmVyT2YgVG9uZS5CdWZmZXIjXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAbmFtZSByZXZlcnNlXG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5CdWZmZXIucHJvdG90eXBlLCBcInJldmVyc2VcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmV2ZXJzZWQ7XG5cdFx0fSxcblx0XHRzZXQgOiBmdW5jdGlvbihyZXYpe1xuXHRcdFx0aWYgKHRoaXMuX3JldmVyc2VkICE9PSByZXYpe1xuXHRcdFx0XHR0aGlzLl9yZXZlcnNlZCA9IHJldjtcblx0XHRcdFx0dGhpcy5fcmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdH0pO1xuXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBTVEFUSUMgTUVUSE9EU1xuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHQvL3N0YXRpY2FsbHkgaW5oZXJpdHMgRW1pdHRlciBtZXRob2RzXG5cdFRvbmUuRW1pdHRlci5taXhpbihUb25lLkJ1ZmZlcik7XG5cblx0LyoqXG5cdCAqICB0aGUgc3RhdGljIHF1ZXVlIGZvciBhbGwgb2YgdGhlIHhociByZXF1ZXN0c1xuXHQgKiAgQHR5cGUge0FycmF5fVxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdFRvbmUuQnVmZmVyLl9kb3dubG9hZFF1ZXVlID0gW107XG5cblx0LyoqXG5cdCAqICBBIHBhdGggd2hpY2ggaXMgcHJlZml4ZWQgYmVmb3JlIGV2ZXJ5IHVybC5cblx0ICogIEB0eXBlICB7U3RyaW5nfVxuXHQgKiAgQHN0YXRpY1xuXHQgKi9cblx0VG9uZS5CdWZmZXIuYmFzZVVybCA9IFwiXCI7XG5cblx0LyoqXG5cdCAqICBDcmVhdGUgYSBUb25lLkJ1ZmZlciBmcm9tIHRoZSBhcnJheS4gVG8gY3JlYXRlIGEgbXVsdGljaGFubmVsIEF1ZGlvQnVmZmVyLFxuXHQgKiAgcGFzcyBpbiBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXkuXG5cdCAqICBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwgdGhlIGF1ZGlvIGJ1ZmZlclxuXHQgKiAgQHJldHVybiB7VG9uZS5CdWZmZXJ9IEEgVG9uZS5CdWZmZXIgY3JlYXRlZCBmcm9tIHRoZSBhcnJheVxuXHQgKi9cblx0VG9uZS5CdWZmZXIuZnJvbUFycmF5ID0gZnVuY3Rpb24oYXJyYXkpe1xuXHRcdHJldHVybiAobmV3IFRvbmUuQnVmZmVyKCkpLmZyb21BcnJheShhcnJheSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBUb25lLkJ1ZmZlciBmcm9tIGEgVVJMLCByZXR1cm5zIGEgcHJvbWlzZVxuXHQgKiB3aGljaCByZXNvbHZlcyB0byBhIFRvbmUuQnVmZmVyXG5cdCAqIEBwYXJhbSAge1N0cmluZ30gdXJsIFRoZSB1cmwgdG8gbG9hZC5cblx0ICogQHJldHVybiB7UHJvbWlzZTxUb25lLkJ1ZmZlcj59ICAgICBBIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gYSBUb25lLkJ1ZmZlclxuXHQgKi9cblx0VG9uZS5CdWZmZXIuZnJvbVVybCA9IGZ1bmN0aW9uKHVybCl7XG5cdFx0dmFyIGJ1ZmZlciA9IG5ldyBUb25lLkJ1ZmZlcigpO1xuXHRcdHJldHVybiBidWZmZXIubG9hZCh1cmwpLnRoZW4oZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiBidWZmZXI7XG5cdFx0fSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbiB4aHIgcmVxdWVzdCBmcm9tIHRoZSBkb3dubG9hZCBxdWV1ZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0VG9uZS5CdWZmZXIuX3JlbW92ZUZyb21Eb3dubG9hZFF1ZXVlID0gZnVuY3Rpb24ocmVxdWVzdCl7XG5cdFx0dmFyIGluZGV4ID0gVG9uZS5CdWZmZXIuX2Rvd25sb2FkUXVldWUuaW5kZXhPZihyZXF1ZXN0KTtcblx0XHRpZiAoaW5kZXggIT09IC0xKXtcblx0XHRcdFRvbmUuQnVmZmVyLl9kb3dubG9hZFF1ZXVlLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiAgTG9hZHMgYSB1cmwgdXNpbmcgWE1MSHR0cFJlcXVlc3QuXG5cdCAqICBAcGFyYW0ge1N0cmluZ30gdXJsXG5cdCAqICBAcGFyYW0ge0Z1bmN0aW9ufSBvbmxvYWRcblx0ICogIEBwYXJhbSB7RnVuY3Rpb259IG9uZXJyb3Jcblx0ICogIEBwYXJhbSB7RnVuY3Rpb259IG9ucHJvZ3Jlc3Ncblx0ICogIEByZXR1cm4ge1hNTEh0dHBSZXF1ZXN0fVxuXHQgKi9cblx0VG9uZS5CdWZmZXIubG9hZCA9IGZ1bmN0aW9uKHVybCwgb25sb2FkLCBvbmVycm9yKXtcblx0XHQvL2RlZmF1bHRcblx0XHRvbmxvYWQgPSBUb25lLmRlZmF1bHRBcmcob25sb2FkLCBUb25lLm5vT3ApO1xuXG5cdFx0Ly8gdGVzdCBpZiB0aGUgdXJsIGNvbnRhaW5zIG11bHRpcGxlIGV4dGVuc2lvbnNcblx0XHR2YXIgbWF0Y2hlcyA9IHVybC5tYXRjaCgvXFxbKC4rXFx8PykrXFxdJC8pO1xuXHRcdGlmIChtYXRjaGVzKXtcblx0XHRcdHZhciBleHRlbnNpb25zID0gbWF0Y2hlc1sxXS5zcGxpdChcInxcIik7XG5cdFx0XHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uc1swXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdGlmIChUb25lLkJ1ZmZlci5zdXBwb3J0c1R5cGUoZXh0ZW5zaW9uc1tpXSkpe1xuXHRcdFx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnNbaV07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHVybCA9IHVybC5yZXBsYWNlKG1hdGNoZXNbMF0sIGV4dGVuc2lvbik7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25FcnJvcihlKXtcblx0XHRcdFRvbmUuQnVmZmVyLl9yZW1vdmVGcm9tRG93bmxvYWRRdWV1ZShyZXF1ZXN0KTtcblx0XHRcdFRvbmUuQnVmZmVyLmVtaXQoXCJlcnJvclwiLCBlKTtcblx0XHRcdGlmIChvbmVycm9yKXtcblx0XHRcdFx0b25lcnJvcihlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Qcm9ncmVzcygpe1xuXHRcdFx0Ly9jYWxjdWxhdGUgdGhlIHByb2dyZXNzXG5cdFx0XHR2YXIgdG90YWxQcm9ncmVzcyA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IFRvbmUuQnVmZmVyLl9kb3dubG9hZFF1ZXVlLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0dG90YWxQcm9ncmVzcyArPSBUb25lLkJ1ZmZlci5fZG93bmxvYWRRdWV1ZVtpXS5wcm9ncmVzcztcblx0XHRcdH1cblx0XHRcdFRvbmUuQnVmZmVyLmVtaXQoXCJwcm9ncmVzc1wiLCB0b3RhbFByb2dyZXNzIC8gVG9uZS5CdWZmZXIuX2Rvd25sb2FkUXVldWUubGVuZ3RoKTtcblx0XHR9XG5cblx0XHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRcdHJlcXVlc3Qub3BlbihcIkdFVFwiLCBUb25lLkJ1ZmZlci5iYXNlVXJsICsgdXJsLCB0cnVlKTtcblx0XHRyZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcblx0XHQvL3N0YXJ0IG91dCBhcyAwXG5cdFx0cmVxdWVzdC5wcm9ncmVzcyA9IDA7XG5cblx0XHRUb25lLkJ1ZmZlci5fZG93bmxvYWRRdWV1ZS5wdXNoKHJlcXVlc3QpO1xuXG5cdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbigpe1xuXG5cdFx0XHRpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCl7XG5cdFx0XHRcdFRvbmUuY29udGV4dC5kZWNvZGVBdWRpb0RhdGEocmVxdWVzdC5yZXNwb25zZSkudGhlbihmdW5jdGlvbihidWZmKXtcblxuXHRcdFx0XHRcdHJlcXVlc3QucHJvZ3Jlc3MgPSAxO1xuXHRcdFx0XHRcdG9uUHJvZ3Jlc3MoKTtcblx0XHRcdFx0XHRvbmxvYWQoYnVmZik7XG5cblx0XHRcdFx0XHRUb25lLkJ1ZmZlci5fcmVtb3ZlRnJvbURvd25sb2FkUXVldWUocmVxdWVzdCk7XG5cdFx0XHRcdFx0aWYgKFRvbmUuQnVmZmVyLl9kb3dubG9hZFF1ZXVlLmxlbmd0aCA9PT0gMCl7XG5cdFx0XHRcdFx0XHQvL2VtaXQgdGhlIGV2ZW50IGF0IHRoZSBlbmRcblx0XHRcdFx0XHRcdFRvbmUuQnVmZmVyLmVtaXQoXCJsb2FkXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkuY2F0Y2goZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRUb25lLkJ1ZmZlci5fcmVtb3ZlRnJvbURvd25sb2FkUXVldWUocmVxdWVzdCk7XG5cdFx0XHRcdFx0b25FcnJvcihcIlRvbmUuQnVmZmVyOiBjb3VsZCBub3QgZGVjb2RlIGF1ZGlvIGRhdGE6IFwiK3VybCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b25FcnJvcihcIlRvbmUuQnVmZmVyOiBjb3VsZCBub3QgbG9jYXRlIGZpbGU6IFwiK3VybCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvcik7XG5cblx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCBmdW5jdGlvbihldmVudCl7XG5cdFx0XHRpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSl7XG5cdFx0XHRcdC8vb25seSBnbyB0byA5NSUsIHRoZSBsYXN0IDUlIGlzIHdoZW4gdGhlIGF1ZGlvIGlzIGRlY29kZWRcblx0XHRcdFx0cmVxdWVzdC5wcm9ncmVzcyA9IChldmVudC5sb2FkZWQgLyBldmVudC50b3RhbCkgKiAwLjk1O1xuXHRcdFx0XHRvblByb2dyZXNzKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXF1ZXN0LnNlbmQoKTtcblxuXHRcdHJldHVybiByZXF1ZXN0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgU3RvcCBhbGwgb2YgdGhlIGRvd25sb2FkcyBpbiBwcm9ncmVzc1xuXHQgKiAgQHJldHVybiB7VG9uZS5CdWZmZXJ9XG5cdCAqICBAc3RhdGljXG5cdCAqL1xuXHRUb25lLkJ1ZmZlci5jYW5jZWxEb3dubG9hZHMgPSBmdW5jdGlvbigpe1xuXHRcdFRvbmUuQnVmZmVyLl9kb3dubG9hZFF1ZXVlLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbihyZXF1ZXN0KXtcblx0XHRcdFRvbmUuQnVmZmVyLl9yZW1vdmVGcm9tRG93bmxvYWRRdWV1ZShyZXF1ZXN0KTtcblx0XHRcdHJlcXVlc3QuYWJvcnQoKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gVG9uZS5CdWZmZXI7XG5cdH07XG5cblx0LyoqXG5cdCAqICBDaGVja3MgYSB1cmwncyBleHRlbnNpb24gdG8gc2VlIGlmIHRoZSBjdXJyZW50IGJyb3dzZXIgY2FuIHBsYXkgdGhhdCBmaWxlIHR5cGUuXG5cdCAqICBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSB1cmwvZXh0ZW5zaW9uIHRvIHRlc3Rcblx0ICogIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBmaWxlIGV4dGVuc2lvbiBjYW4gYmUgcGxheWVkXG5cdCAqICBAc3RhdGljXG5cdCAqICBAZXhhbXBsZVxuXHQgKiBUb25lLkJ1ZmZlci5zdXBwb3J0c1R5cGUoXCJ3YXZcIik7IC8vcmV0dXJucyB0cnVlXG5cdCAqIFRvbmUuQnVmZmVyLnN1cHBvcnRzVHlwZShcInBhdGgvdG8vZmlsZS53YXZcIik7IC8vcmV0dXJucyB0cnVlXG5cdCAqL1xuXHRUb25lLkJ1ZmZlci5zdXBwb3J0c1R5cGUgPSBmdW5jdGlvbih1cmwpe1xuXHRcdHZhciBleHRlbnNpb24gPSB1cmwuc3BsaXQoXCIuXCIpO1xuXHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbltleHRlbnNpb24ubGVuZ3RoIC0gMV07XG5cdFx0dmFyIHJlc3BvbnNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImF1ZGlvXCIpLmNhblBsYXlUeXBlKFwiYXVkaW8vXCIrZXh0ZW5zaW9uKTtcblx0XHRyZXR1cm4gcmVzcG9uc2UgIT09IFwiXCI7XG5cdH07XG5cblx0LyoqXG5cdCAqICBSZXR1cm5zIGEgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIGFsbCBvZiB0aGUgYnVmZmVycyBoYXZlIGxvYWRlZFxuXHQgKiAgQHJldHVybiB7UHJvbWlzZX1cblx0ICovXG5cdFRvbmUubG9hZGVkID0gZnVuY3Rpb24oKXtcblx0XHR2YXIgb25sb2FkLCBvbmVycm9yO1xuXHRcdGZ1bmN0aW9uIHJlbW92ZUV2ZW50cygpe1xuXHRcdFx0Ly9yZW1vdmUgdGhlIGV2ZW50cyB3aGVuIGl0J3MgcmVzb2x2ZWRcblx0XHRcdFRvbmUuQnVmZmVyLm9mZihcImxvYWRcIiwgb25sb2FkKTtcblx0XHRcdFRvbmUuQnVmZmVyLm9mZihcImVycm9yXCIsIG9uZXJyb3IpO1xuXHRcdH1cblx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oc3VjY2VzcywgZmFpbCl7XG5cdFx0XHRvbmxvYWQgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRzdWNjZXNzKCk7XG5cdFx0XHR9O1xuXHRcdFx0b25lcnJvciA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdGZhaWwoKTtcblx0XHRcdH07XG5cdFx0XHQvL2FkZCB0aGUgZXZlbnQgbGlzdGVuZXJzXG5cdFx0XHRUb25lLkJ1ZmZlci5vbihcImxvYWRcIiwgb25sb2FkKTtcblx0XHRcdFRvbmUuQnVmZmVyLm9uKFwiZXJyb3JcIiwgb25lcnJvcik7XG5cdFx0fSkudGhlbihyZW1vdmVFdmVudHMpLmNhdGNoKGZ1bmN0aW9uKGUpe1xuXHRcdFx0cmVtb3ZlRXZlbnRzKCk7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoZSk7XG5cdFx0fSk7XG5cdH07XG5cblx0cmV0dXJuIFRvbmUuQnVmZmVyO1xufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBRUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkE7QUFFQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQVNBO0FBRUE7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQURBO0FBTUE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUFBO0FBREE7QUFVQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQUE7QUFEQTtBQVVBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQUE7QUFEQTtBQVVBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFBQTtBQUpBO0FBYUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBOzs7Ozs7QUFLQTtBQUVBOzs7Ozs7QUFLQTtBQUVBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/core/Buffer.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/core/Buffers.js":
/*!************************************************!*\
  !*** ./node_modules/tone/Tone/core/Buffers.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/core/Buffer */ \"./node_modules/tone/Tone/core/Buffer.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  /**\n   *  @class A data structure for holding multiple buffers.\n   *  \n   *  @param  {Object|Array}    urls      An object literal or array\n   *                                      of urls to load.\n   *  @param  {Function=}  callback  The callback to invoke when\n   *                                 the buffers are loaded. \n   *  @extends {Tone}\n   *  @example\n   * //load a whole bank of piano samples\n   * var pianoSamples = new Tone.Buffers({\n   * \t\"C4\" : \"path/to/C4.mp3\"\n   * \t\"C#4\" : \"path/to/C#4.mp3\"\n   * \t\"D4\" : \"path/to/D4.mp3\"\n   * \t\"D#4\" : \"path/to/D#4.mp3\"\n   * \t...\n   * }, function(){\n   * \t//play one of the samples when they all load\n   * \tplayer.buffer = pianoSamples.get(\"C4\");\n   * \tplayer.start();\n   * });\n   * \t@example\n   * //To pass in additional parameters in the second parameter\n   * var buffers = new Tone.Buffers(urls, {\n   * \t\"onload\" : callback,\n   * \t\"baseUrl\" : \"../path/to/audio/\"\n   * })\n   */\n  Tone.Buffers = function (urls) {\n    //remove the urls from the options\n    var args = Array.prototype.slice.call(arguments);\n    args.shift();\n    var options = Tone.defaults(args, [\"onload\", \"baseUrl\"], Tone.Buffers);\n    Tone.call(this);\n    /**\n     *  All of the buffers\n     *  @type  {Object}\n     *  @private\n     */\n\n    this._buffers = {};\n    /**\n     *  A path which is prefixed before every url.\n     *  @type  {String}\n     */\n\n    this.baseUrl = options.baseUrl;\n    this._loadingCount = 0; //add each one\n\n    for (var key in urls) {\n      this._loadingCount++;\n      this.add(key, urls[key], this._bufferLoaded.bind(this, options.onload));\n    }\n  };\n\n  Tone.extend(Tone.Buffers);\n  /**\n   *  Defaults\n   *  @type  {Object}\n   */\n\n  Tone.Buffers.defaults = {\n    \"onload\": Tone.noOp,\n    \"baseUrl\": \"\"\n  };\n  /**\n   *  True if the buffers object has a buffer by that name.\n   *  @param  {String|Number}  name  The key or index of the \n   *                                 buffer.\n   *  @return  {Boolean}\n   */\n\n  Tone.Buffers.prototype.has = function (name) {\n    return this._buffers.hasOwnProperty(name);\n  };\n  /**\n   *  Get a buffer by name. If an array was loaded, \n   *  then use the array index.\n   *  @param  {String|Number}  name  The key or index of the \n   *                                 buffer.\n   *  @return  {Tone.Buffer}\n   */\n\n\n  Tone.Buffers.prototype.get = function (name) {\n    if (this.has(name)) {\n      return this._buffers[name];\n    } else {\n      throw new Error(\"Tone.Buffers: no buffer named \" + name);\n    }\n  };\n  /**\n   *  A buffer was loaded. decrement the counter.\n   *  @param  {Function}  callback \n   *  @private\n   */\n\n\n  Tone.Buffers.prototype._bufferLoaded = function (callback) {\n    this._loadingCount--;\n\n    if (this._loadingCount === 0 && callback) {\n      callback(this);\n    }\n  };\n  /**\n   * If the buffers are loaded or not\n   * @memberOf Tone.Buffers#\n   * @type {Boolean}\n   * @name loaded\n   * @readOnly\n   */\n\n\n  Object.defineProperty(Tone.Buffers.prototype, \"loaded\", {\n    get: function () {\n      function get() {\n        var isLoaded = true;\n\n        for (var buffName in this._buffers) {\n          var buff = this.get(buffName);\n          isLoaded = isLoaded && buff.loaded;\n        }\n\n        return isLoaded;\n      }\n\n      return get;\n    }()\n  });\n  /**\n   *  Add a buffer by name and url to the Buffers\n   *  @param  {String}    name      A unique name to give\n   *                                the buffer\n   *  @param  {String|Tone.Buffer|Audiobuffer}  url  Either the url of the bufer, \n   *                                                 or a buffer which will be added\n   *                                                 with the given name.\n   *  @param  {Function=}  callback  The callback to invoke \n   *                                 when the url is loaded.\n   */\n\n  Tone.Buffers.prototype.add = function (name, url, callback) {\n    callback = Tone.defaultArg(callback, Tone.noOp);\n\n    if (url instanceof Tone.Buffer) {\n      this._buffers[name] = url;\n      callback(this);\n    } else if (url instanceof AudioBuffer) {\n      this._buffers[name] = new Tone.Buffer(url);\n      callback(this);\n    } else if (Tone.isString(url)) {\n      this._buffers[name] = new Tone.Buffer(this.baseUrl + url, callback);\n    }\n\n    return this;\n  };\n  /**\n   *  Clean up.\n   *  @return  {Tone.Buffers} this\n   */\n\n\n  Tone.Buffers.prototype.dispose = function () {\n    Tone.prototype.dispose.call(this);\n\n    for (var name in this._buffers) {\n      this._buffers[name].dispose();\n    }\n\n    this._buffers = null;\n    return this;\n  };\n\n  return Tone.Buffers;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvQnVmZmVycy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90b25lL1RvbmUvY29yZS9CdWZmZXJzLmpzPzU5ZDIiXSwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFtcIlRvbmUvY29yZS9Ub25lXCIsIFwiVG9uZS9jb3JlL0J1ZmZlclwiXSwgZnVuY3Rpb24oVG9uZSl7XG5cblx0LyoqXG5cdCAqICBAY2xhc3MgQSBkYXRhIHN0cnVjdHVyZSBmb3IgaG9sZGluZyBtdWx0aXBsZSBidWZmZXJzLlxuXHQgKiAgXG5cdCAqICBAcGFyYW0gIHtPYmplY3R8QXJyYXl9ICAgIHVybHMgICAgICBBbiBvYmplY3QgbGl0ZXJhbCBvciBhcnJheVxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdXJscyB0byBsb2FkLlxuXHQgKiAgQHBhcmFtICB7RnVuY3Rpb249fSAgY2FsbGJhY2sgIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2hlblxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBidWZmZXJzIGFyZSBsb2FkZWQuIFxuXHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdCAqICBAZXhhbXBsZVxuXHQgKiAvL2xvYWQgYSB3aG9sZSBiYW5rIG9mIHBpYW5vIHNhbXBsZXNcblx0ICogdmFyIHBpYW5vU2FtcGxlcyA9IG5ldyBUb25lLkJ1ZmZlcnMoe1xuXHQgKiBcdFwiQzRcIiA6IFwicGF0aC90by9DNC5tcDNcIlxuXHQgKiBcdFwiQyM0XCIgOiBcInBhdGgvdG8vQyM0Lm1wM1wiXG5cdCAqIFx0XCJENFwiIDogXCJwYXRoL3RvL0Q0Lm1wM1wiXG5cdCAqIFx0XCJEIzRcIiA6IFwicGF0aC90by9EIzQubXAzXCJcblx0ICogXHQuLi5cblx0ICogfSwgZnVuY3Rpb24oKXtcblx0ICogXHQvL3BsYXkgb25lIG9mIHRoZSBzYW1wbGVzIHdoZW4gdGhleSBhbGwgbG9hZFxuXHQgKiBcdHBsYXllci5idWZmZXIgPSBwaWFub1NhbXBsZXMuZ2V0KFwiQzRcIik7XG5cdCAqIFx0cGxheWVyLnN0YXJ0KCk7XG5cdCAqIH0pO1xuXHQgKiBcdEBleGFtcGxlXG5cdCAqIC8vVG8gcGFzcyBpbiBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgaW4gdGhlIHNlY29uZCBwYXJhbWV0ZXJcblx0ICogdmFyIGJ1ZmZlcnMgPSBuZXcgVG9uZS5CdWZmZXJzKHVybHMsIHtcblx0ICogXHRcIm9ubG9hZFwiIDogY2FsbGJhY2ssXG5cdCAqIFx0XCJiYXNlVXJsXCIgOiBcIi4uL3BhdGgvdG8vYXVkaW8vXCJcblx0ICogfSlcblx0ICovXG5cdFRvbmUuQnVmZmVycyA9IGZ1bmN0aW9uKHVybHMpe1xuXG5cdFx0Ly9yZW1vdmUgdGhlIHVybHMgZnJvbSB0aGUgb3B0aW9uc1xuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHRhcmdzLnNoaWZ0KCk7XG5cdFx0dmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3MsIFtcIm9ubG9hZFwiLCBcImJhc2VVcmxcIl0sIFRvbmUuQnVmZmVycyk7XG5cdFx0VG9uZS5jYWxsKHRoaXMpO1xuXG5cdFx0LyoqXG5cdFx0ICogIEFsbCBvZiB0aGUgYnVmZmVyc1xuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9idWZmZXJzID0ge307XG5cblx0XHQvKipcblx0XHQgKiAgQSBwYXRoIHdoaWNoIGlzIHByZWZpeGVkIGJlZm9yZSBldmVyeSB1cmwuXG5cdFx0ICogIEB0eXBlICB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdHRoaXMuYmFzZVVybCA9IG9wdGlvbnMuYmFzZVVybDtcblxuXHRcdHRoaXMuX2xvYWRpbmdDb3VudCA9IDA7XG5cdFx0Ly9hZGQgZWFjaCBvbmVcblx0XHRmb3IgKHZhciBrZXkgaW4gdXJscyl7XG5cdFx0XHR0aGlzLl9sb2FkaW5nQ291bnQrKztcblx0XHRcdHRoaXMuYWRkKGtleSwgdXJsc1trZXldLCB0aGlzLl9idWZmZXJMb2FkZWQuYmluZCh0aGlzLCBvcHRpb25zLm9ubG9hZCkpO1xuXHRcdH1cblx0fTtcblxuXHRUb25lLmV4dGVuZChUb25lLkJ1ZmZlcnMpO1xuXG5cdC8qKlxuXHQgKiAgRGVmYXVsdHNcblx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHQgKi9cblx0VG9uZS5CdWZmZXJzLmRlZmF1bHRzID0ge1xuXHRcdFwib25sb2FkXCIgOiBUb25lLm5vT3AsXG5cdFx0XCJiYXNlVXJsXCIgOiBcIlwiXG5cdH07XG5cblx0LyoqXG5cdCAqICBUcnVlIGlmIHRoZSBidWZmZXJzIG9iamVjdCBoYXMgYSBidWZmZXIgYnkgdGhhdCBuYW1lLlxuXHQgKiAgQHBhcmFtICB7U3RyaW5nfE51bWJlcn0gIG5hbWUgIFRoZSBrZXkgb3IgaW5kZXggb2YgdGhlIFxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5cblx0ICogIEByZXR1cm4gIHtCb29sZWFufVxuXHQgKi9cblx0VG9uZS5CdWZmZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKXtcblx0XHRyZXR1cm4gdGhpcy5fYnVmZmVycy5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcblx0fTtcblxuXHQvKipcblx0ICogIEdldCBhIGJ1ZmZlciBieSBuYW1lLiBJZiBhbiBhcnJheSB3YXMgbG9hZGVkLCBcblx0ICogIHRoZW4gdXNlIHRoZSBhcnJheSBpbmRleC5cblx0ICogIEBwYXJhbSAge1N0cmluZ3xOdW1iZXJ9ICBuYW1lICBUaGUga2V5IG9yIGluZGV4IG9mIHRoZSBcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuXG5cdCAqICBAcmV0dXJuICB7VG9uZS5CdWZmZXJ9XG5cdCAqL1xuXHRUb25lLkJ1ZmZlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpe1xuXHRcdGlmICh0aGlzLmhhcyhuYW1lKSl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYnVmZmVyc1tuYW1lXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVG9uZS5CdWZmZXJzOiBubyBidWZmZXIgbmFtZWQgXCIrbmFtZSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiAgQSBidWZmZXIgd2FzIGxvYWRlZC4gZGVjcmVtZW50IHRoZSBjb3VudGVyLlxuXHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFjayBcblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLkJ1ZmZlcnMucHJvdG90eXBlLl9idWZmZXJMb2FkZWQgPSBmdW5jdGlvbihjYWxsYmFjayl7XG5cdFx0dGhpcy5fbG9hZGluZ0NvdW50LS07XG5cdFx0aWYgKHRoaXMuX2xvYWRpbmdDb3VudCA9PT0gMCAmJiBjYWxsYmFjayl7XG5cdFx0XHRjYWxsYmFjayh0aGlzKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIElmIHRoZSBidWZmZXJzIGFyZSBsb2FkZWQgb3Igbm90XG5cdCAqIEBtZW1iZXJPZiBUb25lLkJ1ZmZlcnMjXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAbmFtZSBsb2FkZWRcblx0ICogQHJlYWRPbmx5XG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5CdWZmZXJzLnByb3RvdHlwZSwgXCJsb2FkZWRcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgaXNMb2FkZWQgPSB0cnVlO1xuXHRcdFx0Zm9yICh2YXIgYnVmZk5hbWUgaW4gdGhpcy5fYnVmZmVycyl7XG5cdFx0XHRcdHZhciBidWZmID0gdGhpcy5nZXQoYnVmZk5hbWUpO1xuXHRcdFx0XHRpc0xvYWRlZCA9IGlzTG9hZGVkICYmIGJ1ZmYubG9hZGVkO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGlzTG9hZGVkO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqICBBZGQgYSBidWZmZXIgYnkgbmFtZSBhbmQgdXJsIHRvIHRoZSBCdWZmZXJzXG5cdCAqICBAcGFyYW0gIHtTdHJpbmd9ICAgIG5hbWUgICAgICBBIHVuaXF1ZSBuYW1lIHRvIGdpdmVcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBidWZmZXJcblx0ICogIEBwYXJhbSAge1N0cmluZ3xUb25lLkJ1ZmZlcnxBdWRpb2J1ZmZlcn0gIHVybCAgRWl0aGVyIHRoZSB1cmwgb2YgdGhlIGJ1ZmVyLCBcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgYSBidWZmZXIgd2hpY2ggd2lsbCBiZSBhZGRlZFxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuXHQgKiAgQHBhcmFtICB7RnVuY3Rpb249fSAgY2FsbGJhY2sgIFRoZSBjYWxsYmFjayB0byBpbnZva2UgXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiB0aGUgdXJsIGlzIGxvYWRlZC5cblx0ICovXG5cdFRvbmUuQnVmZmVycy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obmFtZSwgdXJsLCBjYWxsYmFjayl7XG5cdFx0Y2FsbGJhY2sgPSBUb25lLmRlZmF1bHRBcmcoY2FsbGJhY2ssIFRvbmUubm9PcCk7XG5cdFx0aWYgKHVybCBpbnN0YW5jZW9mIFRvbmUuQnVmZmVyKXtcblx0XHRcdHRoaXMuX2J1ZmZlcnNbbmFtZV0gPSB1cmw7XG5cdFx0XHRjYWxsYmFjayh0aGlzKTtcblx0XHR9IGVsc2UgaWYgKHVybCBpbnN0YW5jZW9mIEF1ZGlvQnVmZmVyKXtcblx0XHRcdHRoaXMuX2J1ZmZlcnNbbmFtZV0gPSBuZXcgVG9uZS5CdWZmZXIodXJsKTtcblx0XHRcdGNhbGxiYWNrKHRoaXMpO1xuXHRcdH0gZWxzZSBpZiAoVG9uZS5pc1N0cmluZyh1cmwpKXtcblx0XHRcdHRoaXMuX2J1ZmZlcnNbbmFtZV0gPSBuZXcgVG9uZS5CdWZmZXIodGhpcy5iYXNlVXJsICsgdXJsLCBjYWxsYmFjayk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgQ2xlYW4gdXAuXG5cdCAqICBAcmV0dXJuICB7VG9uZS5CdWZmZXJzfSB0aGlzXG5cdCAqL1xuXHRUb25lLkJ1ZmZlcnMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpe1xuXHRcdFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0XHRmb3IgKHZhciBuYW1lIGluIHRoaXMuX2J1ZmZlcnMpe1xuXHRcdFx0dGhpcy5fYnVmZmVyc1tuYW1lXS5kaXNwb3NlKCk7XG5cdFx0fVxuXHRcdHRoaXMuX2J1ZmZlcnMgPSBudWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdHJldHVybiBUb25lLkJ1ZmZlcnM7XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRCQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBUkE7QUFBQTtBQURBO0FBV0E7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/core/Buffers.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/core/Clock.js":
/*!**********************************************!*\
  !*** ./node_modules/tone/Tone/core/Clock.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/source/TickSource */ \"./node_modules/tone/Tone/source/TickSource.js\"), __webpack_require__(/*! Tone/core/TimelineState */ \"./node_modules/tone/Tone/core/TimelineState.js\"), __webpack_require__(/*! Tone/core/Emitter */ \"./node_modules/tone/Tone/core/Emitter.js\"), __webpack_require__(/*! Tone/core/Context */ \"./node_modules/tone/Tone/core/Context.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  \"use strict\";\n  /**\n   *  @class  A sample accurate clock which provides a callback at the given rate.\n   *          While the callback is not sample-accurate (it is still susceptible to\n   *          loose JS timing), the time passed in as the argument to the callback\n   *          is precise. For most applications, it is better to use Tone.Transport\n   *          instead of the Clock by itself since you can synchronize multiple callbacks.\n   *\n   * \t@constructor\n   *  @extends {Tone.Emitter}\n   * \t@param {function} callback The callback to be invoked with the time of the audio event\n   * \t@param {Frequency} frequency The rate of the callback\n   * \t@example\n   * //the callback will be invoked approximately once a second\n   * //and will print the time exactly once a second apart.\n   * var clock = new Tone.Clock(function(time){\n   * \tconsole.log(time);\n   * }, 1);\n   */\n\n  Tone.Clock = function () {\n    var options = Tone.defaults(arguments, [\"callback\", \"frequency\"], Tone.Clock);\n    Tone.Emitter.call(this);\n    /**\n     *  The callback function to invoke at the scheduled tick.\n     *  @type  {Function}\n     */\n\n    this.callback = options.callback;\n    /**\n     *  The next time the callback is scheduled.\n     *  @type {Number}\n     *  @private\n     */\n\n    this._nextTick = 0;\n    /**\n     *  The tick counter\n     *  @type  {Tone.TickSource}\n     *  @private\n     */\n\n    this._tickSource = new Tone.TickSource(options.frequency);\n    /**\n     *  The last time the loop callback was invoked\n     *  @private\n     *  @type {Number}\n     */\n\n    this._lastUpdate = 0;\n    /**\n     *  The rate the callback function should be invoked.\n     *  @type  {BPM}\n     *  @signal\n     */\n\n    this.frequency = this._tickSource.frequency;\n\n    this._readOnly(\"frequency\");\n    /**\n     *  The state timeline\n     *  @type {Tone.TimelineState}\n     *  @private\n     */\n\n\n    this._state = new Tone.TimelineState(Tone.State.Stopped); //add an initial state\n\n    this._state.setStateAtTime(Tone.State.Stopped, 0);\n    /**\n     *  The loop function bound to its context.\n     *  This is necessary to remove the event in the end.\n     *  @type {Function}\n     *  @private\n     */\n\n\n    this._boundLoop = this._loop.bind(this); //bind a callback to the worker thread\n\n    this.context.on(\"tick\", this._boundLoop);\n  };\n\n  Tone.extend(Tone.Clock, Tone.Emitter);\n  /**\n   *  The defaults\n   *  @const\n   *  @type  {Object}\n   */\n\n  Tone.Clock.defaults = {\n    \"callback\": Tone.noOp,\n    \"frequency\": 1\n  };\n  /**\n   *  Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n   *  @type {Tone.State}\n   *  @readOnly\n   *  @memberOf Tone.Clock#\n   *  @name state\n   */\n\n  Object.defineProperty(Tone.Clock.prototype, \"state\", {\n    get: function () {\n      function get() {\n        return this._state.getValueAtTime(this.now());\n      }\n\n      return get;\n    }()\n  });\n  /**\n   *  Start the clock at the given time. Optionally pass in an offset\n   *  of where to start the tick counter from.\n   *  @param  {Time=}  time    The time the clock should start\n   *  @param  {Ticks=}  offset  Where the tick counter starts counting from.\n   *  @return  {Tone.Clock}  this\n   */\n\n  Tone.Clock.prototype.start = function (time, offset) {\n    time = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(time) !== Tone.State.Started) {\n      this._state.setStateAtTime(Tone.State.Started, time);\n\n      this._tickSource.start(time, offset);\n\n      if (time < this._lastUpdate) {\n        this.emit(\"start\", time, offset);\n      }\n    }\n\n    return this;\n  };\n  /**\n   *  Stop the clock. Stopping the clock resets the tick counter to 0.\n   *  @param {Time} [time=now] The time when the clock should stop.\n   *  @returns {Tone.Clock} this\n   *  @example\n   * clock.stop();\n   */\n\n\n  Tone.Clock.prototype.stop = function (time) {\n    time = this.toSeconds(time);\n\n    this._state.cancel(time);\n\n    this._state.setStateAtTime(Tone.State.Stopped, time);\n\n    this._tickSource.stop(time);\n\n    if (time < this._lastUpdate) {\n      this.emit(\"stop\", time);\n    }\n\n    return this;\n  };\n  /**\n   *  Pause the clock. Pausing does not reset the tick counter.\n   *  @param {Time} [time=now] The time when the clock should stop.\n   *  @returns {Tone.Clock} this\n   */\n\n\n  Tone.Clock.prototype.pause = function (time) {\n    time = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(time) === Tone.State.Started) {\n      this._state.setStateAtTime(Tone.State.Paused, time);\n\n      this._tickSource.pause(time);\n\n      if (time < this._lastUpdate) {\n        this.emit(\"pause\", time);\n      }\n    }\n\n    return this;\n  };\n  /**\n   *  The number of times the callback was invoked. Starts counting at 0\n   *  and increments after the callback was invoked.\n   *  @type {Ticks}\n   */\n\n\n  Object.defineProperty(Tone.Clock.prototype, \"ticks\", {\n    get: function () {\n      function get() {\n        return Math.ceil(this.getTicksAtTime(this.now()));\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(t) {\n        this._tickSource.ticks = t;\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  The time since ticks=0 that the Clock has been running. Accounts\n   *  for tempo curves\n   *  @type {Seconds}\n   */\n\n  Object.defineProperty(Tone.Clock.prototype, \"seconds\", {\n    get: function () {\n      function get() {\n        return this._tickSource.seconds;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(s) {\n        this._tickSource.seconds = s;\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  Return the elapsed seconds at the given time.\n   *  @param  {Time}  time  When to get the elapsed seconds\n   *  @return  {Seconds}  The number of elapsed seconds\n   */\n\n  Tone.Clock.prototype.getSecondsAtTime = function (time) {\n    return this._tickSource.getSecondsAtTime(time);\n  };\n  /**\n   * Set the clock's ticks at the given time.\n   * @param  {Ticks} ticks The tick value to set\n   * @param  {Time} time  When to set the tick value\n   * @return {Tone.Clock}       this\n   */\n\n\n  Tone.Clock.prototype.setTicksAtTime = function (ticks, time) {\n    this._tickSource.setTicksAtTime(ticks, time);\n\n    return this;\n  };\n  /**\n   * Get the clock's ticks at the given time.\n   * @param  {Time} time  When to get the tick value\n   * @return {Ticks}       The tick value at the given time.\n   */\n\n\n  Tone.Clock.prototype.getTicksAtTime = function (time) {\n    return this._tickSource.getTicksAtTime(time);\n  };\n  /**\n   * Get the time of the next tick\n   * @param  {Ticks} ticks The tick number.\n   * @param  {Time} before \n   * @return {Tone.Clock}       this\n   */\n\n\n  Tone.Clock.prototype.nextTickTime = function (offset, when) {\n    when = this.toSeconds(when);\n    var currentTick = this.getTicksAtTime(when);\n    return this._tickSource.getTimeOfTick(currentTick + offset, when);\n  };\n  /**\n   *  The scheduling loop.\n   *  @private\n   */\n\n\n  Tone.Clock.prototype._loop = function () {\n    var startTime = this._lastUpdate;\n    var endTime = this.now();\n    this._lastUpdate = endTime;\n\n    if (startTime !== endTime) {\n      //the state change events\n      this._state.forEachBetween(startTime, endTime, function (e) {\n        switch (e.state) {\n          case Tone.State.Started:\n            var offset = this._tickSource.getTicksAtTime(e.time);\n\n            this.emit(\"start\", e.time, offset);\n            break;\n\n          case Tone.State.Stopped:\n            if (e.time !== 0) {\n              this.emit(\"stop\", e.time);\n            }\n\n            break;\n\n          case Tone.State.Paused:\n            this.emit(\"pause\", e.time);\n            break;\n        }\n      }.bind(this)); //the tick callbacks\n\n\n      this._tickSource.forEachTickBetween(startTime, endTime, function (time, ticks) {\n        this.callback(time, ticks);\n      }.bind(this));\n    }\n  };\n  /**\n   *  Returns the scheduled state at the given time.\n   *  @param  {Time}  time  The time to query.\n   *  @return  {String}  The name of the state input in setStateAtTime.\n   *  @example\n   * clock.start(\"+0.1\");\n   * clock.getStateAtTime(\"+0.1\"); //returns \"started\"\n   */\n\n\n  Tone.Clock.prototype.getStateAtTime = function (time) {\n    time = this.toSeconds(time);\n    return this._state.getValueAtTime(time);\n  };\n  /**\n   *  Clean up\n   *  @returns {Tone.Clock} this\n   */\n\n\n  Tone.Clock.prototype.dispose = function () {\n    Tone.Emitter.prototype.dispose.call(this);\n    this.context.off(\"tick\", this._boundLoop);\n\n    this._writable(\"frequency\");\n\n    this._tickSource.dispose();\n\n    this._tickSource = null;\n    this.frequency = null;\n    this._boundLoop = null;\n    this._nextTick = Infinity;\n    this.callback = null;\n\n    this._state.dispose();\n\n    this._state = null;\n  };\n\n  return Tone.Clock;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvQ2xvY2suanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvQ2xvY2suanM/ZmIxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoW1wiVG9uZS9jb3JlL1RvbmVcIiwgXCJUb25lL3NvdXJjZS9UaWNrU291cmNlXCIsIFwiVG9uZS9jb3JlL1RpbWVsaW5lU3RhdGVcIixcblx0XCJUb25lL2NvcmUvRW1pdHRlclwiLCBcIlRvbmUvY29yZS9Db250ZXh0XCJdLCBmdW5jdGlvbihUb25lKXtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogIEBjbGFzcyAgQSBzYW1wbGUgYWNjdXJhdGUgY2xvY2sgd2hpY2ggcHJvdmlkZXMgYSBjYWxsYmFjayBhdCB0aGUgZ2l2ZW4gcmF0ZS5cblx0ICogICAgICAgICAgV2hpbGUgdGhlIGNhbGxiYWNrIGlzIG5vdCBzYW1wbGUtYWNjdXJhdGUgKGl0IGlzIHN0aWxsIHN1c2NlcHRpYmxlIHRvXG5cdCAqICAgICAgICAgIGxvb3NlIEpTIHRpbWluZyksIHRoZSB0aW1lIHBhc3NlZCBpbiBhcyB0aGUgYXJndW1lbnQgdG8gdGhlIGNhbGxiYWNrXG5cdCAqICAgICAgICAgIGlzIHByZWNpc2UuIEZvciBtb3N0IGFwcGxpY2F0aW9ucywgaXQgaXMgYmV0dGVyIHRvIHVzZSBUb25lLlRyYW5zcG9ydFxuXHQgKiAgICAgICAgICBpbnN0ZWFkIG9mIHRoZSBDbG9jayBieSBpdHNlbGYgc2luY2UgeW91IGNhbiBzeW5jaHJvbml6ZSBtdWx0aXBsZSBjYWxsYmFja3MuXG5cdCAqXG5cdCAqIFx0QGNvbnN0cnVjdG9yXG5cdCAqICBAZXh0ZW5kcyB7VG9uZS5FbWl0dGVyfVxuXHQgKiBcdEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdpdGggdGhlIHRpbWUgb2YgdGhlIGF1ZGlvIGV2ZW50XG5cdCAqIFx0QHBhcmFtIHtGcmVxdWVuY3l9IGZyZXF1ZW5jeSBUaGUgcmF0ZSBvZiB0aGUgY2FsbGJhY2tcblx0ICogXHRAZXhhbXBsZVxuXHQgKiAvL3RoZSBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgYXBwcm94aW1hdGVseSBvbmNlIGEgc2Vjb25kXG5cdCAqIC8vYW5kIHdpbGwgcHJpbnQgdGhlIHRpbWUgZXhhY3RseSBvbmNlIGEgc2Vjb25kIGFwYXJ0LlxuXHQgKiB2YXIgY2xvY2sgPSBuZXcgVG9uZS5DbG9jayhmdW5jdGlvbih0aW1lKXtcblx0ICogXHRjb25zb2xlLmxvZyh0aW1lKTtcblx0ICogfSwgMSk7XG5cdCAqL1xuXHRUb25lLkNsb2NrID0gZnVuY3Rpb24oKXtcblxuXHRcdHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcImNhbGxiYWNrXCIsIFwiZnJlcXVlbmN5XCJdLCBUb25lLkNsb2NrKTtcblx0XHRUb25lLkVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuXHRcdC8qKlxuXHRcdCAqICBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlIGF0IHRoZSBzY2hlZHVsZWQgdGljay5cblx0XHQgKiAgQHR5cGUgIHtGdW5jdGlvbn1cblx0XHQgKi9cblx0XHR0aGlzLmNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcblxuXHRcdC8qKlxuXHRcdCAqICBUaGUgbmV4dCB0aW1lIHRoZSBjYWxsYmFjayBpcyBzY2hlZHVsZWQuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbmV4dFRpY2sgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogIFRoZSB0aWNrIGNvdW50ZXJcblx0XHQgKiAgQHR5cGUgIHtUb25lLlRpY2tTb3VyY2V9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fdGlja1NvdXJjZSA9IG5ldyBUb25lLlRpY2tTb3VyY2Uob3B0aW9ucy5mcmVxdWVuY3kpO1xuXG5cdFx0LyoqXG5cdFx0ICogIFRoZSBsYXN0IHRpbWUgdGhlIGxvb3AgY2FsbGJhY2sgd2FzIGludm9rZWRcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLl9sYXN0VXBkYXRlID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqICBUaGUgcmF0ZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gc2hvdWxkIGJlIGludm9rZWQuXG5cdFx0ICogIEB0eXBlICB7QlBNfVxuXHRcdCAqICBAc2lnbmFsXG5cdFx0ICovXG5cdFx0dGhpcy5mcmVxdWVuY3kgPSB0aGlzLl90aWNrU291cmNlLmZyZXF1ZW5jeTtcblx0XHR0aGlzLl9yZWFkT25seShcImZyZXF1ZW5jeVwiKTtcblxuXHRcdC8qKlxuXHRcdCAqICBUaGUgc3RhdGUgdGltZWxpbmVcblx0XHQgKiAgQHR5cGUge1RvbmUuVGltZWxpbmVTdGF0ZX1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9zdGF0ZSA9IG5ldyBUb25lLlRpbWVsaW5lU3RhdGUoVG9uZS5TdGF0ZS5TdG9wcGVkKTtcblx0XHQvL2FkZCBhbiBpbml0aWFsIHN0YXRlXG5cdFx0dGhpcy5fc3RhdGUuc2V0U3RhdGVBdFRpbWUoVG9uZS5TdGF0ZS5TdG9wcGVkLCAwKTtcblxuXHRcdC8qKlxuXHRcdCAqICBUaGUgbG9vcCBmdW5jdGlvbiBib3VuZCB0byBpdHMgY29udGV4dC5cblx0XHQgKiAgVGhpcyBpcyBuZWNlc3NhcnkgdG8gcmVtb3ZlIHRoZSBldmVudCBpbiB0aGUgZW5kLlxuXHRcdCAqICBAdHlwZSB7RnVuY3Rpb259XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fYm91bmRMb29wID0gdGhpcy5fbG9vcC5iaW5kKHRoaXMpO1xuXG5cdFx0Ly9iaW5kIGEgY2FsbGJhY2sgdG8gdGhlIHdvcmtlciB0aHJlYWRcblx0XHR0aGlzLmNvbnRleHQub24oXCJ0aWNrXCIsIHRoaXMuX2JvdW5kTG9vcCk7XG5cdH07XG5cblx0VG9uZS5leHRlbmQoVG9uZS5DbG9jaywgVG9uZS5FbWl0dGVyKTtcblxuXHQvKipcblx0ICogIFRoZSBkZWZhdWx0c1xuXHQgKiAgQGNvbnN0XG5cdCAqICBAdHlwZSAge09iamVjdH1cblx0ICovXG5cdFRvbmUuQ2xvY2suZGVmYXVsdHMgPSB7XG5cdFx0XCJjYWxsYmFja1wiIDogVG9uZS5ub09wLFxuXHRcdFwiZnJlcXVlbmN5XCIgOiAxLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiAgUmV0dXJucyB0aGUgcGxheWJhY2sgc3RhdGUgb2YgdGhlIHNvdXJjZSwgZWl0aGVyIFwic3RhcnRlZFwiLCBcInN0b3BwZWRcIiBvciBcInBhdXNlZFwiLlxuXHQgKiAgQHR5cGUge1RvbmUuU3RhdGV9XG5cdCAqICBAcmVhZE9ubHlcblx0ICogIEBtZW1iZXJPZiBUb25lLkNsb2NrI1xuXHQgKiAgQG5hbWUgc3RhdGVcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkNsb2NrLnByb3RvdHlwZSwgXCJzdGF0ZVwiLCB7XG5cdFx0Z2V0IDogZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiB0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aGlzLm5vdygpKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiAgU3RhcnQgdGhlIGNsb2NrIGF0IHRoZSBnaXZlbiB0aW1lLiBPcHRpb25hbGx5IHBhc3MgaW4gYW4gb2Zmc2V0XG5cdCAqICBvZiB3aGVyZSB0byBzdGFydCB0aGUgdGljayBjb3VudGVyIGZyb20uXG5cdCAqICBAcGFyYW0gIHtUaW1lPX0gIHRpbWUgICAgVGhlIHRpbWUgdGhlIGNsb2NrIHNob3VsZCBzdGFydFxuXHQgKiAgQHBhcmFtICB7VGlja3M9fSAgb2Zmc2V0ICBXaGVyZSB0aGUgdGljayBjb3VudGVyIHN0YXJ0cyBjb3VudGluZyBmcm9tLlxuXHQgKiAgQHJldHVybiAge1RvbmUuQ2xvY2t9ICB0aGlzXG5cdCAqL1xuXHRUb25lLkNsb2NrLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKHRpbWUsIG9mZnNldCl7XG5cdFx0dGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHRcdGlmICh0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aW1lKSAhPT0gVG9uZS5TdGF0ZS5TdGFydGVkKXtcblx0XHRcdHRoaXMuX3N0YXRlLnNldFN0YXRlQXRUaW1lKFRvbmUuU3RhdGUuU3RhcnRlZCwgdGltZSk7XG5cdFx0XHR0aGlzLl90aWNrU291cmNlLnN0YXJ0KHRpbWUsIG9mZnNldCk7XG5cdFx0XHRpZiAodGltZSA8IHRoaXMuX2xhc3RVcGRhdGUpe1xuXHRcdFx0XHR0aGlzLmVtaXQoXCJzdGFydFwiLCB0aW1lLCBvZmZzZXQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogIFN0b3AgdGhlIGNsb2NrLiBTdG9wcGluZyB0aGUgY2xvY2sgcmVzZXRzIHRoZSB0aWNrIGNvdW50ZXIgdG8gMC5cblx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBUaGUgdGltZSB3aGVuIHRoZSBjbG9jayBzaG91bGQgc3RvcC5cblx0ICogIEByZXR1cm5zIHtUb25lLkNsb2NrfSB0aGlzXG5cdCAqICBAZXhhbXBsZVxuXHQgKiBjbG9jay5zdG9wKCk7XG5cdCAqL1xuXHRUb25lLkNsb2NrLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24odGltZSl7XG5cdFx0dGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHRcdHRoaXMuX3N0YXRlLmNhbmNlbCh0aW1lKTtcblx0XHR0aGlzLl9zdGF0ZS5zZXRTdGF0ZUF0VGltZShUb25lLlN0YXRlLlN0b3BwZWQsIHRpbWUpO1xuXHRcdHRoaXMuX3RpY2tTb3VyY2Uuc3RvcCh0aW1lKTtcblx0XHRpZiAodGltZSA8IHRoaXMuX2xhc3RVcGRhdGUpe1xuXHRcdFx0dGhpcy5lbWl0KFwic3RvcFwiLCB0aW1lKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqICBQYXVzZSB0aGUgY2xvY2suIFBhdXNpbmcgZG9lcyBub3QgcmVzZXQgdGhlIHRpY2sgY291bnRlci5cblx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBUaGUgdGltZSB3aGVuIHRoZSBjbG9jayBzaG91bGQgc3RvcC5cblx0ICogIEByZXR1cm5zIHtUb25lLkNsb2NrfSB0aGlzXG5cdCAqL1xuXHRUb25lLkNsb2NrLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKHRpbWUpe1xuXHRcdHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0XHRpZiAodGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodGltZSkgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCl7XG5cdFx0XHR0aGlzLl9zdGF0ZS5zZXRTdGF0ZUF0VGltZShUb25lLlN0YXRlLlBhdXNlZCwgdGltZSk7XG5cdFx0XHR0aGlzLl90aWNrU291cmNlLnBhdXNlKHRpbWUpO1xuXHRcdFx0aWYgKHRpbWUgPCB0aGlzLl9sYXN0VXBkYXRlKXtcblx0XHRcdFx0dGhpcy5lbWl0KFwicGF1c2VcIiwgdGltZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgY2FsbGJhY2sgd2FzIGludm9rZWQuIFN0YXJ0cyBjb3VudGluZyBhdCAwXG5cdCAqICBhbmQgaW5jcmVtZW50cyBhZnRlciB0aGUgY2FsbGJhY2sgd2FzIGludm9rZWQuXG5cdCAqICBAdHlwZSB7VGlja3N9XG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5DbG9jay5wcm90b3R5cGUsIFwidGlja3NcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gTWF0aC5jZWlsKHRoaXMuZ2V0VGlja3NBdFRpbWUodGhpcy5ub3coKSkpO1xuXHRcdH0sXG5cdFx0c2V0IDogZnVuY3Rpb24odCl7XG5cdFx0XHR0aGlzLl90aWNrU291cmNlLnRpY2tzID0gdDtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiAgVGhlIHRpbWUgc2luY2UgdGlja3M9MCB0aGF0IHRoZSBDbG9jayBoYXMgYmVlbiBydW5uaW5nLiBBY2NvdW50c1xuXHQgKiAgZm9yIHRlbXBvIGN1cnZlc1xuXHQgKiAgQHR5cGUge1NlY29uZHN9XG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5DbG9jay5wcm90b3R5cGUsIFwic2Vjb25kc1wiLCB7XG5cdFx0Z2V0IDogZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiB0aGlzLl90aWNrU291cmNlLnNlY29uZHM7XG5cdFx0fSxcblx0XHRzZXQgOiBmdW5jdGlvbihzKXtcblx0XHRcdHRoaXMuX3RpY2tTb3VyY2Uuc2Vjb25kcyA9IHM7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogIFJldHVybiB0aGUgZWxhcHNlZCBzZWNvbmRzIGF0IHRoZSBnaXZlbiB0aW1lLlxuXHQgKiAgQHBhcmFtICB7VGltZX0gIHRpbWUgIFdoZW4gdG8gZ2V0IHRoZSBlbGFwc2VkIHNlY29uZHNcblx0ICogIEByZXR1cm4gIHtTZWNvbmRzfSAgVGhlIG51bWJlciBvZiBlbGFwc2VkIHNlY29uZHNcblx0ICovXG5cdFRvbmUuQ2xvY2sucHJvdG90eXBlLmdldFNlY29uZHNBdFRpbWUgPSBmdW5jdGlvbih0aW1lKXtcblx0XHRyZXR1cm4gdGhpcy5fdGlja1NvdXJjZS5nZXRTZWNvbmRzQXRUaW1lKHRpbWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGNsb2NrJ3MgdGlja3MgYXQgdGhlIGdpdmVuIHRpbWUuXG5cdCAqIEBwYXJhbSAge1RpY2tzfSB0aWNrcyBUaGUgdGljayB2YWx1ZSB0byBzZXRcblx0ICogQHBhcmFtICB7VGltZX0gdGltZSAgV2hlbiB0byBzZXQgdGhlIHRpY2sgdmFsdWVcblx0ICogQHJldHVybiB7VG9uZS5DbG9ja30gICAgICAgdGhpc1xuXHQgKi9cblx0VG9uZS5DbG9jay5wcm90b3R5cGUuc2V0VGlja3NBdFRpbWUgPSBmdW5jdGlvbih0aWNrcywgdGltZSl7XG5cdFx0dGhpcy5fdGlja1NvdXJjZS5zZXRUaWNrc0F0VGltZSh0aWNrcywgdGltZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgY2xvY2sncyB0aWNrcyBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0ICogQHBhcmFtICB7VGltZX0gdGltZSAgV2hlbiB0byBnZXQgdGhlIHRpY2sgdmFsdWVcblx0ICogQHJldHVybiB7VGlja3N9ICAgICAgIFRoZSB0aWNrIHZhbHVlIGF0IHRoZSBnaXZlbiB0aW1lLlxuXHQgKi9cblx0VG9uZS5DbG9jay5wcm90b3R5cGUuZ2V0VGlja3NBdFRpbWUgPSBmdW5jdGlvbih0aW1lKXtcblx0XHRyZXR1cm4gdGhpcy5fdGlja1NvdXJjZS5nZXRUaWNrc0F0VGltZSh0aW1lKTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IHRoZSB0aW1lIG9mIHRoZSBuZXh0IHRpY2tcblx0ICogQHBhcmFtICB7VGlja3N9IHRpY2tzIFRoZSB0aWNrIG51bWJlci5cblx0ICogQHBhcmFtICB7VGltZX0gYmVmb3JlIFxuXHQgKiBAcmV0dXJuIHtUb25lLkNsb2NrfSAgICAgICB0aGlzXG5cdCAqL1xuXHRUb25lLkNsb2NrLnByb3RvdHlwZS5uZXh0VGlja1RpbWUgPSBmdW5jdGlvbihvZmZzZXQsIHdoZW4pe1xuXHRcdHdoZW4gPSB0aGlzLnRvU2Vjb25kcyh3aGVuKTtcblx0XHR2YXIgY3VycmVudFRpY2sgPSB0aGlzLmdldFRpY2tzQXRUaW1lKHdoZW4pO1xuXHRcdHJldHVybiB0aGlzLl90aWNrU291cmNlLmdldFRpbWVPZlRpY2soY3VycmVudFRpY2srb2Zmc2V0LCB3aGVuKTtcblx0fTtcblxuXHQvKipcblx0ICogIFRoZSBzY2hlZHVsaW5nIGxvb3AuXG5cdCAqICBAcHJpdmF0ZVxuXHQgKi9cblx0VG9uZS5DbG9jay5wcm90b3R5cGUuX2xvb3AgPSBmdW5jdGlvbigpe1xuXG5cdFx0dmFyIHN0YXJ0VGltZSA9IHRoaXMuX2xhc3RVcGRhdGU7XG5cdFx0dmFyIGVuZFRpbWUgPSB0aGlzLm5vdygpO1xuXHRcdHRoaXMuX2xhc3RVcGRhdGUgPSBlbmRUaW1lO1xuXG5cdFx0aWYgKHN0YXJ0VGltZSAhPT0gZW5kVGltZSl7XG5cdFx0XHQvL3RoZSBzdGF0ZSBjaGFuZ2UgZXZlbnRzXG5cdFx0XHR0aGlzLl9zdGF0ZS5mb3JFYWNoQmV0d2VlbihzdGFydFRpbWUsIGVuZFRpbWUsIGZ1bmN0aW9uKGUpe1xuXHRcdFx0XHRzd2l0Y2ggKGUuc3RhdGUpe1xuXHRcdFx0XHRcdGNhc2UgVG9uZS5TdGF0ZS5TdGFydGVkIDogXG5cdFx0XHRcdFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fdGlja1NvdXJjZS5nZXRUaWNrc0F0VGltZShlLnRpbWUpO1xuXHRcdFx0XHRcdFx0dGhpcy5lbWl0KFwic3RhcnRcIiwgZS50aW1lLCBvZmZzZXQpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBUb25lLlN0YXRlLlN0b3BwZWQgOiBcblx0XHRcdFx0XHRcdGlmIChlLnRpbWUgIT09IDApe1xuXHRcdFx0XHRcdFx0XHR0aGlzLmVtaXQoXCJzdG9wXCIsIGUudGltZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFRvbmUuU3RhdGUuUGF1c2VkIDpcblx0XHRcdFx0XHRcdHRoaXMuZW1pdChcInBhdXNlXCIsIGUudGltZSk7IFxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH0uYmluZCh0aGlzKSk7XG5cdFx0XHQvL3RoZSB0aWNrIGNhbGxiYWNrc1xuXHRcdFx0dGhpcy5fdGlja1NvdXJjZS5mb3JFYWNoVGlja0JldHdlZW4oc3RhcnRUaW1lLCBlbmRUaW1lLCBmdW5jdGlvbih0aW1lLCB0aWNrcyl7XG5cdFx0XHRcdHRoaXMuY2FsbGJhY2sodGltZSwgdGlja3MpO1xuXHRcdFx0fS5iaW5kKHRoaXMpKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqICBSZXR1cm5zIHRoZSBzY2hlZHVsZWQgc3RhdGUgYXQgdGhlIGdpdmVuIHRpbWUuXG5cdCAqICBAcGFyYW0gIHtUaW1lfSAgdGltZSAgVGhlIHRpbWUgdG8gcXVlcnkuXG5cdCAqICBAcmV0dXJuICB7U3RyaW5nfSAgVGhlIG5hbWUgb2YgdGhlIHN0YXRlIGlucHV0IGluIHNldFN0YXRlQXRUaW1lLlxuXHQgKiAgQGV4YW1wbGVcblx0ICogY2xvY2suc3RhcnQoXCIrMC4xXCIpO1xuXHQgKiBjbG9jay5nZXRTdGF0ZUF0VGltZShcIiswLjFcIik7IC8vcmV0dXJucyBcInN0YXJ0ZWRcIlxuXHQgKi9cblx0VG9uZS5DbG9jay5wcm90b3R5cGUuZ2V0U3RhdGVBdFRpbWUgPSBmdW5jdGlvbih0aW1lKXtcblx0XHR0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdFx0cmV0dXJuIHRoaXMuX3N0YXRlLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgQ2xlYW4gdXBcblx0ICogIEByZXR1cm5zIHtUb25lLkNsb2NrfSB0aGlzXG5cdCAqL1xuXHRUb25lLkNsb2NrLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKXtcblx0XHRUb25lLkVtaXR0ZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0XHR0aGlzLmNvbnRleHQub2ZmKFwidGlja1wiLCB0aGlzLl9ib3VuZExvb3ApO1xuXHRcdHRoaXMuX3dyaXRhYmxlKFwiZnJlcXVlbmN5XCIpO1xuXHRcdHRoaXMuX3RpY2tTb3VyY2UuZGlzcG9zZSgpO1xuXHRcdHRoaXMuX3RpY2tTb3VyY2UgPSBudWxsO1xuXHRcdHRoaXMuZnJlcXVlbmN5ID0gbnVsbDtcblx0XHR0aGlzLl9ib3VuZExvb3AgPSBudWxsO1xuXHRcdHRoaXMuX25leHRUaWNrID0gSW5maW5pdHk7XG5cdFx0dGhpcy5jYWxsYmFjayA9IG51bGw7XG5cdFx0dGhpcy5fc3RhdGUuZGlzcG9zZSgpO1xuXHRcdHRoaXMuX3N0YXRlID0gbnVsbDtcblx0fTtcblxuXHRyZXR1cm4gVG9uZS5DbG9jaztcbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7QUFFQTtBQUNBO0FBRUE7Ozs7O0FBSUE7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQUFBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFLQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBREE7QUFNQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUpBO0FBU0E7Ozs7OztBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUpBO0FBU0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/core/Clock.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/core/Context.js":
/*!************************************************!*\
  !*** ./node_modules/tone/Tone/core/Context.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/core/Emitter */ \"./node_modules/tone/Tone/core/Emitter.js\"), __webpack_require__(/*! Tone/core/Timeline */ \"./node_modules/tone/Tone/core/Timeline.js\"), __webpack_require__(/*! Tone/shim/AudioContext */ \"./node_modules/tone/Tone/shim/AudioContext.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  /**\n   *  @class Wrapper around the native AudioContext.\n   *  @extends {Tone.Emitter}\n   *  @param {AudioContext=} context optionally pass in a context\n   */\n  Tone.Context = function () {\n    Tone.Emitter.call(this);\n    var options = Tone.defaults(arguments, [\"context\"], Tone.Context);\n\n    if (!options.context) {\n      options.context = new window.AudioContext();\n\n      if (!options.context) {\n        throw new Error(\"could not create AudioContext. Possibly too many AudioContexts running already.\");\n      }\n    }\n\n    this._context = options.context; // extend all of the methods\n\n    for (var prop in this._context) {\n      this._defineProperty(this._context, prop);\n    }\n    /**\n     *  The default latency hint\n     *  @type  {String}\n     *  @private\n     */\n\n\n    this._latencyHint = options.latencyHint;\n    /**\n     *  An object containing all of the constants AudioBufferSourceNodes\n     *  @type  {Object}\n     *  @private\n     */\n\n    this._constants = {}; ///////////////////////////////////////////////////////////////////////\n    // WORKER\n    ///////////////////////////////////////////////////////////////////////\n\n    /**\n     *  The amount of time events are scheduled\n     *  into the future\n     *  @type  {Number}\n     */\n\n    this.lookAhead = options.lookAhead;\n    /**\n     *  A reference to the actual computed update interval\n     *  @type  {Number}\n     *  @private\n     */\n\n    this._computedUpdateInterval = 0;\n    /**\n     *  A reliable callback method\n     *  @private\n     *  @type  {Ticker}\n     */\n\n    this._ticker = new Ticker(this.emit.bind(this, \"tick\"), options.clockSource, options.updateInterval); ///////////////////////////////////////////////////////////////////////\n    // TIMEOUTS\n    ///////////////////////////////////////////////////////////////////////\n\n    /**\n     *  All of the setTimeout events.\n     *  @type  {Tone.Timeline}\n     *  @private\n     */\n\n    this._timeouts = new Tone.Timeline();\n    /**\n     *  The timeout id counter\n     *  @private\n     *  @type {Number}\n     */\n\n    this._timeoutIds = 0;\n    this.on(\"tick\", this._timeoutLoop.bind(this));\n  };\n\n  Tone.extend(Tone.Context, Tone.Emitter);\n  Tone.Emitter.mixin(Tone.Context);\n  /**\n   * defaults\n   * @static\n   * @type {Object}\n   */\n\n  Tone.Context.defaults = {\n    \"clockSource\": \"worker\",\n    \"latencyHint\": \"interactive\",\n    \"lookAhead\": 0.1,\n    \"updateInterval\": 0.03\n  };\n  /**\n   *  Define a property on this Tone.Context.\n   *  This is used to extend the native AudioContext\n   *  @param  {AudioContext}  context\n   *  @param  {String}  prop\n   *  @private\n   */\n\n  Tone.Context.prototype._defineProperty = function (context, prop) {\n    if (Tone.isUndef(this[prop])) {\n      Object.defineProperty(this, prop, {\n        get: function () {\n          function get() {\n            if (typeof context[prop] === \"function\") {\n              return context[prop].bind(context);\n            } else {\n              return context[prop];\n            }\n          }\n\n          return get;\n        }(),\n        set: function () {\n          function set(val) {\n            context[prop] = val;\n          }\n\n          return set;\n        }()\n      });\n    }\n  };\n  /**\n   *  The current audio context time\n   *  @return  {Number}\n   */\n\n\n  Tone.Context.prototype.now = function () {\n    return this._context.currentTime + this.lookAhead;\n  };\n  /**\n   *  Promise which is invoked when the context is running.\n   *  Tries to resume the context if it's not started.\n   *  @return  {Promise}\n   */\n\n\n  Tone.Context.prototype.ready = function () {\n    return new Promise(function (done) {\n      if (this._context.state === \"running\") {\n        done();\n      } else {\n        this._context.resume().then(function () {\n          done();\n        });\n      }\n    }.bind(this));\n  };\n  /**\n   *  Promise which is invoked when the context is running.\n   *  Tries to resume the context if it's not started.\n   *  @return  {Promise}\n   */\n\n\n  Tone.Context.prototype.close = function () {\n    return this._context.close().then(function () {\n      Tone.Context.emit(\"close\", this);\n    }.bind(this));\n  };\n  /**\n   *  Generate a looped buffer at some constant value.\n   *  @param  {Number}  val\n   *  @return  {BufferSourceNode}\n   */\n\n\n  Tone.Context.prototype.getConstant = function (val) {\n    if (this._constants[val]) {\n      return this._constants[val];\n    } else {\n      var buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n\n      var arr = buffer.getChannelData(0);\n\n      for (var i = 0; i < arr.length; i++) {\n        arr[i] = val;\n      }\n\n      var constant = this._context.createBufferSource();\n\n      constant.channelCount = 1;\n      constant.channelCountMode = \"explicit\";\n      constant.buffer = buffer;\n      constant.loop = true;\n      constant.start(0);\n      this._constants[val] = constant;\n      return constant;\n    }\n  };\n  /**\n   *  The private loop which keeps track of the context scheduled timeouts\n   *  Is invoked from the clock source\n   *  @private\n   */\n\n\n  Tone.Context.prototype._timeoutLoop = function () {\n    var now = this.now();\n\n    while (this._timeouts && this._timeouts.length && this._timeouts.peek().time <= now) {\n      this._timeouts.shift().callback();\n    }\n  };\n  /**\n   *  A setTimeout which is gaurenteed by the clock source.\n   *  Also runs in the offline context.\n   *  @param  {Function}  fn       The callback to invoke\n   *  @param  {Seconds}    timeout  The timeout in seconds\n   *  @returns {Number} ID to use when invoking Tone.Context.clearTimeout\n   */\n\n\n  Tone.Context.prototype.setTimeout = function (fn, timeout) {\n    this._timeoutIds++;\n    var now = this.now();\n\n    this._timeouts.add({\n      callback: fn,\n      time: now + timeout,\n      id: this._timeoutIds\n    });\n\n    return this._timeoutIds;\n  };\n  /**\n   *  Clears a previously scheduled timeout with Tone.context.setTimeout\n   *  @param  {Number}  id  The ID returned from setTimeout\n   *  @return  {Tone.Context}  this\n   */\n\n\n  Tone.Context.prototype.clearTimeout = function (id) {\n    this._timeouts.forEach(function (event) {\n      if (event.id === id) {\n        this.remove(event);\n      }\n    });\n\n    return this;\n  };\n  /**\n   *  How often the Web Worker callback is invoked.\n   *  This number corresponds to how responsive the scheduling\n   *  can be. Context.updateInterval + Context.lookAhead gives you the\n   *  total latency between scheduling an event and hearing it.\n   *  @type {Number}\n   *  @memberOf Tone.Context#\n   *  @name updateInterval\n   */\n\n\n  Object.defineProperty(Tone.Context.prototype, \"updateInterval\", {\n    get: function () {\n      function get() {\n        return this._ticker.updateInterval;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(interval) {\n        this._ticker.updateInterval = interval;\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  What the source of the clock is, either \"worker\" (Web Worker [default]),\n   *  \"timeout\" (setTimeout), or \"offline\" (none).\n   *  @type {String}\n   *  @memberOf Tone.Context#\n   *  @name clockSource\n   */\n\n  Object.defineProperty(Tone.Context.prototype, \"clockSource\", {\n    get: function () {\n      function get() {\n        return this._ticker.type;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(type) {\n        this._ticker.type = type;\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  The type of playback, which affects tradeoffs between audio\n   *  output latency and responsiveness.\n   *\n   *  In addition to setting the value in seconds, the latencyHint also\n   *  accepts the strings \"interactive\" (prioritizes low latency),\n   *  \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n   *  latency and performance), and \"fastest\" (lowest latency, might glitch more often).\n   *  @type {String|Seconds}\n   *  @memberOf Tone.Context#\n   *  @name latencyHint\n   *  @example\n   * //set the lookAhead to 0.3 seconds\n   * Tone.context.latencyHint = 0.3;\n   */\n\n  Object.defineProperty(Tone.Context.prototype, \"latencyHint\", {\n    get: function () {\n      function get() {\n        return this._latencyHint;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(hint) {\n        var lookAhead = hint;\n        this._latencyHint = hint;\n\n        if (Tone.isString(hint)) {\n          switch (hint) {\n            case \"interactive\":\n              lookAhead = 0.1;\n              this._context.latencyHint = hint;\n              break;\n\n            case \"playback\":\n              lookAhead = 0.8;\n              this._context.latencyHint = hint;\n              break;\n\n            case \"balanced\":\n              lookAhead = 0.25;\n              this._context.latencyHint = hint;\n              break;\n\n            case \"fastest\":\n              this._context.latencyHint = \"interactive\";\n              lookAhead = 0.01;\n              break;\n          }\n        }\n\n        this.lookAhead = lookAhead;\n        this.updateInterval = lookAhead / 3;\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  Unlike other dispose methods, this returns a Promise\n   *  which executes when the context is closed and disposed\n   *  @returns {Promise} this\n   */\n\n  Tone.Context.prototype.dispose = function () {\n    return this.close().then(function () {\n      Tone.Emitter.prototype.dispose.call(this);\n\n      this._ticker.dispose();\n\n      this._ticker = null;\n\n      this._timeouts.dispose();\n\n      this._timeouts = null;\n\n      for (var con in this._constants) {\n        this._constants[con].disconnect();\n      }\n\n      this._constants = null;\n    }.bind(this));\n  };\n  /**\n   * @class A class which provides a reliable callback using either\n   *        a Web Worker, or if that isn't supported, falls back to setTimeout.\n   * @private\n   */\n\n\n  var Ticker = function Ticker(callback, type, updateInterval) {\n    /**\n     * Either \"worker\" or \"timeout\"\n     * @type {String}\n     * @private\n     */\n    this._type = type;\n    /**\n     * The update interval of the worker\n     * @private\n     * @type {Number}\n     */\n\n    this._updateInterval = updateInterval;\n    /**\n     * The callback to invoke at regular intervals\n     * @type {Function}\n     * @private\n     */\n\n    this._callback = Tone.defaultArg(callback, Tone.noOp); //create the clock source for the first time\n\n    this._createClock();\n  };\n  /**\n   * The possible ticker types\n   * @private\n   * @type {Object}\n   */\n\n\n  Ticker.Type = {\n    Worker: \"worker\",\n    Timeout: \"timeout\",\n    Offline: \"offline\"\n  };\n  /**\n   *  Generate a web worker\n   *  @return  {WebWorker}\n   *  @private\n   */\n\n  Ticker.prototype._createWorker = function () {\n    //URL Shim\n    window.URL = window.URL || window.webkitURL;\n    var blob = new Blob([//the initial timeout time\n    \"var timeoutTime = \" + (this._updateInterval * 1000).toFixed(1) + \";\" + //onmessage callback\n    \"self.onmessage = function(msg){\" + \"\ttimeoutTime = parseInt(msg.data);\" + \"};\" + //the tick function which posts a message\n    //and schedules a new tick\n    \"function tick(){\" + \"\tsetTimeout(tick, timeoutTime);\" + \"\tself.postMessage('tick');\" + \"}\" + //call tick initially\n    \"tick();\"]);\n    var blobUrl = URL.createObjectURL(blob);\n    var worker = new Worker(blobUrl);\n    worker.onmessage = this._callback.bind(this);\n    this._worker = worker;\n  };\n  /**\n   * Create a timeout loop\n   * @private\n   */\n\n\n  Ticker.prototype._createTimeout = function () {\n    this._timeout = setTimeout(function () {\n      this._createTimeout();\n\n      this._callback();\n    }.bind(this), this._updateInterval * 1000);\n  };\n  /**\n   * Create the clock source.\n   * @private\n   */\n\n\n  Ticker.prototype._createClock = function () {\n    if (this._type === Ticker.Type.Worker) {\n      try {\n        this._createWorker();\n      } catch (e) {\n        // workers not supported, fallback to timeout\n        this._type = Ticker.Type.Timeout;\n\n        this._createClock();\n      }\n    } else if (this._type === Ticker.Type.Timeout) {\n      this._createTimeout();\n    }\n  };\n  /**\n   * @memberOf Ticker#\n   * @type {Number}\n   * @name updateInterval\n   * @private\n   */\n\n\n  Object.defineProperty(Ticker.prototype, \"updateInterval\", {\n    get: function () {\n      function get() {\n        return this._updateInterval;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(interval) {\n        this._updateInterval = Math.max(interval, 128 / 44100);\n\n        if (this._type === Ticker.Type.Worker) {\n          this._worker.postMessage(Math.max(interval * 1000, 1));\n        }\n      }\n\n      return set;\n    }()\n  });\n  /**\n   * The type of the ticker, either a worker or a timeout\n   * @memberOf Ticker#\n   * @type {Number}\n   * @name type\n   * @private\n   */\n\n  Object.defineProperty(Ticker.prototype, \"type\", {\n    get: function () {\n      function get() {\n        return this._type;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(type) {\n        this._disposeClock();\n\n        this._type = type;\n\n        this._createClock();\n      }\n\n      return set;\n    }()\n  });\n  /**\n   * Clean up the current clock source\n   * @private\n   */\n\n  Ticker.prototype._disposeClock = function () {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = null;\n    }\n\n    if (this._worker) {\n      this._worker.terminate();\n\n      this._worker.onmessage = null;\n      this._worker = null;\n    }\n  };\n  /**\n   * Clean up\n   * @private\n   */\n\n\n  Ticker.prototype.dispose = function () {\n    this._disposeClock();\n\n    this._callback = null;\n  };\n  /**\n   *  Shim all connect/disconnect and some deprecated methods which are still in\n   *  some older implementations.\n   *  @private\n   */\n\n\n  Tone.getContext(function () {\n    var nativeConnect = AudioNode.prototype.connect;\n    var nativeDisconnect = AudioNode.prototype.disconnect; //replace the old connect method\n\n    function toneConnect(B, outNum, inNum) {\n      if (B.input) {\n        inNum = Tone.defaultArg(inNum, 0);\n\n        if (Tone.isArray(B.input)) {\n          return this.connect(B.input[inNum]);\n        } else {\n          return this.connect(B.input, outNum, inNum);\n        }\n      } else {\n        try {\n          if (B instanceof AudioNode) {\n            nativeConnect.call(this, B, outNum, inNum);\n            return B;\n          } else {\n            nativeConnect.call(this, B, outNum);\n            return B;\n          }\n        } catch (e) {\n          throw new Error(\"error connecting to node: \" + B + \"\\n\" + e);\n        }\n      }\n    } //replace the old disconnect method\n\n\n    function toneDisconnect(B, outNum, inNum) {\n      if (B && B.input && Tone.isArray(B.input)) {\n        inNum = Tone.defaultArg(inNum, 0);\n        this.disconnect(B.input[inNum], outNum, 0);\n      } else if (B && B.input) {\n        this.disconnect(B.input, outNum, inNum);\n      } else {\n        try {\n          nativeDisconnect.apply(this, arguments);\n        } catch (e) {\n          throw new Error(\"error disconnecting node: \" + B + \"\\n\" + e);\n        }\n      }\n    }\n\n    if (AudioNode.prototype.connect !== toneConnect) {\n      AudioNode.prototype.connect = toneConnect;\n      AudioNode.prototype.disconnect = toneDisconnect;\n    }\n  }); // set the audio context initially, and if one is not already created\n\n  if (Tone.supported && !Tone.initialized) {\n    Tone.context = new Tone.Context(); // log on first initialization\n    // allow optional silencing of this log\n\n    if (!window.TONE_SILENCE_VERSION_LOGGING) {\n      // eslint-disable-next-line no-console\n      console.log(\"%c * Tone.js \" + Tone.version + \" * \", \"background: #000; color: #fff\");\n    }\n  } else if (!Tone.supported) {\n    // eslint-disable-next-line no-console\n    console.warn(\"This browser does not support Tone.js\");\n  }\n\n  return Tone.Context;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvQ29udGV4dC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90b25lL1RvbmUvY29yZS9Db250ZXh0LmpzPzExZDIiXSwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFtcIlRvbmUvY29yZS9Ub25lXCIsIFwiVG9uZS9jb3JlL0VtaXR0ZXJcIiwgXCJUb25lL2NvcmUvVGltZWxpbmVcIiwgXCJUb25lL3NoaW0vQXVkaW9Db250ZXh0XCJdLCBmdW5jdGlvbihUb25lKXtcblxuXHQvKipcblx0ICogIEBjbGFzcyBXcmFwcGVyIGFyb3VuZCB0aGUgbmF0aXZlIEF1ZGlvQ29udGV4dC5cblx0ICogIEBleHRlbmRzIHtUb25lLkVtaXR0ZXJ9XG5cdCAqICBAcGFyYW0ge0F1ZGlvQ29udGV4dD19IGNvbnRleHQgb3B0aW9uYWxseSBwYXNzIGluIGEgY29udGV4dFxuXHQgKi9cblx0VG9uZS5Db250ZXh0ID0gZnVuY3Rpb24oKXtcblxuXHRcdFRvbmUuRW1pdHRlci5jYWxsKHRoaXMpO1xuXG5cdFx0dmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1wiY29udGV4dFwiXSwgVG9uZS5Db250ZXh0KTtcblxuXHRcdGlmICghb3B0aW9ucy5jb250ZXh0KXtcblx0XHRcdG9wdGlvbnMuY29udGV4dCA9IG5ldyB3aW5kb3cuQXVkaW9Db250ZXh0KCk7XG5cdFx0XHRpZiAoIW9wdGlvbnMuY29udGV4dCl7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImNvdWxkIG5vdCBjcmVhdGUgQXVkaW9Db250ZXh0LiBQb3NzaWJseSB0b28gbWFueSBBdWRpb0NvbnRleHRzIHJ1bm5pbmcgYWxyZWFkeS5cIik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2NvbnRleHQgPSBvcHRpb25zLmNvbnRleHQ7XG5cdFx0Ly8gZXh0ZW5kIGFsbCBvZiB0aGUgbWV0aG9kc1xuXHRcdGZvciAodmFyIHByb3AgaW4gdGhpcy5fY29udGV4dCl7XG5cdFx0XHR0aGlzLl9kZWZpbmVQcm9wZXJ0eSh0aGlzLl9jb250ZXh0LCBwcm9wKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiAgVGhlIGRlZmF1bHQgbGF0ZW5jeSBoaW50XG5cdFx0ICogIEB0eXBlICB7U3RyaW5nfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xhdGVuY3lIaW50ID0gb3B0aW9ucy5sYXRlbmN5SGludDtcblxuXHRcdC8qKlxuXHRcdCAqICBBbiBvYmplY3QgY29udGFpbmluZyBhbGwgb2YgdGhlIGNvbnN0YW50cyBBdWRpb0J1ZmZlclNvdXJjZU5vZGVzXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2NvbnN0YW50cyA9IHt9O1xuXG5cdFx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0XHQvLyBXT1JLRVJcblx0XHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cdFx0LyoqXG5cdFx0ICogIFRoZSBhbW91bnQgb2YgdGltZSBldmVudHMgYXJlIHNjaGVkdWxlZFxuXHRcdCAqICBpbnRvIHRoZSBmdXR1cmVcblx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5sb29rQWhlYWQgPSBvcHRpb25zLmxvb2tBaGVhZDtcblxuXHRcdC8qKlxuXHRcdCAqICBBIHJlZmVyZW5jZSB0byB0aGUgYWN0dWFsIGNvbXB1dGVkIHVwZGF0ZSBpbnRlcnZhbFxuXHRcdCAqICBAdHlwZSAge051bWJlcn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9jb21wdXRlZFVwZGF0ZUludGVydmFsID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqICBBIHJlbGlhYmxlIGNhbGxiYWNrIG1ldGhvZFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAdHlwZSAge1RpY2tlcn1cblx0XHQgKi9cblx0XHR0aGlzLl90aWNrZXIgPSBuZXcgVGlja2VyKHRoaXMuZW1pdC5iaW5kKHRoaXMsIFwidGlja1wiKSwgb3B0aW9ucy5jbG9ja1NvdXJjZSwgb3B0aW9ucy51cGRhdGVJbnRlcnZhbCk7XG5cblx0XHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHRcdC8vIFRJTUVPVVRTXG5cdFx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHRcdC8qKlxuXHRcdCAqICBBbGwgb2YgdGhlIHNldFRpbWVvdXQgZXZlbnRzLlxuXHRcdCAqICBAdHlwZSAge1RvbmUuVGltZWxpbmV9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fdGltZW91dHMgPSBuZXcgVG9uZS5UaW1lbGluZSgpO1xuXG5cdFx0LyoqXG5cdFx0ICogIFRoZSB0aW1lb3V0IGlkIGNvdW50ZXJcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLl90aW1lb3V0SWRzID0gMDtcblxuXHRcdHRoaXMub24oXCJ0aWNrXCIsIHRoaXMuX3RpbWVvdXRMb29wLmJpbmQodGhpcykpO1xuXG5cdH07XG5cblx0VG9uZS5leHRlbmQoVG9uZS5Db250ZXh0LCBUb25lLkVtaXR0ZXIpO1xuXHRUb25lLkVtaXR0ZXIubWl4aW4oVG9uZS5Db250ZXh0KTtcblxuXHQvKipcblx0ICogZGVmYXVsdHNcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKi9cblx0VG9uZS5Db250ZXh0LmRlZmF1bHRzID0ge1xuXHRcdFwiY2xvY2tTb3VyY2VcIiA6IFwid29ya2VyXCIsXG5cdFx0XCJsYXRlbmN5SGludFwiIDogXCJpbnRlcmFjdGl2ZVwiLFxuXHRcdFwibG9va0FoZWFkXCIgOiAwLjEsXG5cdFx0XCJ1cGRhdGVJbnRlcnZhbFwiIDogMC4wM1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgRGVmaW5lIGEgcHJvcGVydHkgb24gdGhpcyBUb25lLkNvbnRleHQuXG5cdCAqICBUaGlzIGlzIHVzZWQgdG8gZXh0ZW5kIHRoZSBuYXRpdmUgQXVkaW9Db250ZXh0XG5cdCAqICBAcGFyYW0gIHtBdWRpb0NvbnRleHR9ICBjb250ZXh0XG5cdCAqICBAcGFyYW0gIHtTdHJpbmd9ICBwcm9wXG5cdCAqICBAcHJpdmF0ZVxuXHQgKi9cblx0VG9uZS5Db250ZXh0LnByb3RvdHlwZS5fZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbihjb250ZXh0LCBwcm9wKXtcblx0XHRpZiAoVG9uZS5pc1VuZGVmKHRoaXNbcHJvcF0pKXtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wLCB7XG5cdFx0XHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBjb250ZXh0W3Byb3BdID09PSBcImZ1bmN0aW9uXCIpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIGNvbnRleHRbcHJvcF0uYmluZChjb250ZXh0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGNvbnRleHRbcHJvcF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQgOiBmdW5jdGlvbih2YWwpe1xuXHRcdFx0XHRcdGNvbnRleHRbcHJvcF0gPSB2YWw7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogIFRoZSBjdXJyZW50IGF1ZGlvIGNvbnRleHQgdGltZVxuXHQgKiAgQHJldHVybiAge051bWJlcn1cblx0ICovXG5cdFRvbmUuQ29udGV4dC5wcm90b3R5cGUubm93ID0gZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gdGhpcy5fY29udGV4dC5jdXJyZW50VGltZSArIHRoaXMubG9va0FoZWFkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgUHJvbWlzZSB3aGljaCBpcyBpbnZva2VkIHdoZW4gdGhlIGNvbnRleHQgaXMgcnVubmluZy5cblx0ICogIFRyaWVzIHRvIHJlc3VtZSB0aGUgY29udGV4dCBpZiBpdCdzIG5vdCBzdGFydGVkLlxuXHQgKiAgQHJldHVybiAge1Byb21pc2V9XG5cdCAqL1xuXHRUb25lLkNvbnRleHQucHJvdG90eXBlLnJlYWR5ID0gZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oZG9uZSl7XG5cdFx0XHRpZiAodGhpcy5fY29udGV4dC5zdGF0ZSA9PT0gXCJydW5uaW5nXCIpe1xuXHRcdFx0XHRkb25lKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9jb250ZXh0LnJlc3VtZSgpLnRoZW4oZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRkb25lKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0uYmluZCh0aGlzKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqICBQcm9taXNlIHdoaWNoIGlzIGludm9rZWQgd2hlbiB0aGUgY29udGV4dCBpcyBydW5uaW5nLlxuXHQgKiAgVHJpZXMgdG8gcmVzdW1lIHRoZSBjb250ZXh0IGlmIGl0J3Mgbm90IHN0YXJ0ZWQuXG5cdCAqICBAcmV0dXJuICB7UHJvbWlzZX1cblx0ICovXG5cdFRvbmUuQ29udGV4dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpe1xuXHRcdHJldHVybiB0aGlzLl9jb250ZXh0LmNsb3NlKCkudGhlbihmdW5jdGlvbigpe1xuXHRcdFx0VG9uZS5Db250ZXh0LmVtaXQoXCJjbG9zZVwiLCB0aGlzKTtcblx0XHR9LmJpbmQodGhpcykpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgR2VuZXJhdGUgYSBsb29wZWQgYnVmZmVyIGF0IHNvbWUgY29uc3RhbnQgdmFsdWUuXG5cdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB2YWxcblx0ICogIEByZXR1cm4gIHtCdWZmZXJTb3VyY2VOb2RlfVxuXHQgKi9cblx0VG9uZS5Db250ZXh0LnByb3RvdHlwZS5nZXRDb25zdGFudCA9IGZ1bmN0aW9uKHZhbCl7XG5cdFx0aWYgKHRoaXMuX2NvbnN0YW50c1t2YWxdKXtcblx0XHRcdHJldHVybiB0aGlzLl9jb25zdGFudHNbdmFsXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGJ1ZmZlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQnVmZmVyKDEsIDEyOCwgdGhpcy5fY29udGV4dC5zYW1wbGVSYXRlKTtcblx0XHRcdHZhciBhcnIgPSBidWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdGFycltpXSA9IHZhbDtcblx0XHRcdH1cblx0XHRcdHZhciBjb25zdGFudCA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cdFx0XHRjb25zdGFudC5jaGFubmVsQ291bnQgPSAxO1xuXHRcdFx0Y29uc3RhbnQuY2hhbm5lbENvdW50TW9kZSA9IFwiZXhwbGljaXRcIjtcblx0XHRcdGNvbnN0YW50LmJ1ZmZlciA9IGJ1ZmZlcjtcblx0XHRcdGNvbnN0YW50Lmxvb3AgPSB0cnVlO1xuXHRcdFx0Y29uc3RhbnQuc3RhcnQoMCk7XG5cdFx0XHR0aGlzLl9jb25zdGFudHNbdmFsXSA9IGNvbnN0YW50O1xuXHRcdFx0cmV0dXJuIGNvbnN0YW50O1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogIFRoZSBwcml2YXRlIGxvb3Agd2hpY2gga2VlcHMgdHJhY2sgb2YgdGhlIGNvbnRleHQgc2NoZWR1bGVkIHRpbWVvdXRzXG5cdCAqICBJcyBpbnZva2VkIGZyb20gdGhlIGNsb2NrIHNvdXJjZVxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdFRvbmUuQ29udGV4dC5wcm90b3R5cGUuX3RpbWVvdXRMb29wID0gZnVuY3Rpb24oKXtcblx0XHR2YXIgbm93ID0gdGhpcy5ub3coKTtcblx0XHR3aGlsZSAodGhpcy5fdGltZW91dHMgJiYgdGhpcy5fdGltZW91dHMubGVuZ3RoICYmIHRoaXMuX3RpbWVvdXRzLnBlZWsoKS50aW1lIDw9IG5vdyl7XG5cdFx0XHR0aGlzLl90aW1lb3V0cy5zaGlmdCgpLmNhbGxiYWNrKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiAgQSBzZXRUaW1lb3V0IHdoaWNoIGlzIGdhdXJlbnRlZWQgYnkgdGhlIGNsb2NrIHNvdXJjZS5cblx0ICogIEFsc28gcnVucyBpbiB0aGUgb2ZmbGluZSBjb250ZXh0LlxuXHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBmbiAgICAgICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlXG5cdCAqICBAcGFyYW0gIHtTZWNvbmRzfSAgICB0aW1lb3V0ICBUaGUgdGltZW91dCBpbiBzZWNvbmRzXG5cdCAqICBAcmV0dXJucyB7TnVtYmVyfSBJRCB0byB1c2Ugd2hlbiBpbnZva2luZyBUb25lLkNvbnRleHQuY2xlYXJUaW1lb3V0XG5cdCAqL1xuXHRUb25lLkNvbnRleHQucHJvdG90eXBlLnNldFRpbWVvdXQgPSBmdW5jdGlvbihmbiwgdGltZW91dCl7XG5cdFx0dGhpcy5fdGltZW91dElkcysrO1xuXHRcdHZhciBub3cgPSB0aGlzLm5vdygpO1xuXHRcdHRoaXMuX3RpbWVvdXRzLmFkZCh7XG5cdFx0XHRjYWxsYmFjayA6IGZuLFxuXHRcdFx0dGltZSA6IG5vdyArIHRpbWVvdXQsXG5cdFx0XHRpZCA6IHRoaXMuX3RpbWVvdXRJZHNcblx0XHR9KTtcblx0XHRyZXR1cm4gdGhpcy5fdGltZW91dElkcztcblx0fTtcblxuXHQvKipcblx0ICogIENsZWFycyBhIHByZXZpb3VzbHkgc2NoZWR1bGVkIHRpbWVvdXQgd2l0aCBUb25lLmNvbnRleHQuc2V0VGltZW91dFxuXHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgaWQgIFRoZSBJRCByZXR1cm5lZCBmcm9tIHNldFRpbWVvdXRcblx0ICogIEByZXR1cm4gIHtUb25lLkNvbnRleHR9ICB0aGlzXG5cdCAqL1xuXHRUb25lLkNvbnRleHQucHJvdG90eXBlLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uKGlkKXtcblx0XHR0aGlzLl90aW1lb3V0cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KXtcblx0XHRcdGlmIChldmVudC5pZCA9PT0gaWQpe1xuXHRcdFx0XHR0aGlzLnJlbW92ZShldmVudCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqICBIb3cgb2Z0ZW4gdGhlIFdlYiBXb3JrZXIgY2FsbGJhY2sgaXMgaW52b2tlZC5cblx0ICogIFRoaXMgbnVtYmVyIGNvcnJlc3BvbmRzIHRvIGhvdyByZXNwb25zaXZlIHRoZSBzY2hlZHVsaW5nXG5cdCAqICBjYW4gYmUuIENvbnRleHQudXBkYXRlSW50ZXJ2YWwgKyBDb250ZXh0Lmxvb2tBaGVhZCBnaXZlcyB5b3UgdGhlXG5cdCAqICB0b3RhbCBsYXRlbmN5IGJldHdlZW4gc2NoZWR1bGluZyBhbiBldmVudCBhbmQgaGVhcmluZyBpdC5cblx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdCAqICBAbWVtYmVyT2YgVG9uZS5Db250ZXh0I1xuXHQgKiAgQG5hbWUgdXBkYXRlSW50ZXJ2YWxcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkNvbnRleHQucHJvdG90eXBlLCBcInVwZGF0ZUludGVydmFsXCIsIHtcblx0XHRnZXQgOiBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX3RpY2tlci51cGRhdGVJbnRlcnZhbDtcblx0XHR9LFxuXHRcdHNldCA6IGZ1bmN0aW9uKGludGVydmFsKXtcblx0XHRcdHRoaXMuX3RpY2tlci51cGRhdGVJbnRlcnZhbCA9IGludGVydmFsO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqICBXaGF0IHRoZSBzb3VyY2Ugb2YgdGhlIGNsb2NrIGlzLCBlaXRoZXIgXCJ3b3JrZXJcIiAoV2ViIFdvcmtlciBbZGVmYXVsdF0pLFxuXHQgKiAgXCJ0aW1lb3V0XCIgKHNldFRpbWVvdXQpLCBvciBcIm9mZmxpbmVcIiAobm9uZSkuXG5cdCAqICBAdHlwZSB7U3RyaW5nfVxuXHQgKiAgQG1lbWJlck9mIFRvbmUuQ29udGV4dCNcblx0ICogIEBuYW1lIGNsb2NrU291cmNlXG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Db250ZXh0LnByb3RvdHlwZSwgXCJjbG9ja1NvdXJjZVwiLCB7XG5cdFx0Z2V0IDogZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiB0aGlzLl90aWNrZXIudHlwZTtcblx0XHR9LFxuXHRcdHNldCA6IGZ1bmN0aW9uKHR5cGUpe1xuXHRcdFx0dGhpcy5fdGlja2VyLnR5cGUgPSB0eXBlO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqICBUaGUgdHlwZSBvZiBwbGF5YmFjaywgd2hpY2ggYWZmZWN0cyB0cmFkZW9mZnMgYmV0d2VlbiBhdWRpb1xuXHQgKiAgb3V0cHV0IGxhdGVuY3kgYW5kIHJlc3BvbnNpdmVuZXNzLlxuXHQgKlxuXHQgKiAgSW4gYWRkaXRpb24gdG8gc2V0dGluZyB0aGUgdmFsdWUgaW4gc2Vjb25kcywgdGhlIGxhdGVuY3lIaW50IGFsc29cblx0ICogIGFjY2VwdHMgdGhlIHN0cmluZ3MgXCJpbnRlcmFjdGl2ZVwiIChwcmlvcml0aXplcyBsb3cgbGF0ZW5jeSksXG5cdCAqICBcInBsYXliYWNrXCIgKHByaW9yaXRpemVzIHN1c3RhaW5lZCBwbGF5YmFjayksIFwiYmFsYW5jZWRcIiAoYmFsYW5jZXNcblx0ICogIGxhdGVuY3kgYW5kIHBlcmZvcm1hbmNlKSwgYW5kIFwiZmFzdGVzdFwiIChsb3dlc3QgbGF0ZW5jeSwgbWlnaHQgZ2xpdGNoIG1vcmUgb2Z0ZW4pLlxuXHQgKiAgQHR5cGUge1N0cmluZ3xTZWNvbmRzfVxuXHQgKiAgQG1lbWJlck9mIFRvbmUuQ29udGV4dCNcblx0ICogIEBuYW1lIGxhdGVuY3lIaW50XG5cdCAqICBAZXhhbXBsZVxuXHQgKiAvL3NldCB0aGUgbG9va0FoZWFkIHRvIDAuMyBzZWNvbmRzXG5cdCAqIFRvbmUuY29udGV4dC5sYXRlbmN5SGludCA9IDAuMztcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkNvbnRleHQucHJvdG90eXBlLCBcImxhdGVuY3lIaW50XCIsIHtcblx0XHRnZXQgOiBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX2xhdGVuY3lIaW50O1xuXHRcdH0sXG5cdFx0c2V0IDogZnVuY3Rpb24oaGludCl7XG5cdFx0XHR2YXIgbG9va0FoZWFkID0gaGludDtcblx0XHRcdHRoaXMuX2xhdGVuY3lIaW50ID0gaGludDtcblx0XHRcdGlmIChUb25lLmlzU3RyaW5nKGhpbnQpKXtcblx0XHRcdFx0c3dpdGNoIChoaW50KXtcblx0XHRcdFx0XHRjYXNlIFwiaW50ZXJhY3RpdmVcIiA6XG5cdFx0XHRcdFx0XHRsb29rQWhlYWQgPSAwLjE7XG5cdFx0XHRcdFx0XHR0aGlzLl9jb250ZXh0LmxhdGVuY3lIaW50ID0gaGludDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJwbGF5YmFja1wiIDpcblx0XHRcdFx0XHRcdGxvb2tBaGVhZCA9IDAuODtcblx0XHRcdFx0XHRcdHRoaXMuX2NvbnRleHQubGF0ZW5jeUhpbnQgPSBoaW50O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcImJhbGFuY2VkXCIgOlxuXHRcdFx0XHRcdFx0bG9va0FoZWFkID0gMC4yNTtcblx0XHRcdFx0XHRcdHRoaXMuX2NvbnRleHQubGF0ZW5jeUhpbnQgPSBoaW50O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcImZhc3Rlc3RcIiA6XG5cdFx0XHRcdFx0XHR0aGlzLl9jb250ZXh0LmxhdGVuY3lIaW50ID0gXCJpbnRlcmFjdGl2ZVwiO1xuXHRcdFx0XHRcdFx0bG9va0FoZWFkID0gMC4wMTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmxvb2tBaGVhZCA9IGxvb2tBaGVhZDtcblx0XHRcdHRoaXMudXBkYXRlSW50ZXJ2YWwgPSBsb29rQWhlYWQvMztcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiAgVW5saWtlIG90aGVyIGRpc3Bvc2UgbWV0aG9kcywgdGhpcyByZXR1cm5zIGEgUHJvbWlzZVxuXHQgKiAgd2hpY2ggZXhlY3V0ZXMgd2hlbiB0aGUgY29udGV4dCBpcyBjbG9zZWQgYW5kIGRpc3Bvc2VkXG5cdCAqICBAcmV0dXJucyB7UHJvbWlzZX0gdGhpc1xuXHQgKi9cblx0VG9uZS5Db250ZXh0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gdGhpcy5jbG9zZSgpLnRoZW4oZnVuY3Rpb24oKXtcblx0XHRcdFRvbmUuRW1pdHRlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHRcdFx0dGhpcy5fdGlja2VyLmRpc3Bvc2UoKTtcblx0XHRcdHRoaXMuX3RpY2tlciA9IG51bGw7XG5cdFx0XHR0aGlzLl90aW1lb3V0cy5kaXNwb3NlKCk7XG5cdFx0XHR0aGlzLl90aW1lb3V0cyA9IG51bGw7XG5cdFx0XHRmb3IgKHZhciBjb24gaW4gdGhpcy5fY29uc3RhbnRzKXtcblx0XHRcdFx0dGhpcy5fY29uc3RhbnRzW2Nvbl0uZGlzY29ubmVjdCgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY29uc3RhbnRzID0gbnVsbDtcblx0XHR9LmJpbmQodGhpcykpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAY2xhc3MgQSBjbGFzcyB3aGljaCBwcm92aWRlcyBhIHJlbGlhYmxlIGNhbGxiYWNrIHVzaW5nIGVpdGhlclxuXHQgKiAgICAgICAgYSBXZWIgV29ya2VyLCBvciBpZiB0aGF0IGlzbid0IHN1cHBvcnRlZCwgZmFsbHMgYmFjayB0byBzZXRUaW1lb3V0LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dmFyIFRpY2tlciA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0eXBlLCB1cGRhdGVJbnRlcnZhbCl7XG5cblx0XHQvKipcblx0XHQgKiBFaXRoZXIgXCJ3b3JrZXJcIiBvciBcInRpbWVvdXRcIlxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl90eXBlID0gdHlwZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB1cGRhdGUgaW50ZXJ2YWwgb2YgdGhlIHdvcmtlclxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLl91cGRhdGVJbnRlcnZhbCA9IHVwZGF0ZUludGVydmFsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGNhbGxiYWNrIHRvIGludm9rZSBhdCByZWd1bGFyIGludGVydmFsc1xuXHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2NhbGxiYWNrID0gVG9uZS5kZWZhdWx0QXJnKGNhbGxiYWNrLCBUb25lLm5vT3ApO1xuXG5cdFx0Ly9jcmVhdGUgdGhlIGNsb2NrIHNvdXJjZSBmb3IgdGhlIGZpcnN0IHRpbWVcblx0XHR0aGlzLl9jcmVhdGVDbG9jaygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgcG9zc2libGUgdGlja2VyIHR5cGVzXG5cdCAqIEBwcml2YXRlXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqL1xuXHRUaWNrZXIuVHlwZSA9IHtcblx0XHRXb3JrZXIgOiBcIndvcmtlclwiLFxuXHRcdFRpbWVvdXQgOiBcInRpbWVvdXRcIixcblx0XHRPZmZsaW5lIDogXCJvZmZsaW5lXCJcblx0fTtcblxuXHQvKipcblx0ICogIEdlbmVyYXRlIGEgd2ViIHdvcmtlclxuXHQgKiAgQHJldHVybiAge1dlYldvcmtlcn1cblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRUaWNrZXIucHJvdG90eXBlLl9jcmVhdGVXb3JrZXIgPSBmdW5jdGlvbigpe1xuXG5cdFx0Ly9VUkwgU2hpbVxuXHRcdHdpbmRvdy5VUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XG5cblx0XHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtcblx0XHRcdC8vdGhlIGluaXRpYWwgdGltZW91dCB0aW1lXG5cdFx0XHRcInZhciB0aW1lb3V0VGltZSA9IFwiKyh0aGlzLl91cGRhdGVJbnRlcnZhbCAqIDEwMDApLnRvRml4ZWQoMSkrXCI7XCIgK1xuXHRcdFx0Ly9vbm1lc3NhZ2UgY2FsbGJhY2tcblx0XHRcdFwic2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpe1wiICtcblx0XHRcdFwiXHR0aW1lb3V0VGltZSA9IHBhcnNlSW50KG1zZy5kYXRhKTtcIiArXG5cdFx0XHRcIn07XCIgK1xuXHRcdFx0Ly90aGUgdGljayBmdW5jdGlvbiB3aGljaCBwb3N0cyBhIG1lc3NhZ2Vcblx0XHRcdC8vYW5kIHNjaGVkdWxlcyBhIG5ldyB0aWNrXG5cdFx0XHRcImZ1bmN0aW9uIHRpY2soKXtcIiArXG5cdFx0XHRcIlx0c2V0VGltZW91dCh0aWNrLCB0aW1lb3V0VGltZSk7XCIgK1xuXHRcdFx0XCJcdHNlbGYucG9zdE1lc3NhZ2UoJ3RpY2snKTtcIiArXG5cdFx0XHRcIn1cIiArXG5cdFx0XHQvL2NhbGwgdGljayBpbml0aWFsbHlcblx0XHRcdFwidGljaygpO1wiXG5cdFx0XSk7XG5cdFx0dmFyIGJsb2JVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXHRcdHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKGJsb2JVcmwpO1xuXG5cdFx0d29ya2VyLm9ubWVzc2FnZSA9IHRoaXMuX2NhbGxiYWNrLmJpbmQodGhpcyk7XG5cblx0XHR0aGlzLl93b3JrZXIgPSB3b3JrZXI7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIHRpbWVvdXQgbG9vcFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0VGlja2VyLnByb3RvdHlwZS5fY3JlYXRlVGltZW91dCA9IGZ1bmN0aW9uKCl7XG5cdFx0dGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMuX2NyZWF0ZVRpbWVvdXQoKTtcblx0XHRcdHRoaXMuX2NhbGxiYWNrKCk7XG5cdFx0fS5iaW5kKHRoaXMpLCB0aGlzLl91cGRhdGVJbnRlcnZhbCAqIDEwMDApO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgdGhlIGNsb2NrIHNvdXJjZS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdFRpY2tlci5wcm90b3R5cGUuX2NyZWF0ZUNsb2NrID0gZnVuY3Rpb24oKXtcblx0XHRpZiAodGhpcy5fdHlwZSA9PT0gVGlja2VyLlR5cGUuV29ya2VyKXtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMuX2NyZWF0ZVdvcmtlcigpO1xuXHRcdFx0fSBjYXRjaCAoZSl7XG5cdFx0XHRcdC8vIHdvcmtlcnMgbm90IHN1cHBvcnRlZCwgZmFsbGJhY2sgdG8gdGltZW91dFxuXHRcdFx0XHR0aGlzLl90eXBlID0gVGlja2VyLlR5cGUuVGltZW91dDtcblx0XHRcdFx0dGhpcy5fY3JlYXRlQ2xvY2soKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHRoaXMuX3R5cGUgPT09IFRpY2tlci5UeXBlLlRpbWVvdXQpe1xuXHRcdFx0dGhpcy5fY3JlYXRlVGltZW91dCgpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1lbWJlck9mIFRpY2tlciNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQG5hbWUgdXBkYXRlSW50ZXJ2YWxcblx0ICogQHByaXZhdGVcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaWNrZXIucHJvdG90eXBlLCBcInVwZGF0ZUludGVydmFsXCIsIHtcblx0XHRnZXQgOiBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX3VwZGF0ZUludGVydmFsO1xuXHRcdH0sXG5cdFx0c2V0IDogZnVuY3Rpb24oaW50ZXJ2YWwpe1xuXHRcdFx0dGhpcy5fdXBkYXRlSW50ZXJ2YWwgPSBNYXRoLm1heChpbnRlcnZhbCwgMTI4LzQ0MTAwKTtcblx0XHRcdGlmICh0aGlzLl90eXBlID09PSBUaWNrZXIuVHlwZS5Xb3JrZXIpe1xuXHRcdFx0XHR0aGlzLl93b3JrZXIucG9zdE1lc3NhZ2UoTWF0aC5tYXgoaW50ZXJ2YWwgKiAxMDAwLCAxKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogVGhlIHR5cGUgb2YgdGhlIHRpY2tlciwgZWl0aGVyIGEgd29ya2VyIG9yIGEgdGltZW91dFxuXHQgKiBAbWVtYmVyT2YgVGlja2VyI1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAbmFtZSB0eXBlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVGlja2VyLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHtcblx0XHRnZXQgOiBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX3R5cGU7XG5cdFx0fSxcblx0XHRzZXQgOiBmdW5jdGlvbih0eXBlKXtcblx0XHRcdHRoaXMuX2Rpc3Bvc2VDbG9jaygpO1xuXHRcdFx0dGhpcy5fdHlwZSA9IHR5cGU7XG5cdFx0XHR0aGlzLl9jcmVhdGVDbG9jaygpO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIENsZWFuIHVwIHRoZSBjdXJyZW50IGNsb2NrIHNvdXJjZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0VGlja2VyLnByb3RvdHlwZS5fZGlzcG9zZUNsb2NrID0gZnVuY3Rpb24oKXtcblx0XHRpZiAodGhpcy5fdGltZW91dCl7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG5cdFx0XHR0aGlzLl90aW1lb3V0ID0gbnVsbDtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX3dvcmtlcil7XG5cdFx0XHR0aGlzLl93b3JrZXIudGVybWluYXRlKCk7XG5cdFx0XHR0aGlzLl93b3JrZXIub25tZXNzYWdlID0gbnVsbDtcblx0XHRcdHRoaXMuX3dvcmtlciA9IG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiB1cFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0VGlja2VyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKXtcblx0XHR0aGlzLl9kaXNwb3NlQ2xvY2soKTtcblx0XHR0aGlzLl9jYWxsYmFjayA9IG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqICBTaGltIGFsbCBjb25uZWN0L2Rpc2Nvbm5lY3QgYW5kIHNvbWUgZGVwcmVjYXRlZCBtZXRob2RzIHdoaWNoIGFyZSBzdGlsbCBpblxuXHQgKiAgc29tZSBvbGRlciBpbXBsZW1lbnRhdGlvbnMuXG5cdCAqICBAcHJpdmF0ZVxuXHQgKi9cblx0VG9uZS5nZXRDb250ZXh0KGZ1bmN0aW9uKCl7XG5cblx0XHR2YXIgbmF0aXZlQ29ubmVjdCA9IEF1ZGlvTm9kZS5wcm90b3R5cGUuY29ubmVjdDtcblx0XHR2YXIgbmF0aXZlRGlzY29ubmVjdCA9IEF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzY29ubmVjdDtcblxuXHRcdC8vcmVwbGFjZSB0aGUgb2xkIGNvbm5lY3QgbWV0aG9kXG5cdFx0ZnVuY3Rpb24gdG9uZUNvbm5lY3QoQiwgb3V0TnVtLCBpbk51bSl7XG5cdFx0XHRpZiAoQi5pbnB1dCl7XG5cdFx0XHRcdGluTnVtID0gVG9uZS5kZWZhdWx0QXJnKGluTnVtLCAwKTtcblx0XHRcdFx0aWYgKFRvbmUuaXNBcnJheShCLmlucHV0KSl7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuY29ubmVjdChCLmlucHV0W2luTnVtXSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuY29ubmVjdChCLmlucHV0LCBvdXROdW0sIGluTnVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpZiAoQiBpbnN0YW5jZW9mIEF1ZGlvTm9kZSl7XG5cdFx0XHRcdFx0XHRuYXRpdmVDb25uZWN0LmNhbGwodGhpcywgQiwgb3V0TnVtLCBpbk51bSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gQjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bmF0aXZlQ29ubmVjdC5jYWxsKHRoaXMsIEIsIG91dE51bSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gQjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKGUpe1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImVycm9yIGNvbm5lY3RpbmcgdG8gbm9kZTogXCIrQitcIlxcblwiK2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9yZXBsYWNlIHRoZSBvbGQgZGlzY29ubmVjdCBtZXRob2Rcblx0XHRmdW5jdGlvbiB0b25lRGlzY29ubmVjdChCLCBvdXROdW0sIGluTnVtKXtcblx0XHRcdGlmIChCICYmIEIuaW5wdXQgJiYgVG9uZS5pc0FycmF5KEIuaW5wdXQpKXtcblx0XHRcdFx0aW5OdW0gPSBUb25lLmRlZmF1bHRBcmcoaW5OdW0sIDApO1xuXHRcdFx0XHR0aGlzLmRpc2Nvbm5lY3QoQi5pbnB1dFtpbk51bV0sIG91dE51bSwgMCk7XG5cdFx0XHR9IGVsc2UgaWYgKEIgJiYgQi5pbnB1dCl7XG5cdFx0XHRcdHRoaXMuZGlzY29ubmVjdChCLmlucHV0LCBvdXROdW0sIGluTnVtKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0bmF0aXZlRGlzY29ubmVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9IGNhdGNoIChlKXtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJlcnJvciBkaXNjb25uZWN0aW5nIG5vZGU6IFwiK0IrXCJcXG5cIitlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChBdWRpb05vZGUucHJvdG90eXBlLmNvbm5lY3QgIT09IHRvbmVDb25uZWN0KXtcblx0XHRcdEF1ZGlvTm9kZS5wcm90b3R5cGUuY29ubmVjdCA9IHRvbmVDb25uZWN0O1xuXHRcdFx0QXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gdG9uZURpc2Nvbm5lY3Q7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBzZXQgdGhlIGF1ZGlvIGNvbnRleHQgaW5pdGlhbGx5LCBhbmQgaWYgb25lIGlzIG5vdCBhbHJlYWR5IGNyZWF0ZWRcblx0aWYgKFRvbmUuc3VwcG9ydGVkICYmICFUb25lLmluaXRpYWxpemVkKXtcblx0XHRUb25lLmNvbnRleHQgPSBuZXcgVG9uZS5Db250ZXh0KCk7XG5cblx0XHQvLyBsb2cgb24gZmlyc3QgaW5pdGlhbGl6YXRpb25cblx0XHQvLyBhbGxvdyBvcHRpb25hbCBzaWxlbmNpbmcgb2YgdGhpcyBsb2dcblx0XHRpZiAoIXdpbmRvdy5UT05FX1NJTEVOQ0VfVkVSU0lPTl9MT0dHSU5HKXtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdFx0XHRjb25zb2xlLmxvZyhcIiVjICogVG9uZS5qcyBcIiArIFRvbmUudmVyc2lvbiArIFwiICogXCIsIFwiYmFja2dyb3VuZDogIzAwMDsgY29sb3I6ICNmZmZcIik7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCFUb25lLnN1cHBvcnRlZCl7XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0XHRjb25zb2xlLndhcm4oXCJUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBUb25lLmpzXCIpO1xuXHR9XG5cblx0cmV0dXJuIFRvbmUuQ29udGV4dDtcbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUVBOzs7OztBQUtBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUFBO0FBT0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFSQTtBQVlBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUlBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUpBO0FBU0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBSkE7QUFTQTs7Ozs7Ozs7Ozs7Ozs7OztBQWVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBa0JBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQTFCQTtBQUFBO0FBSkE7QUFnQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUVBOzs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7Ozs7OztBQUtBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUlBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUFBO0FBSkE7QUFZQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBTEE7QUFBQTtBQUpBO0FBV0E7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/core/Context.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/core/Emitter.js":
/*!************************************************!*\
  !*** ./node_modules/tone/Tone/core/Emitter.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  \"use strict\";\n  /**\n   *  @class Tone.Emitter gives classes which extend it\n   *         the ability to listen for and emit events.\n   *         Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n   *         MIT (c) 2011 Jerome Etienne.\n   *\n   *  @extends {Tone}\n   */\n\n  Tone.Emitter = function () {\n    Tone.call(this);\n    /**\n     *  Contains all of the events.\n     *  @private\n     *  @type  {Object}\n     */\n\n    this._events = {};\n  };\n\n  Tone.extend(Tone.Emitter);\n  /**\n   *  Bind a callback to a specific event.\n   *  @param  {String}    event     The name of the event to listen for.\n   *  @param  {Function}  callback  The callback to invoke when the\n   *                                event is emitted\n   *  @return  {Tone.Emitter}    this\n   */\n\n  Tone.Emitter.prototype.on = function (event, callback) {\n    //split the event\n    var events = event.split(/\\W+/);\n\n    for (var i = 0; i < events.length; i++) {\n      var eventName = events[i];\n\n      if (!this._events.hasOwnProperty(eventName)) {\n        this._events[eventName] = [];\n      }\n\n      this._events[eventName].push(callback);\n    }\n\n    return this;\n  };\n  /**\n   *  Bind a callback which is only invoked once\n   *  @param  {String}    event     The name of the event to listen for.\n   *  @param  {Function}  callback  The callback to invoke when the\n   *                                event is emitted\n   *  @return  {Tone.Emitter}    this\n   */\n\n\n  Tone.Emitter.prototype.once = function (event, callback) {\n    var boundCallback = function () {\n      //invoke the callback\n      callback.apply(this, arguments);\n      this.off(event, boundCallback);\n    }.bind(this);\n\n    this.on(event, boundCallback);\n    return this;\n  };\n  /**\n   *  Remove the event listener.\n   *  @param  {String}    event     The event to stop listening to.\n   *  @param  {Function=}  callback  The callback which was bound to\n   *                                the event with Tone.Emitter.on.\n   *                                If no callback is given, all callbacks\n   *                                events are removed.\n   *  @return  {Tone.Emitter}    this\n   */\n\n\n  Tone.Emitter.prototype.off = function (event, callback) {\n    var events = event.split(/\\W+/);\n\n    for (var ev = 0; ev < events.length; ev++) {\n      event = events[ev];\n\n      if (this._events.hasOwnProperty(event)) {\n        if (Tone.isUndef(callback)) {\n          this._events[event] = [];\n        } else {\n          var eventList = this._events[event];\n\n          for (var i = 0; i < eventList.length; i++) {\n            if (eventList[i] === callback) {\n              eventList.splice(i, 1);\n            }\n          }\n        }\n      }\n    }\n\n    return this;\n  };\n  /**\n   *  Invoke all of the callbacks bound to the event\n   *  with any arguments passed in.\n   *  @param  {String}  event  The name of the event.\n   *  @param {*} args... The arguments to pass to the functions listening.\n   *  @return  {Tone.Emitter}  this\n   */\n\n\n  Tone.Emitter.prototype.emit = function (event) {\n    if (this._events) {\n      var args = Array.apply(null, arguments).slice(1);\n\n      if (this._events.hasOwnProperty(event)) {\n        var eventList = this._events[event].slice(0);\n\n        for (var i = 0, len = eventList.length; i < len; i++) {\n          eventList[i].apply(this, args);\n        }\n      }\n    }\n\n    return this;\n  };\n  /**\n   *  Add Emitter functions (on/off/emit) to the object\n   *  @param  {Object|Function}  object  The object or class to extend.\n   *  @returns {Tone.Emitter}\n   */\n\n\n  Tone.Emitter.mixin = function (object) {\n    var functions = [\"on\", \"once\", \"off\", \"emit\"];\n    object._events = {};\n\n    for (var i = 0; i < functions.length; i++) {\n      var func = functions[i];\n      var emitterFunc = Tone.Emitter.prototype[func];\n      object[func] = emitterFunc;\n    }\n\n    return Tone.Emitter;\n  };\n  /**\n   *  Clean up\n   *  @return  {Tone.Emitter}  this\n   */\n\n\n  Tone.Emitter.prototype.dispose = function () {\n    Tone.prototype.dispose.call(this);\n    this._events = null;\n    return this;\n  };\n\n  return Tone.Emitter;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvRW1pdHRlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90b25lL1RvbmUvY29yZS9FbWl0dGVyLmpzP2QyNDQiXSwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFtcIlRvbmUvY29yZS9Ub25lXCJdLCBmdW5jdGlvbihUb25lKXtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogIEBjbGFzcyBUb25lLkVtaXR0ZXIgZ2l2ZXMgY2xhc3NlcyB3aGljaCBleHRlbmQgaXRcblx0ICogICAgICAgICB0aGUgYWJpbGl0eSB0byBsaXN0ZW4gZm9yIGFuZCBlbWl0IGV2ZW50cy5cblx0ICogICAgICAgICBJbnNwaXJhdGlvbiBhbmQgcmVmZXJlbmNlIGZyb20gSmVyb21lIEV0aWVubmUncyBbTWljcm9FdmVudF0oaHR0cHM6Ly9naXRodWIuY29tL2plcm9tZWV0aWVubmUvbWljcm9ldmVudC5qcykuXG5cdCAqICAgICAgICAgTUlUIChjKSAyMDExIEplcm9tZSBFdGllbm5lLlxuXHQgKlxuXHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdCAqL1xuXHRUb25lLkVtaXR0ZXIgPSBmdW5jdGlvbigpe1xuXHRcdFRvbmUuY2FsbCh0aGlzKTtcblx0XHQvKipcblx0XHQgKiAgQ29udGFpbnMgYWxsIG9mIHRoZSBldmVudHMuXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMuX2V2ZW50cyA9IHt9O1xuXHR9O1xuXG5cdFRvbmUuZXh0ZW5kKFRvbmUuRW1pdHRlcik7XG5cblx0LyoqXG5cdCAqICBCaW5kIGEgY2FsbGJhY2sgdG8gYSBzcGVjaWZpYyBldmVudC5cblx0ICogIEBwYXJhbSAge1N0cmluZ30gICAgZXZlbnQgICAgIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gZm9yLlxuXHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFjayAgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIHRoZVxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQgaXMgZW1pdHRlZFxuXHQgKiAgQHJldHVybiAge1RvbmUuRW1pdHRlcn0gICAgdGhpc1xuXHQgKi9cblx0VG9uZS5FbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFjayl7XG5cdFx0Ly9zcGxpdCB0aGUgZXZlbnRcblx0XHR2YXIgZXZlbnRzID0gZXZlbnQuc3BsaXQoL1xcVysvKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKyl7XG5cdFx0XHR2YXIgZXZlbnROYW1lID0gZXZlbnRzW2ldO1xuXHRcdFx0aWYgKCF0aGlzLl9ldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSl7XG5cdFx0XHRcdHRoaXMuX2V2ZW50c1tldmVudE5hbWVdID0gW107XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9ldmVudHNbZXZlbnROYW1lXS5wdXNoKGNhbGxiYWNrKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqICBCaW5kIGEgY2FsbGJhY2sgd2hpY2ggaXMgb25seSBpbnZva2VkIG9uY2Vcblx0ICogIEBwYXJhbSAge1N0cmluZ30gICAgZXZlbnQgICAgIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gZm9yLlxuXHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFjayAgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIHRoZVxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQgaXMgZW1pdHRlZFxuXHQgKiAgQHJldHVybiAge1RvbmUuRW1pdHRlcn0gICAgdGhpc1xuXHQgKi9cblx0VG9uZS5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKXtcblx0XHR2YXIgYm91bmRDYWxsYmFjayA9IGZ1bmN0aW9uKCl7XG5cdFx0XHQvL2ludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRcdGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLm9mZihldmVudCwgYm91bmRDYWxsYmFjayk7XG5cdFx0fS5iaW5kKHRoaXMpO1xuXHRcdHRoaXMub24oZXZlbnQsIGJvdW5kQ2FsbGJhY2spO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgUmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lci5cblx0ICogIEBwYXJhbSAge1N0cmluZ30gICAgZXZlbnQgICAgIFRoZSBldmVudCB0byBzdG9wIGxpc3RlbmluZyB0by5cblx0ICogIEBwYXJhbSAge0Z1bmN0aW9uPX0gIGNhbGxiYWNrICBUaGUgY2FsbGJhY2sgd2hpY2ggd2FzIGJvdW5kIHRvXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgZXZlbnQgd2l0aCBUb25lLkVtaXR0ZXIub24uXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBubyBjYWxsYmFjayBpcyBnaXZlbiwgYWxsIGNhbGxiYWNrc1xuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzIGFyZSByZW1vdmVkLlxuXHQgKiAgQHJldHVybiAge1RvbmUuRW1pdHRlcn0gICAgdGhpc1xuXHQgKi9cblx0VG9uZS5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spe1xuXHRcdHZhciBldmVudHMgPSBldmVudC5zcGxpdCgvXFxXKy8pO1xuXHRcdGZvciAodmFyIGV2ID0gMDsgZXYgPCBldmVudHMubGVuZ3RoOyBldisrKXtcblx0XHRcdGV2ZW50ID0gZXZlbnRzW2V2XTtcblx0XHRcdGlmICh0aGlzLl9ldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKXtcblx0XHRcdFx0aWYgKFRvbmUuaXNVbmRlZihjYWxsYmFjaykpe1xuXHRcdFx0XHRcdHRoaXMuX2V2ZW50c1tldmVudF0gPSBbXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgZXZlbnRMaXN0ID0gdGhpcy5fZXZlbnRzW2V2ZW50XTtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50TGlzdC5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdFx0XHRpZiAoZXZlbnRMaXN0W2ldID09PSBjYWxsYmFjayl7XG5cdFx0XHRcdFx0XHRcdGV2ZW50TGlzdC5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgSW52b2tlIGFsbCBvZiB0aGUgY2FsbGJhY2tzIGJvdW5kIHRvIHRoZSBldmVudFxuXHQgKiAgd2l0aCBhbnkgYXJndW1lbnRzIHBhc3NlZCBpbi5cblx0ICogIEBwYXJhbSAge1N0cmluZ30gIGV2ZW50ICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXG5cdCAqICBAcGFyYW0geyp9IGFyZ3MuLi4gVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbnMgbGlzdGVuaW5nLlxuXHQgKiAgQHJldHVybiAge1RvbmUuRW1pdHRlcn0gIHRoaXNcblx0ICovXG5cdFRvbmUuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcblx0XHRpZiAodGhpcy5fZXZlbnRzKXtcblx0XHRcdHZhciBhcmdzID0gQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5zbGljZSgxKTtcblx0XHRcdGlmICh0aGlzLl9ldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKXtcblx0XHRcdFx0dmFyIGV2ZW50TGlzdCA9IHRoaXMuX2V2ZW50c1tldmVudF0uc2xpY2UoMCk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBldmVudExpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuXHRcdFx0XHRcdGV2ZW50TGlzdFtpXS5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogIEFkZCBFbWl0dGVyIGZ1bmN0aW9ucyAob24vb2ZmL2VtaXQpIHRvIHRoZSBvYmplY3Rcblx0ICogIEBwYXJhbSAge09iamVjdHxGdW5jdGlvbn0gIG9iamVjdCAgVGhlIG9iamVjdCBvciBjbGFzcyB0byBleHRlbmQuXG5cdCAqICBAcmV0dXJucyB7VG9uZS5FbWl0dGVyfVxuXHQgKi9cblx0VG9uZS5FbWl0dGVyLm1peGluID0gZnVuY3Rpb24ob2JqZWN0KXtcblx0XHR2YXIgZnVuY3Rpb25zID0gW1wib25cIiwgXCJvbmNlXCIsIFwib2ZmXCIsIFwiZW1pdFwiXTtcblx0XHRvYmplY3QuX2V2ZW50cyA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKXtcblx0XHRcdHZhciBmdW5jID0gZnVuY3Rpb25zW2ldO1xuXHRcdFx0dmFyIGVtaXR0ZXJGdW5jID0gVG9uZS5FbWl0dGVyLnByb3RvdHlwZVtmdW5jXTtcblx0XHRcdG9iamVjdFtmdW5jXSA9IGVtaXR0ZXJGdW5jO1xuXHRcdH1cblx0XHRyZXR1cm4gVG9uZS5FbWl0dGVyO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgQ2xlYW4gdXBcblx0ICogIEByZXR1cm4gIHtUb25lLkVtaXR0ZXJ9ICB0aGlzXG5cdCAqL1xuXHRUb25lLkVtaXR0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpe1xuXHRcdFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0XHR0aGlzLl9ldmVudHMgPSBudWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdHJldHVybiBUb25lLkVtaXR0ZXI7XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTtBQUVBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/core/Emitter.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/core/Gain.js":
/*!*********************************************!*\
  !*** ./node_modules/tone/Tone/core/Gain.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/core/Param */ \"./node_modules/tone/Tone/core/Param.js\"), __webpack_require__(/*! Tone/type/Type */ \"./node_modules/tone/Tone/type/Type.js\"), __webpack_require__(/*! Tone/core/AudioNode */ \"./node_modules/tone/Tone/core/AudioNode.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  \"use strict\";\n  /**\n   *  @class A thin wrapper around the Native Web Audio GainNode.\n   *         The GainNode is a basic building block of the Web Audio\n   *         API and is useful for routing audio and adjusting gains.\n   *  @extends {Tone}\n   *  @param  {Number=}  gain  The initial gain of the GainNode\n   *  @param {Tone.Type=} units The units of the gain parameter.\n   */\n\n  Tone.Gain = function () {\n    var options = Tone.defaults(arguments, [\"gain\", \"units\"], Tone.Gain);\n    Tone.AudioNode.call(this);\n    /**\n     *  The GainNode\n     *  @type  {GainNode}\n     *  @private\n     */\n\n    this.input = this.output = this._gainNode = this.context.createGain();\n    /**\n     *  The gain parameter of the gain node.\n     *  @type {Gain}\n     *  @signal\n     */\n\n    this.gain = new Tone.Param({\n      \"param\": this._gainNode.gain,\n      \"units\": options.units,\n      \"value\": options.gain,\n      \"convert\": options.convert\n    });\n\n    this._readOnly(\"gain\");\n  };\n\n  Tone.extend(Tone.Gain, Tone.AudioNode);\n  /**\n   *  The defaults\n   *  @const\n   *  @type  {Object}\n   */\n\n  Tone.Gain.defaults = {\n    \"gain\": 1,\n    \"convert\": true\n  };\n  /**\n   *  Clean up.\n   *  @return  {Tone.Gain}  this\n   */\n\n  Tone.Gain.prototype.dispose = function () {\n    Tone.AudioNode.prototype.dispose.call(this);\n\n    this._gainNode.disconnect();\n\n    this._gainNode = null;\n\n    this._writable(\"gain\");\n\n    this.gain.dispose();\n    this.gain = null;\n  };\n\n  return Tone.Gain;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvR2Fpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90b25lL1RvbmUvY29yZS9HYWluLmpzPzFkZDkiXSwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFtcIlRvbmUvY29yZS9Ub25lXCIsIFwiVG9uZS9jb3JlL1BhcmFtXCIsIFwiVG9uZS90eXBlL1R5cGVcIiwgXCJUb25lL2NvcmUvQXVkaW9Ob2RlXCJdLCBmdW5jdGlvbihUb25lKXtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogIEBjbGFzcyBBIHRoaW4gd3JhcHBlciBhcm91bmQgdGhlIE5hdGl2ZSBXZWIgQXVkaW8gR2Fpbk5vZGUuXG5cdCAqICAgICAgICAgVGhlIEdhaW5Ob2RlIGlzIGEgYmFzaWMgYnVpbGRpbmcgYmxvY2sgb2YgdGhlIFdlYiBBdWRpb1xuXHQgKiAgICAgICAgIEFQSSBhbmQgaXMgdXNlZnVsIGZvciByb3V0aW5nIGF1ZGlvIGFuZCBhZGp1c3RpbmcgZ2FpbnMuXG5cdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0ICogIEBwYXJhbSAge051bWJlcj19ICBnYWluICBUaGUgaW5pdGlhbCBnYWluIG9mIHRoZSBHYWluTm9kZVxuXHQgKiAgQHBhcmFtIHtUb25lLlR5cGU9fSB1bml0cyBUaGUgdW5pdHMgb2YgdGhlIGdhaW4gcGFyYW1ldGVyLlxuXHQgKi9cblx0VG9uZS5HYWluID0gZnVuY3Rpb24oKXtcblxuXHRcdHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcImdhaW5cIiwgXCJ1bml0c1wiXSwgVG9uZS5HYWluKTtcblx0XHRUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXG5cdFx0LyoqXG5cdFx0ICogIFRoZSBHYWluTm9kZVxuXHRcdCAqICBAdHlwZSAge0dhaW5Ob2RlfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IHRoaXMuX2dhaW5Ob2RlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblxuXHRcdC8qKlxuXHRcdCAqICBUaGUgZ2FpbiBwYXJhbWV0ZXIgb2YgdGhlIGdhaW4gbm9kZS5cblx0XHQgKiAgQHR5cGUge0dhaW59XG5cdFx0ICogIEBzaWduYWxcblx0XHQgKi9cblx0XHR0aGlzLmdhaW4gPSBuZXcgVG9uZS5QYXJhbSh7XG5cdFx0XHRcInBhcmFtXCIgOiB0aGlzLl9nYWluTm9kZS5nYWluLFxuXHRcdFx0XCJ1bml0c1wiIDogb3B0aW9ucy51bml0cyxcblx0XHRcdFwidmFsdWVcIiA6IG9wdGlvbnMuZ2Fpbixcblx0XHRcdFwiY29udmVydFwiIDogb3B0aW9ucy5jb252ZXJ0XG5cdFx0fSk7XG5cdFx0dGhpcy5fcmVhZE9ubHkoXCJnYWluXCIpO1xuXHR9O1xuXG5cdFRvbmUuZXh0ZW5kKFRvbmUuR2FpbiwgVG9uZS5BdWRpb05vZGUpO1xuXG5cdC8qKlxuXHQgKiAgVGhlIGRlZmF1bHRzXG5cdCAqICBAY29uc3Rcblx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHQgKi9cblx0VG9uZS5HYWluLmRlZmF1bHRzID0ge1xuXHRcdFwiZ2FpblwiIDogMSxcblx0XHRcImNvbnZlcnRcIiA6IHRydWUsXG5cdH07XG5cblx0LyoqXG5cdCAqICBDbGVhbiB1cC5cblx0ICogIEByZXR1cm4gIHtUb25lLkdhaW59ICB0aGlzXG5cdCAqL1xuXHRUb25lLkdhaW4ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpe1xuXHRcdFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5fZ2Fpbk5vZGUuZGlzY29ubmVjdCgpO1xuXHRcdHRoaXMuX2dhaW5Ob2RlID0gbnVsbDtcblx0XHR0aGlzLl93cml0YWJsZShcImdhaW5cIik7XG5cdFx0dGhpcy5nYWluLmRpc3Bvc2UoKTtcblx0XHR0aGlzLmdhaW4gPSBudWxsO1xuXHR9O1xuXG5cdHJldHVybiBUb25lLkdhaW47XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTtBQUVBOzs7Ozs7Ozs7QUFRQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFGQTtBQUtBOzs7OztBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/core/Gain.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/core/IntervalTimeline.js":
/*!*********************************************************!*\
  !*** ./node_modules/tone/Tone/core/IntervalTimeline.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/type/Type */ \"./node_modules/tone/Tone/type/Type.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  \"use strict\";\n  /**\n   *  @class Similar to Tone.Timeline, but all events represent\n   *         intervals with both \"time\" and \"duration\" times. The\n   *         events are placed in a tree structure optimized\n   *         for querying an intersection point with the timeline\n   *         events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n   *         to represent the data.\n   *  @extends {Tone}\n   */\n\n  Tone.IntervalTimeline = function () {\n    Tone.call(this);\n    /**\n     *  The root node of the inteval tree\n     *  @type  {IntervalNode}\n     *  @private\n     */\n\n    this._root = null;\n    /**\n     *  Keep track of the length of the timeline.\n     *  @type  {Number}\n     *  @private\n     */\n\n    this._length = 0;\n  };\n\n  Tone.extend(Tone.IntervalTimeline);\n  /**\n   *  The event to add to the timeline. All events must\n   *  have a time and duration value\n   *  @param  {Object}  event  The event to add to the timeline\n   *  @return  {Tone.IntervalTimeline}  this\n   */\n\n  Tone.IntervalTimeline.prototype.add = function (event) {\n    if (Tone.isUndef(event.time) || Tone.isUndef(event.duration)) {\n      throw new Error(\"Tone.IntervalTimeline: events must have time and duration parameters\");\n    }\n\n    event.time = event.time.valueOf();\n    var node = new IntervalNode(event.time, event.time + event.duration, event);\n\n    if (this._root === null) {\n      this._root = node;\n    } else {\n      this._root.insert(node);\n    }\n\n    this._length++; // Restructure tree to be balanced\n\n    while (node !== null) {\n      node.updateHeight();\n      node.updateMax();\n\n      this._rebalance(node);\n\n      node = node.parent;\n    }\n\n    return this;\n  };\n  /**\n   *  Remove an event from the timeline.\n   *  @param  {Object}  event  The event to remove from the timeline\n   *  @return  {Tone.IntervalTimeline}  this\n   */\n\n\n  Tone.IntervalTimeline.prototype.remove = function (event) {\n    if (this._root !== null) {\n      var results = [];\n\n      this._root.search(event.time, results);\n\n      for (var i = 0; i < results.length; i++) {\n        var node = results[i];\n\n        if (node.event === event) {\n          this._removeNode(node);\n\n          this._length--;\n          break;\n        }\n      }\n    }\n\n    return this;\n  };\n  /**\n   *  The number of items in the timeline.\n   *  @type {Number}\n   *  @memberOf Tone.IntervalTimeline#\n   *  @name length\n   *  @readOnly\n   */\n\n\n  Object.defineProperty(Tone.IntervalTimeline.prototype, \"length\", {\n    get: function () {\n      function get() {\n        return this._length;\n      }\n\n      return get;\n    }()\n  });\n  /**\n   *  Remove events whose time time is after the given time\n   *  @param  {Number}  time  The time to query.\n   *  @returns {Tone.IntervalTimeline} this\n   */\n\n  Tone.IntervalTimeline.prototype.cancel = function (after) {\n    this.forEachFrom(after, function (event) {\n      this.remove(event);\n    }.bind(this));\n    return this;\n  };\n  /**\n   *  Set the root node as the given node\n   *  @param {IntervalNode} node\n   *  @private\n   */\n\n\n  Tone.IntervalTimeline.prototype._setRoot = function (node) {\n    this._root = node;\n\n    if (this._root !== null) {\n      this._root.parent = null;\n    }\n  };\n  /**\n   *  Replace the references to the node in the node's parent\n   *  with the replacement node.\n   *  @param  {IntervalNode}  node\n   *  @param  {IntervalNode}  replacement\n   *  @private\n   */\n\n\n  Tone.IntervalTimeline.prototype._replaceNodeInParent = function (node, replacement) {\n    if (node.parent !== null) {\n      if (node.isLeftChild()) {\n        node.parent.left = replacement;\n      } else {\n        node.parent.right = replacement;\n      }\n\n      this._rebalance(node.parent);\n    } else {\n      this._setRoot(replacement);\n    }\n  };\n  /**\n   *  Remove the node from the tree and replace it with\n   *  a successor which follows the schema.\n   *  @param  {IntervalNode}  node\n   *  @private\n   */\n\n\n  Tone.IntervalTimeline.prototype._removeNode = function (node) {\n    if (node.left === null && node.right === null) {\n      this._replaceNodeInParent(node, null);\n    } else if (node.right === null) {\n      this._replaceNodeInParent(node, node.left);\n    } else if (node.left === null) {\n      this._replaceNodeInParent(node, node.right);\n    } else {\n      var balance = node.getBalance();\n      var replacement, temp;\n\n      if (balance > 0) {\n        if (node.left.right === null) {\n          replacement = node.left;\n          replacement.right = node.right;\n          temp = replacement;\n        } else {\n          replacement = node.left.right;\n\n          while (replacement.right !== null) {\n            replacement = replacement.right;\n          }\n\n          replacement.parent.right = replacement.left;\n          temp = replacement.parent;\n          replacement.left = node.left;\n          replacement.right = node.right;\n        }\n      } else if (node.right.left === null) {\n        replacement = node.right;\n        replacement.left = node.left;\n        temp = replacement;\n      } else {\n        replacement = node.right.left;\n\n        while (replacement.left !== null) {\n          replacement = replacement.left;\n        }\n\n        replacement.parent = replacement.parent;\n        replacement.parent.left = replacement.right;\n        temp = replacement.parent;\n        replacement.left = node.left;\n        replacement.right = node.right;\n      }\n\n      if (node.parent !== null) {\n        if (node.isLeftChild()) {\n          node.parent.left = replacement;\n        } else {\n          node.parent.right = replacement;\n        }\n      } else {\n        this._setRoot(replacement);\n      } // this._replaceNodeInParent(node, replacement);\n\n\n      this._rebalance(temp);\n    }\n\n    node.dispose();\n  };\n  /**\n   *  Rotate the tree to the left\n   *  @param  {IntervalNode}  node\n   *  @private\n   */\n\n\n  Tone.IntervalTimeline.prototype._rotateLeft = function (node) {\n    var parent = node.parent;\n    var isLeftChild = node.isLeftChild(); // Make node.right the new root of this sub tree (instead of node)\n\n    var pivotNode = node.right;\n    node.right = pivotNode.left;\n    pivotNode.left = node;\n\n    if (parent !== null) {\n      if (isLeftChild) {\n        parent.left = pivotNode;\n      } else {\n        parent.right = pivotNode;\n      }\n    } else {\n      this._setRoot(pivotNode);\n    }\n  };\n  /**\n   *  Rotate the tree to the right\n   *  @param  {IntervalNode}  node\n   *  @private\n   */\n\n\n  Tone.IntervalTimeline.prototype._rotateRight = function (node) {\n    var parent = node.parent;\n    var isLeftChild = node.isLeftChild(); // Make node.left the new root of this sub tree (instead of node)\n\n    var pivotNode = node.left;\n    node.left = pivotNode.right;\n    pivotNode.right = node;\n\n    if (parent !== null) {\n      if (isLeftChild) {\n        parent.left = pivotNode;\n      } else {\n        parent.right = pivotNode;\n      }\n    } else {\n      this._setRoot(pivotNode);\n    }\n  };\n  /**\n   *  Balance the BST\n   *  @param  {IntervalNode}  node\n   *  @private\n   */\n\n\n  Tone.IntervalTimeline.prototype._rebalance = function (node) {\n    var balance = node.getBalance();\n\n    if (balance > 1) {\n      if (node.left.getBalance() < 0) {\n        this._rotateLeft(node.left);\n      } else {\n        this._rotateRight(node);\n      }\n    } else if (balance < -1) {\n      if (node.right.getBalance() > 0) {\n        this._rotateRight(node.right);\n      } else {\n        this._rotateLeft(node);\n      }\n    }\n  };\n  /**\n   *  Get an event whose time and duration span the give time. Will\n   *  return the match whose \"time\" value is closest to the given time.\n   *  @param  {Object}  event  The event to add to the timeline\n   *  @return  {Object}  The event which spans the desired time\n   */\n\n\n  Tone.IntervalTimeline.prototype.get = function (time) {\n    if (this._root !== null) {\n      var results = [];\n\n      this._root.search(time, results);\n\n      if (results.length > 0) {\n        var max = results[0];\n\n        for (var i = 1; i < results.length; i++) {\n          if (results[i].low > max.low) {\n            max = results[i];\n          }\n        }\n\n        return max.event;\n      }\n    }\n\n    return null;\n  };\n  /**\n   *  Iterate over everything in the timeline.\n   *  @param  {Function}  callback The callback to invoke with every item\n   *  @returns {Tone.IntervalTimeline} this\n   */\n\n\n  Tone.IntervalTimeline.prototype.forEach = function (callback) {\n    if (this._root !== null) {\n      var allNodes = [];\n\n      this._root.traverse(function (node) {\n        allNodes.push(node);\n      });\n\n      for (var i = 0; i < allNodes.length; i++) {\n        var ev = allNodes[i].event;\n\n        if (ev) {\n          callback(ev);\n        }\n      }\n    }\n\n    return this;\n  };\n  /**\n   *  Iterate over everything in the array in which the given time\n   *  overlaps with the time and duration time of the event.\n   *  @param  {Number}  time The time to check if items are overlapping\n   *  @param  {Function}  callback The callback to invoke with every item\n   *  @returns {Tone.IntervalTimeline} this\n   */\n\n\n  Tone.IntervalTimeline.prototype.forEachAtTime = function (time, callback) {\n    if (this._root !== null) {\n      var results = [];\n\n      this._root.search(time, results);\n\n      for (var i = results.length - 1; i >= 0; i--) {\n        var ev = results[i].event;\n\n        if (ev) {\n          callback(ev);\n        }\n      }\n    }\n\n    return this;\n  };\n  /**\n   *  Iterate over everything in the array in which the time is greater\n   *  than or equal to the given time.\n   *  @param  {Number}  time The time to check if items are before\n   *  @param  {Function}  callback The callback to invoke with every item\n   *  @returns {Tone.IntervalTimeline} this\n   */\n\n\n  Tone.IntervalTimeline.prototype.forEachFrom = function (time, callback) {\n    if (this._root !== null) {\n      var results = [];\n\n      this._root.searchAfter(time, results);\n\n      for (var i = results.length - 1; i >= 0; i--) {\n        var ev = results[i].event;\n        callback(ev);\n      }\n    }\n\n    return this;\n  };\n  /**\n   *  Clean up\n   *  @return  {Tone.IntervalTimeline}  this\n   */\n\n\n  Tone.IntervalTimeline.prototype.dispose = function () {\n    var allNodes = [];\n\n    if (this._root !== null) {\n      this._root.traverse(function (node) {\n        allNodes.push(node);\n      });\n    }\n\n    for (var i = 0; i < allNodes.length; i++) {\n      allNodes[i].dispose();\n    }\n\n    allNodes = null;\n    this._root = null;\n    return this;\n  }; ///////////////////////////////////////////////////////////////////////////\n  //\tINTERVAL NODE HELPER\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  Represents a node in the binary search tree, with the addition\n   *  of a \"high\" value which keeps track of the highest value of\n   *  its children.\n   *  References:\n   *  https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n   *  http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n   *  @param {Number} low\n   *  @param {Number} high\n   *  @private\n   */\n\n\n  var IntervalNode = function IntervalNode(low, high, event) {\n    //the event container\n    this.event = event; //the low value\n\n    this.low = low; //the high value\n\n    this.high = high; //the high value for this and all child nodes\n\n    this.max = this.high; //the nodes to the left\n\n    this._left = null; //the nodes to the right\n\n    this._right = null; //the parent node\n\n    this.parent = null; //the number of child nodes\n\n    this.height = 0;\n  };\n  /**\n   *  Insert a node into the correct spot in the tree\n   *  @param  {IntervalNode}  node\n   */\n\n\n  IntervalNode.prototype.insert = function (node) {\n    if (node.low <= this.low) {\n      if (this.left === null) {\n        this.left = node;\n      } else {\n        this.left.insert(node);\n      }\n    } else if (this.right === null) {\n      this.right = node;\n    } else {\n      this.right.insert(node);\n    }\n  };\n  /**\n   *  Search the tree for nodes which overlap\n   *  with the given point\n   *  @param  {Number}  point  The point to query\n   *  @param  {Array}  results  The array to put the results\n   */\n\n\n  IntervalNode.prototype.search = function (point, results) {\n    // If p is to the right of the rightmost point of any interval\n    // in this node and all children, there won't be any matches.\n    if (point > this.max) {\n      return;\n    } // Search left children\n\n\n    if (this.left !== null) {\n      this.left.search(point, results);\n    } // Check this node\n\n\n    if (this.low <= point && this.high > point) {\n      results.push(this);\n    } // If p is to the left of the time of this interval,\n    // then it can't be in any child to the right.\n\n\n    if (this.low > point) {\n      return;\n    } // Search right children\n\n\n    if (this.right !== null) {\n      this.right.search(point, results);\n    }\n  };\n  /**\n   *  Search the tree for nodes which are less\n   *  than the given point\n   *  @param  {Number}  point  The point to query\n   *  @param  {Array}  results  The array to put the results\n   */\n\n\n  IntervalNode.prototype.searchAfter = function (point, results) {\n    // Check this node\n    if (this.low >= point) {\n      results.push(this);\n\n      if (this.left !== null) {\n        this.left.searchAfter(point, results);\n      }\n    } // search the right side\n\n\n    if (this.right !== null) {\n      this.right.searchAfter(point, results);\n    }\n  };\n  /**\n   *  Invoke the callback on this element and both it's branches\n   *  @param  {Function}  callback\n   */\n\n\n  IntervalNode.prototype.traverse = function (callback) {\n    callback(this);\n\n    if (this.left !== null) {\n      this.left.traverse(callback);\n    }\n\n    if (this.right !== null) {\n      this.right.traverse(callback);\n    }\n  };\n  /**\n   *  Update the height of the node\n   */\n\n\n  IntervalNode.prototype.updateHeight = function () {\n    if (this.left !== null && this.right !== null) {\n      this.height = Math.max(this.left.height, this.right.height) + 1;\n    } else if (this.right !== null) {\n      this.height = this.right.height + 1;\n    } else if (this.left !== null) {\n      this.height = this.left.height + 1;\n    } else {\n      this.height = 0;\n    }\n  };\n  /**\n   *  Update the height of the node\n   */\n\n\n  IntervalNode.prototype.updateMax = function () {\n    this.max = this.high;\n\n    if (this.left !== null) {\n      this.max = Math.max(this.max, this.left.max);\n    }\n\n    if (this.right !== null) {\n      this.max = Math.max(this.max, this.right.max);\n    }\n  };\n  /**\n   *  The balance is how the leafs are distributed on the node\n   *  @return  {Number}  Negative numbers are balanced to the right\n   */\n\n\n  IntervalNode.prototype.getBalance = function () {\n    var balance = 0;\n\n    if (this.left !== null && this.right !== null) {\n      balance = this.left.height - this.right.height;\n    } else if (this.left !== null) {\n      balance = this.left.height + 1;\n    } else if (this.right !== null) {\n      balance = -(this.right.height + 1);\n    }\n\n    return balance;\n  };\n  /**\n   *  @returns {Boolean} true if this node is the left child\n   *  of its parent\n   */\n\n\n  IntervalNode.prototype.isLeftChild = function () {\n    return this.parent !== null && this.parent.left === this;\n  };\n  /**\n   *  get/set the left node\n   *  @type {IntervalNode}\n   */\n\n\n  Object.defineProperty(IntervalNode.prototype, \"left\", {\n    get: function () {\n      function get() {\n        return this._left;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(node) {\n        this._left = node;\n\n        if (node !== null) {\n          node.parent = this;\n        }\n\n        this.updateHeight();\n        this.updateMax();\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  get/set the right node\n   *  @type {IntervalNode}\n   */\n\n  Object.defineProperty(IntervalNode.prototype, \"right\", {\n    get: function () {\n      function get() {\n        return this._right;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(node) {\n        this._right = node;\n\n        if (node !== null) {\n          node.parent = this;\n        }\n\n        this.updateHeight();\n        this.updateMax();\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  null out references.\n   */\n\n  IntervalNode.prototype.dispose = function () {\n    this.parent = null;\n    this._left = null;\n    this._right = null;\n    this.event = null;\n  }; ///////////////////////////////////////////////////////////////////////////\n  //\tEND INTERVAL NODE HELPER\n  ///////////////////////////////////////////////////////////////////////////\n\n\n  return Tone.IntervalTimeline;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvSW50ZXJ2YWxUaW1lbGluZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90b25lL1RvbmUvY29yZS9JbnRlcnZhbFRpbWVsaW5lLmpzPzg4YzgiXSwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFtcIlRvbmUvY29yZS9Ub25lXCIsIFwiVG9uZS90eXBlL1R5cGVcIl0sIGZ1bmN0aW9uKFRvbmUpe1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiAgQGNsYXNzIFNpbWlsYXIgdG8gVG9uZS5UaW1lbGluZSwgYnV0IGFsbCBldmVudHMgcmVwcmVzZW50XG5cdCAqICAgICAgICAgaW50ZXJ2YWxzIHdpdGggYm90aCBcInRpbWVcIiBhbmQgXCJkdXJhdGlvblwiIHRpbWVzLiBUaGVcblx0ICogICAgICAgICBldmVudHMgYXJlIHBsYWNlZCBpbiBhIHRyZWUgc3RydWN0dXJlIG9wdGltaXplZFxuXHQgKiAgICAgICAgIGZvciBxdWVyeWluZyBhbiBpbnRlcnNlY3Rpb24gcG9pbnQgd2l0aCB0aGUgdGltZWxpbmVcblx0ICogICAgICAgICBldmVudHMuIEludGVybmFsbHkgdXNlcyBhbiBbSW50ZXJ2YWwgVHJlZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW50ZXJ2YWxfdHJlZSlcblx0ICogICAgICAgICB0byByZXByZXNlbnQgdGhlIGRhdGEuXG5cdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0ICovXG5cdFRvbmUuSW50ZXJ2YWxUaW1lbGluZSA9IGZ1bmN0aW9uKCl7XG5cblx0XHRUb25lLmNhbGwodGhpcyk7XG5cblx0XHQvKipcblx0XHQgKiAgVGhlIHJvb3Qgbm9kZSBvZiB0aGUgaW50ZXZhbCB0cmVlXG5cdFx0ICogIEB0eXBlICB7SW50ZXJ2YWxOb2RlfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3Jvb3QgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogIEtlZXAgdHJhY2sgb2YgdGhlIGxlbmd0aCBvZiB0aGUgdGltZWxpbmUuXG5cdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xlbmd0aCA9IDA7XG5cdH07XG5cblx0VG9uZS5leHRlbmQoVG9uZS5JbnRlcnZhbFRpbWVsaW5lKTtcblxuXHQvKipcblx0ICogIFRoZSBldmVudCB0byBhZGQgdG8gdGhlIHRpbWVsaW5lLiBBbGwgZXZlbnRzIG11c3Rcblx0ICogIGhhdmUgYSB0aW1lIGFuZCBkdXJhdGlvbiB2YWx1ZVxuXHQgKiAgQHBhcmFtICB7T2JqZWN0fSAgZXZlbnQgIFRoZSBldmVudCB0byBhZGQgdG8gdGhlIHRpbWVsaW5lXG5cdCAqICBAcmV0dXJuICB7VG9uZS5JbnRlcnZhbFRpbWVsaW5lfSAgdGhpc1xuXHQgKi9cblx0VG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihldmVudCl7XG5cdFx0aWYgKFRvbmUuaXNVbmRlZihldmVudC50aW1lKSB8fCBUb25lLmlzVW5kZWYoZXZlbnQuZHVyYXRpb24pKXtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlRvbmUuSW50ZXJ2YWxUaW1lbGluZTogZXZlbnRzIG11c3QgaGF2ZSB0aW1lIGFuZCBkdXJhdGlvbiBwYXJhbWV0ZXJzXCIpO1xuXHRcdH1cblx0XHRldmVudC50aW1lID0gZXZlbnQudGltZS52YWx1ZU9mKCk7XG5cdFx0dmFyIG5vZGUgPSBuZXcgSW50ZXJ2YWxOb2RlKGV2ZW50LnRpbWUsIGV2ZW50LnRpbWUgKyBldmVudC5kdXJhdGlvbiwgZXZlbnQpO1xuXHRcdGlmICh0aGlzLl9yb290ID09PSBudWxsKXtcblx0XHRcdHRoaXMuX3Jvb3QgPSBub2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yb290Lmluc2VydChub2RlKTtcblx0XHR9XG5cdFx0dGhpcy5fbGVuZ3RoKys7XG5cdFx0Ly8gUmVzdHJ1Y3R1cmUgdHJlZSB0byBiZSBiYWxhbmNlZFxuXHRcdHdoaWxlIChub2RlICE9PSBudWxsKXtcblx0XHRcdG5vZGUudXBkYXRlSGVpZ2h0KCk7XG5cdFx0XHRub2RlLnVwZGF0ZU1heCgpO1xuXHRcdFx0dGhpcy5fcmViYWxhbmNlKG5vZGUpO1xuXHRcdFx0bm9kZSA9IG5vZGUucGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogIFJlbW92ZSBhbiBldmVudCBmcm9tIHRoZSB0aW1lbGluZS5cblx0ICogIEBwYXJhbSAge09iamVjdH0gIGV2ZW50ICBUaGUgZXZlbnQgdG8gcmVtb3ZlIGZyb20gdGhlIHRpbWVsaW5lXG5cdCAqICBAcmV0dXJuICB7VG9uZS5JbnRlcnZhbFRpbWVsaW5lfSAgdGhpc1xuXHQgKi9cblx0VG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihldmVudCl7XG5cdFx0aWYgKHRoaXMuX3Jvb3QgIT09IG51bGwpe1xuXHRcdFx0dmFyIHJlc3VsdHMgPSBbXTtcblx0XHRcdHRoaXMuX3Jvb3Quc2VhcmNoKGV2ZW50LnRpbWUsIHJlc3VsdHMpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0dmFyIG5vZGUgPSByZXN1bHRzW2ldO1xuXHRcdFx0XHRpZiAobm9kZS5ldmVudCA9PT0gZXZlbnQpe1xuXHRcdFx0XHRcdHRoaXMuX3JlbW92ZU5vZGUobm9kZSk7XG5cdFx0XHRcdFx0dGhpcy5fbGVuZ3RoLS07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqICBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSB0aW1lbGluZS5cblx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdCAqICBAbWVtYmVyT2YgVG9uZS5JbnRlcnZhbFRpbWVsaW5lI1xuXHQgKiAgQG5hbWUgbGVuZ3RoXG5cdCAqICBAcmVhZE9ubHlcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkludGVydmFsVGltZWxpbmUucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG5cdFx0Z2V0IDogZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiB0aGlzLl9sZW5ndGg7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogIFJlbW92ZSBldmVudHMgd2hvc2UgdGltZSB0aW1lIGlzIGFmdGVyIHRoZSBnaXZlbiB0aW1lXG5cdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSB0byBxdWVyeS5cblx0ICogIEByZXR1cm5zIHtUb25lLkludGVydmFsVGltZWxpbmV9IHRoaXNcblx0ICovXG5cdFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24oYWZ0ZXIpe1xuXHRcdHRoaXMuZm9yRWFjaEZyb20oYWZ0ZXIsIGZ1bmN0aW9uKGV2ZW50KXtcblx0XHRcdHRoaXMucmVtb3ZlKGV2ZW50KTtcblx0XHR9LmJpbmQodGhpcykpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgU2V0IHRoZSByb290IG5vZGUgYXMgdGhlIGdpdmVuIG5vZGVcblx0ICogIEBwYXJhbSB7SW50ZXJ2YWxOb2RlfSBub2RlXG5cdCAqICBAcHJpdmF0ZVxuXHQgKi9cblx0VG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5fc2V0Um9vdCA9IGZ1bmN0aW9uKG5vZGUpe1xuXHRcdHRoaXMuX3Jvb3QgPSBub2RlO1xuXHRcdGlmICh0aGlzLl9yb290ICE9PSBudWxsKXtcblx0XHRcdHRoaXMuX3Jvb3QucGFyZW50ID0gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqICBSZXBsYWNlIHRoZSByZWZlcmVuY2VzIHRvIHRoZSBub2RlIGluIHRoZSBub2RlJ3MgcGFyZW50XG5cdCAqICB3aXRoIHRoZSByZXBsYWNlbWVudCBub2RlLlxuXHQgKiAgQHBhcmFtICB7SW50ZXJ2YWxOb2RlfSAgbm9kZVxuXHQgKiAgQHBhcmFtICB7SW50ZXJ2YWxOb2RlfSAgcmVwbGFjZW1lbnRcblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLkludGVydmFsVGltZWxpbmUucHJvdG90eXBlLl9yZXBsYWNlTm9kZUluUGFyZW50ID0gZnVuY3Rpb24obm9kZSwgcmVwbGFjZW1lbnQpe1xuXHRcdGlmIChub2RlLnBhcmVudCAhPT0gbnVsbCl7XG5cdFx0XHRpZiAobm9kZS5pc0xlZnRDaGlsZCgpKXtcblx0XHRcdFx0bm9kZS5wYXJlbnQubGVmdCA9IHJlcGxhY2VtZW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZS5wYXJlbnQucmlnaHQgPSByZXBsYWNlbWVudDtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlYmFsYW5jZShub2RlLnBhcmVudCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3NldFJvb3QocmVwbGFjZW1lbnQpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogIFJlbW92ZSB0aGUgbm9kZSBmcm9tIHRoZSB0cmVlIGFuZCByZXBsYWNlIGl0IHdpdGhcblx0ICogIGEgc3VjY2Vzc29yIHdoaWNoIGZvbGxvd3MgdGhlIHNjaGVtYS5cblx0ICogIEBwYXJhbSAge0ludGVydmFsTm9kZX0gIG5vZGVcblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLkludGVydmFsVGltZWxpbmUucHJvdG90eXBlLl9yZW1vdmVOb2RlID0gZnVuY3Rpb24obm9kZSl7XG5cdFx0aWYgKG5vZGUubGVmdCA9PT0gbnVsbCAmJiBub2RlLnJpZ2h0ID09PSBudWxsKXtcblx0XHRcdHRoaXMuX3JlcGxhY2VOb2RlSW5QYXJlbnQobm9kZSwgbnVsbCk7XG5cdFx0fSBlbHNlIGlmIChub2RlLnJpZ2h0ID09PSBudWxsKXtcblx0XHRcdHRoaXMuX3JlcGxhY2VOb2RlSW5QYXJlbnQobm9kZSwgbm9kZS5sZWZ0KTtcblx0XHR9IGVsc2UgaWYgKG5vZGUubGVmdCA9PT0gbnVsbCl7XG5cdFx0XHR0aGlzLl9yZXBsYWNlTm9kZUluUGFyZW50KG5vZGUsIG5vZGUucmlnaHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgYmFsYW5jZSA9IG5vZGUuZ2V0QmFsYW5jZSgpO1xuXHRcdFx0dmFyIHJlcGxhY2VtZW50LCB0ZW1wO1xuXHRcdFx0aWYgKGJhbGFuY2UgPiAwKXtcblx0XHRcdFx0aWYgKG5vZGUubGVmdC5yaWdodCA9PT0gbnVsbCl7XG5cdFx0XHRcdFx0cmVwbGFjZW1lbnQgPSBub2RlLmxlZnQ7XG5cdFx0XHRcdFx0cmVwbGFjZW1lbnQucmlnaHQgPSBub2RlLnJpZ2h0O1xuXHRcdFx0XHRcdHRlbXAgPSByZXBsYWNlbWVudDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXBsYWNlbWVudCA9IG5vZGUubGVmdC5yaWdodDtcblx0XHRcdFx0XHR3aGlsZSAocmVwbGFjZW1lbnQucmlnaHQgIT09IG51bGwpe1xuXHRcdFx0XHRcdFx0cmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudC5yaWdodDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVwbGFjZW1lbnQucGFyZW50LnJpZ2h0ID0gcmVwbGFjZW1lbnQubGVmdDtcblx0XHRcdFx0XHR0ZW1wID0gcmVwbGFjZW1lbnQucGFyZW50O1xuXHRcdFx0XHRcdHJlcGxhY2VtZW50LmxlZnQgPSBub2RlLmxlZnQ7XG5cdFx0XHRcdFx0cmVwbGFjZW1lbnQucmlnaHQgPSBub2RlLnJpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKG5vZGUucmlnaHQubGVmdCA9PT0gbnVsbCl7XG5cdFx0XHRcdHJlcGxhY2VtZW50ID0gbm9kZS5yaWdodDtcblx0XHRcdFx0cmVwbGFjZW1lbnQubGVmdCA9IG5vZGUubGVmdDtcblx0XHRcdFx0dGVtcCA9IHJlcGxhY2VtZW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVwbGFjZW1lbnQgPSBub2RlLnJpZ2h0LmxlZnQ7XG5cdFx0XHRcdHdoaWxlIChyZXBsYWNlbWVudC5sZWZ0ICE9PSBudWxsKXtcblx0XHRcdFx0XHRyZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50LmxlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVwbGFjZW1lbnQucGFyZW50ID0gcmVwbGFjZW1lbnQucGFyZW50O1xuXHRcdFx0XHRyZXBsYWNlbWVudC5wYXJlbnQubGVmdCA9IHJlcGxhY2VtZW50LnJpZ2h0O1xuXHRcdFx0XHR0ZW1wID0gcmVwbGFjZW1lbnQucGFyZW50O1xuXHRcdFx0XHRyZXBsYWNlbWVudC5sZWZ0ID0gbm9kZS5sZWZ0O1xuXHRcdFx0XHRyZXBsYWNlbWVudC5yaWdodCA9IG5vZGUucmlnaHQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAobm9kZS5wYXJlbnQgIT09IG51bGwpe1xuXHRcdFx0XHRpZiAobm9kZS5pc0xlZnRDaGlsZCgpKXtcblx0XHRcdFx0XHRub2RlLnBhcmVudC5sZWZ0ID0gcmVwbGFjZW1lbnQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bm9kZS5wYXJlbnQucmlnaHQgPSByZXBsYWNlbWVudDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fc2V0Um9vdChyZXBsYWNlbWVudCk7XG5cdFx0XHR9XG5cdFx0XHQvLyB0aGlzLl9yZXBsYWNlTm9kZUluUGFyZW50KG5vZGUsIHJlcGxhY2VtZW50KTtcblx0XHRcdHRoaXMuX3JlYmFsYW5jZSh0ZW1wKTtcblx0XHR9XG5cdFx0bm9kZS5kaXNwb3NlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqICBSb3RhdGUgdGhlIHRyZWUgdG8gdGhlIGxlZnRcblx0ICogIEBwYXJhbSAge0ludGVydmFsTm9kZX0gIG5vZGVcblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLkludGVydmFsVGltZWxpbmUucHJvdG90eXBlLl9yb3RhdGVMZWZ0ID0gZnVuY3Rpb24obm9kZSl7XG5cdFx0dmFyIHBhcmVudCA9IG5vZGUucGFyZW50O1xuXHRcdHZhciBpc0xlZnRDaGlsZCA9IG5vZGUuaXNMZWZ0Q2hpbGQoKTtcblxuXHRcdC8vIE1ha2Ugbm9kZS5yaWdodCB0aGUgbmV3IHJvb3Qgb2YgdGhpcyBzdWIgdHJlZSAoaW5zdGVhZCBvZiBub2RlKVxuXHRcdHZhciBwaXZvdE5vZGUgPSBub2RlLnJpZ2h0O1xuXHRcdG5vZGUucmlnaHQgPSBwaXZvdE5vZGUubGVmdDtcblx0XHRwaXZvdE5vZGUubGVmdCA9IG5vZGU7XG5cblx0XHRpZiAocGFyZW50ICE9PSBudWxsKXtcblx0XHRcdGlmIChpc0xlZnRDaGlsZCl7XG5cdFx0XHRcdHBhcmVudC5sZWZ0ID0gcGl2b3ROb2RlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGFyZW50LnJpZ2h0ID0gcGl2b3ROb2RlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zZXRSb290KHBpdm90Tm9kZSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiAgUm90YXRlIHRoZSB0cmVlIHRvIHRoZSByaWdodFxuXHQgKiAgQHBhcmFtICB7SW50ZXJ2YWxOb2RlfSAgbm9kZVxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUuX3JvdGF0ZVJpZ2h0ID0gZnVuY3Rpb24obm9kZSl7XG5cdFx0dmFyIHBhcmVudCA9IG5vZGUucGFyZW50O1xuXHRcdHZhciBpc0xlZnRDaGlsZCA9IG5vZGUuaXNMZWZ0Q2hpbGQoKTtcblxuXHRcdC8vIE1ha2Ugbm9kZS5sZWZ0IHRoZSBuZXcgcm9vdCBvZiB0aGlzIHN1YiB0cmVlIChpbnN0ZWFkIG9mIG5vZGUpXG5cdFx0dmFyIHBpdm90Tm9kZSA9IG5vZGUubGVmdDtcblx0XHRub2RlLmxlZnQgPSBwaXZvdE5vZGUucmlnaHQ7XG5cdFx0cGl2b3ROb2RlLnJpZ2h0ID0gbm9kZTtcblxuXHRcdGlmIChwYXJlbnQgIT09IG51bGwpe1xuXHRcdFx0aWYgKGlzTGVmdENoaWxkKXtcblx0XHRcdFx0cGFyZW50LmxlZnQgPSBwaXZvdE5vZGU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXJlbnQucmlnaHQgPSBwaXZvdE5vZGU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3NldFJvb3QocGl2b3ROb2RlKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqICBCYWxhbmNlIHRoZSBCU1Rcblx0ICogIEBwYXJhbSAge0ludGVydmFsTm9kZX0gIG5vZGVcblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLkludGVydmFsVGltZWxpbmUucHJvdG90eXBlLl9yZWJhbGFuY2UgPSBmdW5jdGlvbihub2RlKXtcblx0XHR2YXIgYmFsYW5jZSA9IG5vZGUuZ2V0QmFsYW5jZSgpO1xuXHRcdGlmIChiYWxhbmNlID4gMSl7XG5cdFx0XHRpZiAobm9kZS5sZWZ0LmdldEJhbGFuY2UoKSA8IDApe1xuXHRcdFx0XHR0aGlzLl9yb3RhdGVMZWZ0KG5vZGUubGVmdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9yb3RhdGVSaWdodChub2RlKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGJhbGFuY2UgPCAtMSl7XG5cdFx0XHRpZiAobm9kZS5yaWdodC5nZXRCYWxhbmNlKCkgPiAwKXtcblx0XHRcdFx0dGhpcy5fcm90YXRlUmlnaHQobm9kZS5yaWdodCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9yb3RhdGVMZWZ0KG5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogIEdldCBhbiBldmVudCB3aG9zZSB0aW1lIGFuZCBkdXJhdGlvbiBzcGFuIHRoZSBnaXZlIHRpbWUuIFdpbGxcblx0ICogIHJldHVybiB0aGUgbWF0Y2ggd2hvc2UgXCJ0aW1lXCIgdmFsdWUgaXMgY2xvc2VzdCB0byB0aGUgZ2l2ZW4gdGltZS5cblx0ICogIEBwYXJhbSAge09iamVjdH0gIGV2ZW50ICBUaGUgZXZlbnQgdG8gYWRkIHRvIHRoZSB0aW1lbGluZVxuXHQgKiAgQHJldHVybiAge09iamVjdH0gIFRoZSBldmVudCB3aGljaCBzcGFucyB0aGUgZGVzaXJlZCB0aW1lXG5cdCAqL1xuXHRUb25lLkludGVydmFsVGltZWxpbmUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHRpbWUpe1xuXHRcdGlmICh0aGlzLl9yb290ICE9PSBudWxsKXtcblx0XHRcdHZhciByZXN1bHRzID0gW107XG5cdFx0XHR0aGlzLl9yb290LnNlYXJjaCh0aW1lLCByZXN1bHRzKTtcblx0XHRcdGlmIChyZXN1bHRzLmxlbmd0aCA+IDApe1xuXHRcdFx0XHR2YXIgbWF4ID0gcmVzdWx0c1swXTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0XHRpZiAocmVzdWx0c1tpXS5sb3cgPiBtYXgubG93KXtcblx0XHRcdFx0XHRcdG1heCA9IHJlc3VsdHNbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXguZXZlbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgSXRlcmF0ZSBvdmVyIGV2ZXJ5dGhpbmcgaW4gdGhlIHRpbWVsaW5lLlxuXHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZXZlcnkgaXRlbVxuXHQgKiAgQHJldHVybnMge1RvbmUuSW50ZXJ2YWxUaW1lbGluZX0gdGhpc1xuXHQgKi9cblx0VG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2spe1xuXHRcdGlmICh0aGlzLl9yb290ICE9PSBudWxsKXtcblx0XHRcdHZhciBhbGxOb2RlcyA9IFtdO1xuXHRcdFx0dGhpcy5fcm9vdC50cmF2ZXJzZShmdW5jdGlvbihub2RlKXtcblx0XHRcdFx0YWxsTm9kZXMucHVzaChub2RlKTtcblx0XHRcdH0pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdHZhciBldiA9IGFsbE5vZGVzW2ldLmV2ZW50O1xuXHRcdFx0XHRpZiAoZXYpe1xuXHRcdFx0XHRcdGNhbGxiYWNrKGV2KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogIEl0ZXJhdGUgb3ZlciBldmVyeXRoaW5nIGluIHRoZSBhcnJheSBpbiB3aGljaCB0aGUgZ2l2ZW4gdGltZVxuXHQgKiAgb3ZlcmxhcHMgd2l0aCB0aGUgdGltZSBhbmQgZHVyYXRpb24gdGltZSBvZiB0aGUgZXZlbnQuXG5cdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lIFRoZSB0aW1lIHRvIGNoZWNrIGlmIGl0ZW1zIGFyZSBvdmVybGFwcGluZ1xuXHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZXZlcnkgaXRlbVxuXHQgKiAgQHJldHVybnMge1RvbmUuSW50ZXJ2YWxUaW1lbGluZX0gdGhpc1xuXHQgKi9cblx0VG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoQXRUaW1lID0gZnVuY3Rpb24odGltZSwgY2FsbGJhY2spe1xuXHRcdGlmICh0aGlzLl9yb290ICE9PSBudWxsKXtcblx0XHRcdHZhciByZXN1bHRzID0gW107XG5cdFx0XHR0aGlzLl9yb290LnNlYXJjaCh0aW1lLCByZXN1bHRzKTtcblx0XHRcdGZvciAodmFyIGkgPSByZXN1bHRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcblx0XHRcdFx0dmFyIGV2ID0gcmVzdWx0c1tpXS5ldmVudDtcblx0XHRcdFx0aWYgKGV2KXtcblx0XHRcdFx0XHRjYWxsYmFjayhldik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqICBJdGVyYXRlIG92ZXIgZXZlcnl0aGluZyBpbiB0aGUgYXJyYXkgaW4gd2hpY2ggdGhlIHRpbWUgaXMgZ3JlYXRlclxuXHQgKiAgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gdGltZS5cblx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgVGhlIHRpbWUgdG8gY2hlY2sgaWYgaXRlbXMgYXJlIGJlZm9yZVxuXHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZXZlcnkgaXRlbVxuXHQgKiAgQHJldHVybnMge1RvbmUuSW50ZXJ2YWxUaW1lbGluZX0gdGhpc1xuXHQgKi9cblx0VG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoRnJvbSA9IGZ1bmN0aW9uKHRpbWUsIGNhbGxiYWNrKXtcblx0XHRpZiAodGhpcy5fcm9vdCAhPT0gbnVsbCl7XG5cdFx0XHR2YXIgcmVzdWx0cyA9IFtdO1xuXHRcdFx0dGhpcy5fcm9vdC5zZWFyY2hBZnRlcih0aW1lLCByZXN1bHRzKTtcblx0XHRcdGZvciAodmFyIGkgPSByZXN1bHRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcblx0XHRcdFx0dmFyIGV2ID0gcmVzdWx0c1tpXS5ldmVudDtcblx0XHRcdFx0Y2FsbGJhY2soZXYpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogIENsZWFuIHVwXG5cdCAqICBAcmV0dXJuICB7VG9uZS5JbnRlcnZhbFRpbWVsaW5lfSAgdGhpc1xuXHQgKi9cblx0VG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKXtcblx0XHR2YXIgYWxsTm9kZXMgPSBbXTtcblx0XHRpZiAodGhpcy5fcm9vdCAhPT0gbnVsbCl7XG5cdFx0XHR0aGlzLl9yb290LnRyYXZlcnNlKGZ1bmN0aW9uKG5vZGUpe1xuXHRcdFx0XHRhbGxOb2Rlcy5wdXNoKG5vZGUpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspe1xuXHRcdFx0YWxsTm9kZXNbaV0uZGlzcG9zZSgpO1xuXHRcdH1cblx0XHRhbGxOb2RlcyA9IG51bGw7XG5cdFx0dGhpcy5fcm9vdCA9IG51bGw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vXHRJTlRFUlZBTCBOT0RFIEhFTFBFUlxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHQvKipcblx0ICogIFJlcHJlc2VudHMgYSBub2RlIGluIHRoZSBiaW5hcnkgc2VhcmNoIHRyZWUsIHdpdGggdGhlIGFkZGl0aW9uXG5cdCAqICBvZiBhIFwiaGlnaFwiIHZhbHVlIHdoaWNoIGtlZXBzIHRyYWNrIG9mIHRoZSBoaWdoZXN0IHZhbHVlIG9mXG5cdCAqICBpdHMgY2hpbGRyZW4uXG5cdCAqICBSZWZlcmVuY2VzOlxuXHQgKiAgaHR0cHM6Ly9icm9va25vdmFrLndvcmRwcmVzcy5jb20vMjAxMy8xMi8wNy9hdWdtZW50ZWQtaW50ZXJ2YWwtdHJlZS1pbi1jL1xuXHQgKiAgaHR0cDovL3d3dy5taWYudnUubHQvfnZhbGRhcy9BTEdPUklUTUFJL0xJVEVSQVRVUkEvQ29ybWVuL0Nvcm1lbi5wZGZcblx0ICogIEBwYXJhbSB7TnVtYmVyfSBsb3dcblx0ICogIEBwYXJhbSB7TnVtYmVyfSBoaWdoXG5cdCAqICBAcHJpdmF0ZVxuXHQgKi9cblx0dmFyIEludGVydmFsTm9kZSA9IGZ1bmN0aW9uKGxvdywgaGlnaCwgZXZlbnQpe1xuXHRcdC8vdGhlIGV2ZW50IGNvbnRhaW5lclxuXHRcdHRoaXMuZXZlbnQgPSBldmVudDtcblx0XHQvL3RoZSBsb3cgdmFsdWVcblx0XHR0aGlzLmxvdyA9IGxvdztcblx0XHQvL3RoZSBoaWdoIHZhbHVlXG5cdFx0dGhpcy5oaWdoID0gaGlnaDtcblx0XHQvL3RoZSBoaWdoIHZhbHVlIGZvciB0aGlzIGFuZCBhbGwgY2hpbGQgbm9kZXNcblx0XHR0aGlzLm1heCA9IHRoaXMuaGlnaDtcblx0XHQvL3RoZSBub2RlcyB0byB0aGUgbGVmdFxuXHRcdHRoaXMuX2xlZnQgPSBudWxsO1xuXHRcdC8vdGhlIG5vZGVzIHRvIHRoZSByaWdodFxuXHRcdHRoaXMuX3JpZ2h0ID0gbnVsbDtcblx0XHQvL3RoZSBwYXJlbnQgbm9kZVxuXHRcdHRoaXMucGFyZW50ID0gbnVsbDtcblx0XHQvL3RoZSBudW1iZXIgb2YgY2hpbGQgbm9kZXNcblx0XHR0aGlzLmhlaWdodCA9IDA7XG5cdH07XG5cblx0LyoqXG5cdCAqICBJbnNlcnQgYSBub2RlIGludG8gdGhlIGNvcnJlY3Qgc3BvdCBpbiB0aGUgdHJlZVxuXHQgKiAgQHBhcmFtICB7SW50ZXJ2YWxOb2RlfSAgbm9kZVxuXHQgKi9cblx0SW50ZXJ2YWxOb2RlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihub2RlKXtcblx0XHRpZiAobm9kZS5sb3cgPD0gdGhpcy5sb3cpe1xuXHRcdFx0aWYgKHRoaXMubGVmdCA9PT0gbnVsbCl7XG5cdFx0XHRcdHRoaXMubGVmdCA9IG5vZGU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmxlZnQuaW5zZXJ0KG5vZGUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodGhpcy5yaWdodCA9PT0gbnVsbCl7XG5cdFx0XHR0aGlzLnJpZ2h0ID0gbm9kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5yaWdodC5pbnNlcnQobm9kZSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiAgU2VhcmNoIHRoZSB0cmVlIGZvciBub2RlcyB3aGljaCBvdmVybGFwXG5cdCAqICB3aXRoIHRoZSBnaXZlbiBwb2ludFxuXHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgcG9pbnQgIFRoZSBwb2ludCB0byBxdWVyeVxuXHQgKiAgQHBhcmFtICB7QXJyYXl9ICByZXN1bHRzICBUaGUgYXJyYXkgdG8gcHV0IHRoZSByZXN1bHRzXG5cdCAqL1xuXHRJbnRlcnZhbE5vZGUucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uKHBvaW50LCByZXN1bHRzKXtcblx0XHQvLyBJZiBwIGlzIHRvIHRoZSByaWdodCBvZiB0aGUgcmlnaHRtb3N0IHBvaW50IG9mIGFueSBpbnRlcnZhbFxuXHRcdC8vIGluIHRoaXMgbm9kZSBhbmQgYWxsIGNoaWxkcmVuLCB0aGVyZSB3b24ndCBiZSBhbnkgbWF0Y2hlcy5cblx0XHRpZiAocG9pbnQgPiB0aGlzLm1heCl7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdC8vIFNlYXJjaCBsZWZ0IGNoaWxkcmVuXG5cdFx0aWYgKHRoaXMubGVmdCAhPT0gbnVsbCl7XG5cdFx0XHR0aGlzLmxlZnQuc2VhcmNoKHBvaW50LCByZXN1bHRzKTtcblx0XHR9XG5cdFx0Ly8gQ2hlY2sgdGhpcyBub2RlXG5cdFx0aWYgKHRoaXMubG93IDw9IHBvaW50ICYmIHRoaXMuaGlnaCA+IHBvaW50KXtcblx0XHRcdHJlc3VsdHMucHVzaCh0aGlzKTtcblx0XHR9XG5cdFx0Ly8gSWYgcCBpcyB0byB0aGUgbGVmdCBvZiB0aGUgdGltZSBvZiB0aGlzIGludGVydmFsLFxuXHRcdC8vIHRoZW4gaXQgY2FuJ3QgYmUgaW4gYW55IGNoaWxkIHRvIHRoZSByaWdodC5cblx0XHRpZiAodGhpcy5sb3cgPiBwb2ludCl7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdC8vIFNlYXJjaCByaWdodCBjaGlsZHJlblxuXHRcdGlmICh0aGlzLnJpZ2h0ICE9PSBudWxsKXtcblx0XHRcdHRoaXMucmlnaHQuc2VhcmNoKHBvaW50LCByZXN1bHRzKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqICBTZWFyY2ggdGhlIHRyZWUgZm9yIG5vZGVzIHdoaWNoIGFyZSBsZXNzXG5cdCAqICB0aGFuIHRoZSBnaXZlbiBwb2ludFxuXHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgcG9pbnQgIFRoZSBwb2ludCB0byBxdWVyeVxuXHQgKiAgQHBhcmFtICB7QXJyYXl9ICByZXN1bHRzICBUaGUgYXJyYXkgdG8gcHV0IHRoZSByZXN1bHRzXG5cdCAqL1xuXHRJbnRlcnZhbE5vZGUucHJvdG90eXBlLnNlYXJjaEFmdGVyID0gZnVuY3Rpb24ocG9pbnQsIHJlc3VsdHMpe1xuXHRcdC8vIENoZWNrIHRoaXMgbm9kZVxuXHRcdGlmICh0aGlzLmxvdyA+PSBwb2ludCl7XG5cdFx0XHRyZXN1bHRzLnB1c2godGhpcyk7XG5cdFx0XHRpZiAodGhpcy5sZWZ0ICE9PSBudWxsKXtcblx0XHRcdFx0dGhpcy5sZWZ0LnNlYXJjaEFmdGVyKHBvaW50LCByZXN1bHRzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gc2VhcmNoIHRoZSByaWdodCBzaWRlXG5cdFx0aWYgKHRoaXMucmlnaHQgIT09IG51bGwpe1xuXHRcdFx0dGhpcy5yaWdodC5zZWFyY2hBZnRlcihwb2ludCwgcmVzdWx0cyk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiAgSW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGlzIGVsZW1lbnQgYW5kIGJvdGggaXQncyBicmFuY2hlc1xuXHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFja1xuXHQgKi9cblx0SW50ZXJ2YWxOb2RlLnByb3RvdHlwZS50cmF2ZXJzZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKXtcblx0XHRjYWxsYmFjayh0aGlzKTtcblx0XHRpZiAodGhpcy5sZWZ0ICE9PSBudWxsKXtcblx0XHRcdHRoaXMubGVmdC50cmF2ZXJzZShjYWxsYmFjayk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLnJpZ2h0ICE9PSBudWxsKXtcblx0XHRcdHRoaXMucmlnaHQudHJhdmVyc2UoY2FsbGJhY2spO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogIFVwZGF0ZSB0aGUgaGVpZ2h0IG9mIHRoZSBub2RlXG5cdCAqL1xuXHRJbnRlcnZhbE5vZGUucHJvdG90eXBlLnVwZGF0ZUhlaWdodCA9IGZ1bmN0aW9uKCl7XG5cdFx0aWYgKHRoaXMubGVmdCAhPT0gbnVsbCAmJiB0aGlzLnJpZ2h0ICE9PSBudWxsKXtcblx0XHRcdHRoaXMuaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5sZWZ0LmhlaWdodCwgdGhpcy5yaWdodC5oZWlnaHQpICsgMTtcblx0XHR9IGVsc2UgaWYgKHRoaXMucmlnaHQgIT09IG51bGwpe1xuXHRcdFx0dGhpcy5oZWlnaHQgPSB0aGlzLnJpZ2h0LmhlaWdodCArIDE7XG5cdFx0fSBlbHNlIGlmICh0aGlzLmxlZnQgIT09IG51bGwpe1xuXHRcdFx0dGhpcy5oZWlnaHQgPSB0aGlzLmxlZnQuaGVpZ2h0ICsgMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5oZWlnaHQgPSAwO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogIFVwZGF0ZSB0aGUgaGVpZ2h0IG9mIHRoZSBub2RlXG5cdCAqL1xuXHRJbnRlcnZhbE5vZGUucHJvdG90eXBlLnVwZGF0ZU1heCA9IGZ1bmN0aW9uKCl7XG5cdFx0dGhpcy5tYXggPSB0aGlzLmhpZ2g7XG5cdFx0aWYgKHRoaXMubGVmdCAhPT0gbnVsbCl7XG5cdFx0XHR0aGlzLm1heCA9IE1hdGgubWF4KHRoaXMubWF4LCB0aGlzLmxlZnQubWF4KTtcblx0XHR9XG5cdFx0aWYgKHRoaXMucmlnaHQgIT09IG51bGwpe1xuXHRcdFx0dGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLm1heCwgdGhpcy5yaWdodC5tYXgpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogIFRoZSBiYWxhbmNlIGlzIGhvdyB0aGUgbGVhZnMgYXJlIGRpc3RyaWJ1dGVkIG9uIHRoZSBub2RlXG5cdCAqICBAcmV0dXJuICB7TnVtYmVyfSAgTmVnYXRpdmUgbnVtYmVycyBhcmUgYmFsYW5jZWQgdG8gdGhlIHJpZ2h0XG5cdCAqL1xuXHRJbnRlcnZhbE5vZGUucHJvdG90eXBlLmdldEJhbGFuY2UgPSBmdW5jdGlvbigpe1xuXHRcdHZhciBiYWxhbmNlID0gMDtcblx0XHRpZiAodGhpcy5sZWZ0ICE9PSBudWxsICYmIHRoaXMucmlnaHQgIT09IG51bGwpe1xuXHRcdFx0YmFsYW5jZSA9IHRoaXMubGVmdC5oZWlnaHQgLSB0aGlzLnJpZ2h0LmhlaWdodDtcblx0XHR9IGVsc2UgaWYgKHRoaXMubGVmdCAhPT0gbnVsbCl7XG5cdFx0XHRiYWxhbmNlID0gdGhpcy5sZWZ0LmhlaWdodCArIDE7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnJpZ2h0ICE9PSBudWxsKXtcblx0XHRcdGJhbGFuY2UgPSAtKHRoaXMucmlnaHQuaGVpZ2h0ICsgMSk7XG5cdFx0fVxuXHRcdHJldHVybiBiYWxhbmNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBub2RlIGlzIHRoZSBsZWZ0IGNoaWxkXG5cdCAqICBvZiBpdHMgcGFyZW50XG5cdCAqL1xuXHRJbnRlcnZhbE5vZGUucHJvdG90eXBlLmlzTGVmdENoaWxkID0gZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnQgIT09IG51bGwgJiYgdGhpcy5wYXJlbnQubGVmdCA9PT0gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogIGdldC9zZXQgdGhlIGxlZnQgbm9kZVxuXHQgKiAgQHR5cGUge0ludGVydmFsTm9kZX1cblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnRlcnZhbE5vZGUucHJvdG90eXBlLCBcImxlZnRcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbGVmdDtcblx0XHR9LFxuXHRcdHNldCA6IGZ1bmN0aW9uKG5vZGUpe1xuXHRcdFx0dGhpcy5fbGVmdCA9IG5vZGU7XG5cdFx0XHRpZiAobm9kZSAhPT0gbnVsbCl7XG5cdFx0XHRcdG5vZGUucGFyZW50ID0gdGhpcztcblx0XHRcdH1cblx0XHRcdHRoaXMudXBkYXRlSGVpZ2h0KCk7XG5cdFx0XHR0aGlzLnVwZGF0ZU1heCgpO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqICBnZXQvc2V0IHRoZSByaWdodCBub2RlXG5cdCAqICBAdHlwZSB7SW50ZXJ2YWxOb2RlfVxuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KEludGVydmFsTm9kZS5wcm90b3R5cGUsIFwicmlnaHRcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmlnaHQ7XG5cdFx0fSxcblx0XHRzZXQgOiBmdW5jdGlvbihub2RlKXtcblx0XHRcdHRoaXMuX3JpZ2h0ID0gbm9kZTtcblx0XHRcdGlmIChub2RlICE9PSBudWxsKXtcblx0XHRcdFx0bm9kZS5wYXJlbnQgPSB0aGlzO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy51cGRhdGVIZWlnaHQoKTtcblx0XHRcdHRoaXMudXBkYXRlTWF4KCk7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogIG51bGwgb3V0IHJlZmVyZW5jZXMuXG5cdCAqL1xuXHRJbnRlcnZhbE5vZGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpe1xuXHRcdHRoaXMucGFyZW50ID0gbnVsbDtcblx0XHR0aGlzLl9sZWZ0ID0gbnVsbDtcblx0XHR0aGlzLl9yaWdodCA9IG51bGw7XG5cdFx0dGhpcy5ldmVudCA9IG51bGw7XG5cdH07XG5cblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vXHRFTkQgSU5URVJWQUwgTk9ERSBIRUxQRVJcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblx0cmV0dXJuIFRvbmUuSW50ZXJ2YWxUaW1lbGluZTtcbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUVBO0FBRUE7Ozs7Ozs7Ozs7QUFTQTtBQUVBO0FBRUE7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQURBO0FBTUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQUE7QUFKQTtBQWNBOzs7OztBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUFBO0FBSkE7QUFjQTs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/core/IntervalTimeline.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/core/Master.js":
/*!***********************************************!*\
  !*** ./node_modules/tone/Tone/core/Master.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/component/Volume */ \"./node_modules/tone/Tone/component/Volume.js\"), __webpack_require__(/*! Tone/core/Context */ \"./node_modules/tone/Tone/core/Context.js\"), __webpack_require__(/*! Tone/core/AudioNode */ \"./node_modules/tone/Tone/core/AudioNode.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  \"use strict\";\n  /**\n   *  @class  A single master output which is connected to the\n   *          AudioDestinationNode (aka your speakers).\n   *          It provides useful conveniences such as the ability\n   *          to set the volume and mute the entire application.\n   *          It also gives you the ability to apply master effects to your application.\n   *          <br><br>\n   *          Like Tone.Transport, A single Tone.Master is created\n   *          on initialization and you do not need to explicitly construct one.\n   *\n   *  @constructor\n   *  @extends {Tone}\n   *  @singleton\n   *  @example\n   * //the audio will go from the oscillator to the speakers\n   * oscillator.connect(Tone.Master);\n   * //a convenience for connecting to the master output is also provided:\n   * oscillator.toMaster();\n   * //the above two examples are equivalent.\n   */\n\n  Tone.Master = function () {\n    Tone.AudioNode.call(this);\n    Tone.getContext(function () {\n      this.createInsOuts(1, 0);\n      /**\n       *  The private volume node\n       *  @type  {Tone.Volume}\n       *  @private\n       */\n\n      this._volume = this.output = new Tone.Volume();\n      /**\n       * The volume of the master output.\n       * @type {Decibels}\n       * @signal\n       */\n\n      this.volume = this._volume.volume;\n\n      this._readOnly(\"volume\"); //connections\n\n\n      this.input.chain(this.output, this.context.destination);\n    }.bind(this));\n  };\n\n  Tone.extend(Tone.Master, Tone.AudioNode);\n  /**\n   *  @type {Object}\n   *  @const\n   */\n\n  Tone.Master.defaults = {\n    \"volume\": 0,\n    \"mute\": false\n  };\n  /**\n   * Mute the output.\n   * @memberOf Tone.Master#\n   * @type {boolean}\n   * @name mute\n   * @example\n   * //mute the output\n   * Tone.Master.mute = true;\n   */\n\n  Object.defineProperty(Tone.Master.prototype, \"mute\", {\n    get: function () {\n      function get() {\n        return this._volume.mute;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(mute) {\n        this._volume.mute = mute;\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  Add a master effects chain. NOTE: this will disconnect any nodes which were previously\n   *  chained in the master effects chain.\n   *  @param {AudioNode|Tone} args... All arguments will be connected in a row\n   *                                  and the Master will be routed through it.\n   *  @return  {Tone.Master}  this\n   *  @example\n   * //some overall compression to keep the levels in check\n   * var masterCompressor = new Tone.Compressor({\n   * \t\"threshold\" : -6,\n   * \t\"ratio\" : 3,\n   * \t\"attack\" : 0.5,\n   * \t\"release\" : 0.1\n   * });\n   * //give a little boost to the lows\n   * var lowBump = new Tone.Filter(200, \"lowshelf\");\n   * //route everything through the filter\n   * //and compressor before going to the speakers\n   * Tone.Master.chain(lowBump, masterCompressor);\n   */\n\n  Tone.Master.prototype.chain = function () {\n    this.input.disconnect();\n    this.input.chain.apply(this.input, arguments);\n    arguments[arguments.length - 1].connect(this.output);\n  };\n  /**\n   *  Clean up\n   *  @return  {Tone.Master}  this\n   */\n\n\n  Tone.Master.prototype.dispose = function () {\n    Tone.AudioNode.prototype.dispose.call(this);\n\n    this._writable(\"volume\");\n\n    this._volume.dispose();\n\n    this._volume = null;\n    this.volume = null;\n  }; ///////////////////////////////////////////////////////////////////////////\n  //\tAUGMENT TONE's PROTOTYPE\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  Connect 'this' to the master output. Shorthand for this.connect(Tone.Master)\n   *  @returns {Tone.AudioNode} this\n   *  @example\n   * //connect an oscillator to the master output\n   * var osc = new Tone.Oscillator().toMaster();\n   */\n\n\n  Tone.AudioNode.prototype.toMaster = function () {\n    this.connect(Tone.Master);\n    return this;\n  };\n\n  if (window.AudioNode) {\n    // Also augment AudioNode's prototype to include toMaster as a convenience\n    AudioNode.prototype.toMaster = function () {\n      this.connect(Tone.Master);\n      return this;\n    };\n  }\n  /**\n   *  initialize the module and listen for new audio contexts\n   */\n\n\n  var MasterConstructor = Tone.Master;\n  Tone.Master = new MasterConstructor();\n  Tone.Context.on(\"init\", function (context) {\n    // if it already exists, just restore it\n    if (context.Master instanceof MasterConstructor) {\n      Tone.Master = context.Master;\n    } else {\n      Tone.Master = new MasterConstructor();\n    }\n\n    context.Master = Tone.Master;\n  });\n  Tone.Context.on(\"close\", function (context) {\n    if (context.Master instanceof MasterConstructor) {\n      context.Master.dispose();\n    }\n  });\n  return Tone.Master;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvTWFzdGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RvbmUvVG9uZS9jb3JlL01hc3Rlci5qcz8yZmE0Il0sInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbXCJUb25lL2NvcmUvVG9uZVwiLCBcIlRvbmUvY29tcG9uZW50L1ZvbHVtZVwiLCBcIlRvbmUvY29yZS9Db250ZXh0XCIsIFwiVG9uZS9jb3JlL0F1ZGlvTm9kZVwiXSwgZnVuY3Rpb24oVG9uZSl7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqICBAY2xhc3MgIEEgc2luZ2xlIG1hc3RlciBvdXRwdXQgd2hpY2ggaXMgY29ubmVjdGVkIHRvIHRoZVxuXHQgKiAgICAgICAgICBBdWRpb0Rlc3RpbmF0aW9uTm9kZSAoYWthIHlvdXIgc3BlYWtlcnMpLlxuXHQgKiAgICAgICAgICBJdCBwcm92aWRlcyB1c2VmdWwgY29udmVuaWVuY2VzIHN1Y2ggYXMgdGhlIGFiaWxpdHlcblx0ICogICAgICAgICAgdG8gc2V0IHRoZSB2b2x1bWUgYW5kIG11dGUgdGhlIGVudGlyZSBhcHBsaWNhdGlvbi5cblx0ICogICAgICAgICAgSXQgYWxzbyBnaXZlcyB5b3UgdGhlIGFiaWxpdHkgdG8gYXBwbHkgbWFzdGVyIGVmZmVjdHMgdG8geW91ciBhcHBsaWNhdGlvbi5cblx0ICogICAgICAgICAgPGJyPjxicj5cblx0ICogICAgICAgICAgTGlrZSBUb25lLlRyYW5zcG9ydCwgQSBzaW5nbGUgVG9uZS5NYXN0ZXIgaXMgY3JlYXRlZFxuXHQgKiAgICAgICAgICBvbiBpbml0aWFsaXphdGlvbiBhbmQgeW91IGRvIG5vdCBuZWVkIHRvIGV4cGxpY2l0bHkgY29uc3RydWN0IG9uZS5cblx0ICpcblx0ICogIEBjb25zdHJ1Y3RvclxuXHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdCAqICBAc2luZ2xldG9uXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAvL3RoZSBhdWRpbyB3aWxsIGdvIGZyb20gdGhlIG9zY2lsbGF0b3IgdG8gdGhlIHNwZWFrZXJzXG5cdCAqIG9zY2lsbGF0b3IuY29ubmVjdChUb25lLk1hc3Rlcik7XG5cdCAqIC8vYSBjb252ZW5pZW5jZSBmb3IgY29ubmVjdGluZyB0byB0aGUgbWFzdGVyIG91dHB1dCBpcyBhbHNvIHByb3ZpZGVkOlxuXHQgKiBvc2NpbGxhdG9yLnRvTWFzdGVyKCk7XG5cdCAqIC8vdGhlIGFib3ZlIHR3byBleGFtcGxlcyBhcmUgZXF1aXZhbGVudC5cblx0ICovXG5cdFRvbmUuTWFzdGVyID0gZnVuY3Rpb24oKXtcblxuXHRcdFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdFx0VG9uZS5nZXRDb250ZXh0KGZ1bmN0aW9uKCl7XG5cdFx0XHR0aGlzLmNyZWF0ZUluc091dHMoMSwgMCk7XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogIFRoZSBwcml2YXRlIHZvbHVtZSBub2RlXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLlZvbHVtZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLl92b2x1bWUgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLlZvbHVtZSgpO1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRoZSB2b2x1bWUgb2YgdGhlIG1hc3RlciBvdXRwdXQuXG5cdFx0XHQgKiBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudm9sdW1lID0gdGhpcy5fdm9sdW1lLnZvbHVtZTtcblxuXHRcdFx0dGhpcy5fcmVhZE9ubHkoXCJ2b2x1bWVcIik7XG5cdFx0XHQvL2Nvbm5lY3Rpb25zXG5cdFx0XHR0aGlzLmlucHV0LmNoYWluKHRoaXMub3V0cHV0LCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24pO1xuXHRcdH0uYmluZCh0aGlzKSk7XG5cdH07XG5cblx0VG9uZS5leHRlbmQoVG9uZS5NYXN0ZXIsIFRvbmUuQXVkaW9Ob2RlKTtcblxuXHQvKipcblx0ICogIEB0eXBlIHtPYmplY3R9XG5cdCAqICBAY29uc3Rcblx0ICovXG5cdFRvbmUuTWFzdGVyLmRlZmF1bHRzID0ge1xuXHRcdFwidm9sdW1lXCIgOiAwLFxuXHRcdFwibXV0ZVwiIDogZmFsc2Vcblx0fTtcblxuXHQvKipcblx0ICogTXV0ZSB0aGUgb3V0cHV0LlxuXHQgKiBAbWVtYmVyT2YgVG9uZS5NYXN0ZXIjXG5cdCAqIEB0eXBlIHtib29sZWFufVxuXHQgKiBAbmFtZSBtdXRlXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vbXV0ZSB0aGUgb3V0cHV0XG5cdCAqIFRvbmUuTWFzdGVyLm11dGUgPSB0cnVlO1xuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTWFzdGVyLnByb3RvdHlwZSwgXCJtdXRlXCIsIHtcblx0XHRnZXQgOiBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX3ZvbHVtZS5tdXRlO1xuXHRcdH0sXG5cdFx0c2V0IDogZnVuY3Rpb24obXV0ZSl7XG5cdFx0XHR0aGlzLl92b2x1bWUubXV0ZSA9IG11dGU7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogIEFkZCBhIG1hc3RlciBlZmZlY3RzIGNoYWluLiBOT1RFOiB0aGlzIHdpbGwgZGlzY29ubmVjdCBhbnkgbm9kZXMgd2hpY2ggd2VyZSBwcmV2aW91c2x5XG5cdCAqICBjaGFpbmVkIGluIHRoZSBtYXN0ZXIgZWZmZWN0cyBjaGFpbi5cblx0ICogIEBwYXJhbSB7QXVkaW9Ob2RlfFRvbmV9IGFyZ3MuLi4gQWxsIGFyZ3VtZW50cyB3aWxsIGJlIGNvbm5lY3RlZCBpbiBhIHJvd1xuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgdGhlIE1hc3RlciB3aWxsIGJlIHJvdXRlZCB0aHJvdWdoIGl0LlxuXHQgKiAgQHJldHVybiAge1RvbmUuTWFzdGVyfSAgdGhpc1xuXHQgKiAgQGV4YW1wbGVcblx0ICogLy9zb21lIG92ZXJhbGwgY29tcHJlc3Npb24gdG8ga2VlcCB0aGUgbGV2ZWxzIGluIGNoZWNrXG5cdCAqIHZhciBtYXN0ZXJDb21wcmVzc29yID0gbmV3IFRvbmUuQ29tcHJlc3Nvcih7XG5cdCAqIFx0XCJ0aHJlc2hvbGRcIiA6IC02LFxuXHQgKiBcdFwicmF0aW9cIiA6IDMsXG5cdCAqIFx0XCJhdHRhY2tcIiA6IDAuNSxcblx0ICogXHRcInJlbGVhc2VcIiA6IDAuMVxuXHQgKiB9KTtcblx0ICogLy9naXZlIGEgbGl0dGxlIGJvb3N0IHRvIHRoZSBsb3dzXG5cdCAqIHZhciBsb3dCdW1wID0gbmV3IFRvbmUuRmlsdGVyKDIwMCwgXCJsb3dzaGVsZlwiKTtcblx0ICogLy9yb3V0ZSBldmVyeXRoaW5nIHRocm91Z2ggdGhlIGZpbHRlclxuXHQgKiAvL2FuZCBjb21wcmVzc29yIGJlZm9yZSBnb2luZyB0byB0aGUgc3BlYWtlcnNcblx0ICogVG9uZS5NYXN0ZXIuY2hhaW4obG93QnVtcCwgbWFzdGVyQ29tcHJlc3Nvcik7XG5cdCAqL1xuXHRUb25lLk1hc3Rlci5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbigpe1xuXHRcdHRoaXMuaW5wdXQuZGlzY29ubmVjdCgpO1xuXHRcdHRoaXMuaW5wdXQuY2hhaW4uYXBwbHkodGhpcy5pbnB1dCwgYXJndW1lbnRzKTtcblx0XHRhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgQ2xlYW4gdXBcblx0ICogIEByZXR1cm4gIHtUb25lLk1hc3Rlcn0gIHRoaXNcblx0ICovXG5cdFRvbmUuTWFzdGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKXtcblx0XHRUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuX3dyaXRhYmxlKFwidm9sdW1lXCIpO1xuXHRcdHRoaXMuX3ZvbHVtZS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5fdm9sdW1lID0gbnVsbDtcblx0XHR0aGlzLnZvbHVtZSA9IG51bGw7XG5cdH07XG5cblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vXHRBVUdNRU5UIFRPTkUncyBQUk9UT1RZUEVcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblx0LyoqXG5cdCAqICBDb25uZWN0ICd0aGlzJyB0byB0aGUgbWFzdGVyIG91dHB1dC4gU2hvcnRoYW5kIGZvciB0aGlzLmNvbm5lY3QoVG9uZS5NYXN0ZXIpXG5cdCAqICBAcmV0dXJucyB7VG9uZS5BdWRpb05vZGV9IHRoaXNcblx0ICogIEBleGFtcGxlXG5cdCAqIC8vY29ubmVjdCBhbiBvc2NpbGxhdG9yIHRvIHRoZSBtYXN0ZXIgb3V0cHV0XG5cdCAqIHZhciBvc2MgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKCkudG9NYXN0ZXIoKTtcblx0ICovXG5cdFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS50b01hc3RlciA9IGZ1bmN0aW9uKCl7XG5cdFx0dGhpcy5jb25uZWN0KFRvbmUuTWFzdGVyKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHRpZiAod2luZG93LkF1ZGlvTm9kZSl7XG5cdFx0Ly8gQWxzbyBhdWdtZW50IEF1ZGlvTm9kZSdzIHByb3RvdHlwZSB0byBpbmNsdWRlIHRvTWFzdGVyIGFzIGEgY29udmVuaWVuY2Vcblx0XHRBdWRpb05vZGUucHJvdG90eXBlLnRvTWFzdGVyID0gZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMuY29ubmVjdChUb25lLk1hc3Rlcik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqICBpbml0aWFsaXplIHRoZSBtb2R1bGUgYW5kIGxpc3RlbiBmb3IgbmV3IGF1ZGlvIGNvbnRleHRzXG5cdCAqL1xuXHR2YXIgTWFzdGVyQ29uc3RydWN0b3IgPSBUb25lLk1hc3Rlcjtcblx0VG9uZS5NYXN0ZXIgPSBuZXcgTWFzdGVyQ29uc3RydWN0b3IoKTtcblxuXHRUb25lLkNvbnRleHQub24oXCJpbml0XCIsIGZ1bmN0aW9uKGNvbnRleHQpe1xuXHRcdC8vIGlmIGl0IGFscmVhZHkgZXhpc3RzLCBqdXN0IHJlc3RvcmUgaXRcblx0XHRpZiAoY29udGV4dC5NYXN0ZXIgaW5zdGFuY2VvZiBNYXN0ZXJDb25zdHJ1Y3Rvcil7XG5cdFx0XHRUb25lLk1hc3RlciA9IGNvbnRleHQuTWFzdGVyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUb25lLk1hc3RlciA9IG5ldyBNYXN0ZXJDb25zdHJ1Y3RvcigpO1xuXHRcdH1cblx0XHRjb250ZXh0Lk1hc3RlciA9IFRvbmUuTWFzdGVyO1xuXHR9KTtcblxuXHRUb25lLkNvbnRleHQub24oXCJjbG9zZVwiLCBmdW5jdGlvbihjb250ZXh0KXtcblx0XHRpZiAoY29udGV4dC5NYXN0ZXIgaW5zdGFuY2VvZiBNYXN0ZXJDb25zdHJ1Y3Rvcil7XG5cdFx0XHRjb250ZXh0Lk1hc3Rlci5kaXNwb3NlKCk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gVG9uZS5NYXN0ZXI7XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUtBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBSkE7QUFTQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/core/Master.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/core/OfflineContext.js":
/*!*******************************************************!*\
  !*** ./node_modules/tone/Tone/core/OfflineContext.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/core/Context */ \"./node_modules/tone/Tone/core/Context.js\"), __webpack_require__(/*! Tone/shim/OfflineAudioContext */ \"./node_modules/tone/Tone/shim/OfflineAudioContext.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  /**\n   *  @class Wrapper around the OfflineAudioContext\n   *  @extends {Tone.Context}\n   *  @param  {Number}  channels  The number of channels to render\n   *  @param  {Number}  duration  The duration to render in samples\n   *  @param {Number} sampleRate the sample rate to render at\n   */\n  Tone.OfflineContext = function (channels, duration, sampleRate) {\n    /**\n     *  The offline context\n     *  @private\n     *  @type  {OfflineAudioContext}\n     */\n    var offlineContext = new OfflineAudioContext(channels, duration * sampleRate, sampleRate); //wrap the methods/members\n\n    Tone.Context.call(this, {\n      \"context\": offlineContext,\n      \"clockSource\": \"offline\",\n      \"lookAhead\": 0,\n      \"updateInterval\": 128 / sampleRate\n    });\n    /**\n     *  A private reference to the duration\n     *  @private\n     *  @type  {Number}\n     */\n\n    this._duration = duration;\n    /**\n     *  An artificial clock source\n     *  @type  {Number}\n     *  @private\n     */\n\n    this._currentTime = 0;\n  };\n\n  Tone.extend(Tone.OfflineContext, Tone.Context);\n  /**\n   *  Override the now method to point to the internal clock time\n   *  @return  {Number}\n   */\n\n  Tone.OfflineContext.prototype.now = function () {\n    return this._currentTime;\n  };\n  /**\n   *  Render the output of the OfflineContext\n   *  @return  {Promise}\n   */\n\n\n  Tone.OfflineContext.prototype.render = function () {\n    while (this._duration - this._currentTime >= 0) {\n      //invoke all the callbacks on that time\n      this.emit(\"tick\"); //increment the clock\n\n      this._currentTime += this.blockTime;\n    }\n\n    return this._context.startRendering();\n  };\n  /**\n   *  Close the context\n   *  @return  {Promise}\n   */\n\n\n  Tone.OfflineContext.prototype.close = function () {\n    this._context = null;\n    return Promise.resolve();\n  };\n\n  return Tone.OfflineContext;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvT2ZmbGluZUNvbnRleHQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvT2ZmbGluZUNvbnRleHQuanM/MjhmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoW1wiVG9uZS9jb3JlL1RvbmVcIiwgXCJUb25lL2NvcmUvQ29udGV4dFwiLCBcIlRvbmUvc2hpbS9PZmZsaW5lQXVkaW9Db250ZXh0XCJdLCBmdW5jdGlvbihUb25lKXtcblxuXHQvKipcblx0ICogIEBjbGFzcyBXcmFwcGVyIGFyb3VuZCB0aGUgT2ZmbGluZUF1ZGlvQ29udGV4dFxuXHQgKiAgQGV4dGVuZHMge1RvbmUuQ29udGV4dH1cblx0ICogIEBwYXJhbSAge051bWJlcn0gIGNoYW5uZWxzICBUaGUgbnVtYmVyIG9mIGNoYW5uZWxzIHRvIHJlbmRlclxuXHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgZHVyYXRpb24gIFRoZSBkdXJhdGlvbiB0byByZW5kZXIgaW4gc2FtcGxlc1xuXHQgKiAgQHBhcmFtIHtOdW1iZXJ9IHNhbXBsZVJhdGUgdGhlIHNhbXBsZSByYXRlIHRvIHJlbmRlciBhdFxuXHQgKi9cblx0VG9uZS5PZmZsaW5lQ29udGV4dCA9IGZ1bmN0aW9uKGNoYW5uZWxzLCBkdXJhdGlvbiwgc2FtcGxlUmF0ZSl7XG5cblx0XHQvKipcblx0XHQgKiAgVGhlIG9mZmxpbmUgY29udGV4dFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAdHlwZSAge09mZmxpbmVBdWRpb0NvbnRleHR9XG5cdFx0ICovXG5cdFx0dmFyIG9mZmxpbmVDb250ZXh0ID0gbmV3IE9mZmxpbmVBdWRpb0NvbnRleHQoY2hhbm5lbHMsIGR1cmF0aW9uICogc2FtcGxlUmF0ZSwgc2FtcGxlUmF0ZSk7XG5cblx0XHQvL3dyYXAgdGhlIG1ldGhvZHMvbWVtYmVyc1xuXHRcdFRvbmUuQ29udGV4dC5jYWxsKHRoaXMsIHtcblx0XHRcdFwiY29udGV4dFwiIDogb2ZmbGluZUNvbnRleHQsXG5cdFx0XHRcImNsb2NrU291cmNlXCIgOiBcIm9mZmxpbmVcIixcblx0XHRcdFwibG9va0FoZWFkXCIgOiAwLFxuXHRcdFx0XCJ1cGRhdGVJbnRlcnZhbFwiIDogMTI4IC8gc2FtcGxlUmF0ZVxuXHRcdH0pO1xuXG5cdFx0LyoqXG5cdFx0ICogIEEgcHJpdmF0ZSByZWZlcmVuY2UgdG8gdGhlIGR1cmF0aW9uXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb247XG5cblx0XHQvKipcblx0XHQgKiAgQW4gYXJ0aWZpY2lhbCBjbG9jayBzb3VyY2Vcblx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fY3VycmVudFRpbWUgPSAwO1xuXHR9O1xuXG5cdFRvbmUuZXh0ZW5kKFRvbmUuT2ZmbGluZUNvbnRleHQsIFRvbmUuQ29udGV4dCk7XG5cblx0LyoqXG5cdCAqICBPdmVycmlkZSB0aGUgbm93IG1ldGhvZCB0byBwb2ludCB0byB0aGUgaW50ZXJuYWwgY2xvY2sgdGltZVxuXHQgKiAgQHJldHVybiAge051bWJlcn1cblx0ICovXG5cdFRvbmUuT2ZmbGluZUNvbnRleHQucHJvdG90eXBlLm5vdyA9IGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2N1cnJlbnRUaW1lO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgUmVuZGVyIHRoZSBvdXRwdXQgb2YgdGhlIE9mZmxpbmVDb250ZXh0XG5cdCAqICBAcmV0dXJuICB7UHJvbWlzZX1cblx0ICovXG5cdFRvbmUuT2ZmbGluZUNvbnRleHQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCl7XG5cdFx0d2hpbGUgKHRoaXMuX2R1cmF0aW9uIC0gdGhpcy5fY3VycmVudFRpbWUgPj0gMCl7XG5cdFx0XHQvL2ludm9rZSBhbGwgdGhlIGNhbGxiYWNrcyBvbiB0aGF0IHRpbWVcblx0XHRcdHRoaXMuZW1pdChcInRpY2tcIik7XG5cdFx0XHQvL2luY3JlbWVudCB0aGUgY2xvY2tcblx0XHRcdHRoaXMuX2N1cnJlbnRUaW1lICs9IHRoaXMuYmxvY2tUaW1lO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl9jb250ZXh0LnN0YXJ0UmVuZGVyaW5nKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqICBDbG9zZSB0aGUgY29udGV4dFxuXHQgKiAgQHJldHVybiAge1Byb21pc2V9XG5cdCAqL1xuXHRUb25lLk9mZmxpbmVDb250ZXh0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCl7XG5cdFx0dGhpcy5fY29udGV4dCA9IG51bGw7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXHR9O1xuXG5cdHJldHVybiBUb25lLk9mZmxpbmVDb250ZXh0O1xufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBRUE7Ozs7Ozs7QUFPQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/core/OfflineContext.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/core/Param.js":
/*!**********************************************!*\
  !*** ./node_modules/tone/Tone/core/Param.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/type/Type */ \"./node_modules/tone/Tone/type/Type.js\"), __webpack_require__(/*! Tone/core/AudioNode */ \"./node_modules/tone/Tone/core/AudioNode.js\"), __webpack_require__(/*! Tone/core/Timeline */ \"./node_modules/tone/Tone/core/Timeline.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  \"use strict\";\n  /**\n   *  @class Tone.Param wraps the native Web Audio's AudioParam to provide\n   *         additional unit conversion functionality. It also\n   *         serves as a base-class for classes which have a single,\n   *         automatable parameter.\n   *  @extends {Tone.AudioNode}\n   *  @param  {AudioParam}  param  The parameter to wrap.\n   *  @param  {Tone.Type} units The units of the audio param.\n   *  @param  {Boolean} convert If the param should be converted.\n   */\n\n  Tone.Param = function () {\n    var options = Tone.defaults(arguments, [\"param\", \"units\", \"convert\"], Tone.Param);\n    Tone.AudioNode.call(this);\n    /**\n     *  The native parameter to control\n     *  @type  {AudioParam}\n     *  @private\n     */\n\n    this._param = this.input = options.param;\n    /**\n     *  The units of the parameter\n     *  @type {Tone.Type}\n     */\n\n    this.units = options.units;\n    /**\n     *  If the value should be converted or not\n     *  @type {Boolean}\n     */\n\n    this.convert = options.convert;\n    /**\n     *  True if the signal value is being overridden by\n     *  a connected signal.\n     *  @readOnly\n     *  @type  {boolean}\n     *  @private\n     */\n\n    this.overridden = false;\n    /**\n     * The timeline which tracks all of the automations.\n     * @type {Tone.Timeline}\n     * @private\n     */\n\n    this._events = new Tone.Timeline(1000);\n\n    if (Tone.isDefined(options.value) && this._param) {\n      this.value = options.value;\n    }\n  };\n\n  Tone.extend(Tone.Param, Tone.AudioNode);\n  /**\n   *  Defaults\n   *  @type  {Object}\n   *  @const\n   */\n\n  Tone.Param.defaults = {\n    \"units\": Tone.Type.Default,\n    \"convert\": true,\n    \"param\": undefined\n  };\n  /**\n   * The current value of the parameter.\n   * @memberOf Tone.Param#\n   * @type {Number}\n   * @name value\n   */\n\n  Object.defineProperty(Tone.Param.prototype, \"value\", {\n    get: function () {\n      function get() {\n        var now = this.now();\n        return this._toUnits(this.getValueAtTime(now));\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(value) {\n        this._initialValue = this._fromUnits(value);\n        this.cancelScheduledValues(this.context.currentTime);\n        this.setValueAtTime(value, this.context.currentTime);\n      }\n\n      return set;\n    }()\n  });\n  /**\n   * The minimum output value of the parameter\n   * @memberOf Tone.Param#\n   * @type {Number}\n   * @name value\n   */\n\n  Object.defineProperty(Tone.Param.prototype, \"minValue\", {\n    get: function () {\n      function get() {\n        if (this.units === Tone.Type.Time || this.units === Tone.Type.Frequency || this.units === Tone.Type.NormalRange || this.units === Tone.Type.Positive || this.units === Tone.Type.BPM) {\n          return 0;\n        } else if (this.units === Tone.Type.AudioRange) {\n          return -1;\n        } else if (this.units === Tone.Type.Decibels) {\n          return -Infinity;\n        } else {\n          return this._param.minValue;\n        }\n      }\n\n      return get;\n    }()\n  });\n  /**\n   * The maximum output value of the parameter\n   * @memberOf Tone.Param#\n   * @type {Number}\n   * @name value\n   */\n\n  Object.defineProperty(Tone.Param.prototype, \"maxValue\", {\n    get: function () {\n      function get() {\n        if (this.units === Tone.Type.NormalRange || this.units === Tone.Type.AudioRange) {\n          return 1;\n        } else {\n          return this._param.maxValue;\n        }\n      }\n\n      return get;\n    }()\n  });\n  /**\n   *  Convert the given value from the type specified by Tone.Param.units\n   *  into the destination value (such as Gain or Frequency).\n   *  @private\n   *  @param  {*} val the value to convert\n   *  @return {number}     the number which the value should be set to\n   */\n\n  Tone.Param.prototype._fromUnits = function (val) {\n    if ((this.convert || Tone.isUndef(this.convert)) && !this.overridden) {\n      switch (this.units) {\n        case Tone.Type.Time:\n          return this.toSeconds(val);\n\n        case Tone.Type.Frequency:\n          return this.toFrequency(val);\n\n        case Tone.Type.Decibels:\n          return Tone.dbToGain(val);\n\n        case Tone.Type.NormalRange:\n          return Math.min(Math.max(val, 0), 1);\n\n        case Tone.Type.AudioRange:\n          return Math.min(Math.max(val, -1), 1);\n\n        case Tone.Type.Positive:\n          return Math.max(val, 0);\n\n        default:\n          return val;\n      }\n    } else {\n      return val;\n    }\n  };\n  /**\n   * Convert the parameters value into the units specified by Tone.Param.units.\n   * @private\n   * @param  {number} val the value to convert\n   * @return {number}\n   */\n\n\n  Tone.Param.prototype._toUnits = function (val) {\n    if (this.convert || Tone.isUndef(this.convert)) {\n      switch (this.units) {\n        case Tone.Type.Decibels:\n          return Tone.gainToDb(val);\n\n        default:\n          return val;\n      }\n    } else {\n      return val;\n    }\n  };\n  /**\n   *  the minimum output value\n   *  @type {Number}\n   *  @private\n   */\n\n\n  Tone.Param.prototype._minOutput = 0.00001;\n  /**\n   *  The event types\n   *  @enum {String}\n   *  @private\n   */\n\n  Tone.Param.AutomationType = {\n    Linear: \"linearRampToValueAtTime\",\n    Exponential: \"exponentialRampToValueAtTime\",\n    Target: \"setTargetAtTime\",\n    SetValue: \"setValueAtTime\"\n  };\n  /**\n   *  Schedules a parameter value change at the given time.\n   *  @param {*}\tvalue The value to set the signal.\n   *  @param {Time}  time The time when the change should occur.\n   *  @returns {Tone.Param} this\n   *  @example\n   * //set the frequency to \"G4\" in exactly 1 second from now.\n   * freq.setValueAtTime(\"G4\", \"+1\");\n   */\n\n  Tone.Param.prototype.setValueAtTime = function (value, time) {\n    time = this.toSeconds(time);\n    value = this._fromUnits(value);\n\n    this._events.add({\n      \"type\": Tone.Param.AutomationType.SetValue,\n      \"value\": value,\n      \"time\": time\n    });\n\n    this._param.setValueAtTime(value, time);\n\n    return this;\n  };\n  /**\n   *  Get the signals value at the given time. Subsequent scheduling\n   *  may invalidate the returned value.\n   *  @param {Time} time When to get the value\n   *  @returns {Number} The value at the given time\n   */\n\n\n  Tone.Param.prototype.getValueAtTime = function (time) {\n    time = this.toSeconds(time);\n\n    var after = this._events.getAfter(time);\n\n    var before = this._events.get(time);\n\n    var initialValue = Tone.defaultArg(this._initialValue, this._param.defaultValue);\n    var value = initialValue; //if it was set by\n\n    if (before === null) {\n      value = initialValue;\n    } else if (before.type === Tone.Param.AutomationType.Target) {\n      var previous = this._events.getBefore(before.time);\n\n      var previousVal;\n\n      if (previous === null) {\n        previousVal = initialValue;\n      } else {\n        previousVal = previous.value;\n      }\n\n      value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, time);\n    } else if (after === null) {\n      value = before.value;\n    } else if (after.type === Tone.Param.AutomationType.Linear) {\n      value = this._linearInterpolate(before.time, before.value, after.time, after.value, time);\n    } else if (after.type === Tone.Param.AutomationType.Exponential) {\n      value = this._exponentialInterpolate(before.time, before.value, after.time, after.value, time);\n    } else {\n      value = before.value;\n    }\n\n    return value;\n  };\n  /**\n   *  Creates a schedule point with the current value at the current time.\n   *  This is useful for creating an automation anchor point in order to\n   *  schedule changes from the current value.\n   *\n   *  @param {number=} now (Optionally) pass the now value in.\n   *  @returns {Tone.Param} this\n   */\n\n\n  Tone.Param.prototype.setRampPoint = function (time) {\n    time = this.toSeconds(time);\n    var currentVal = this.getValueAtTime(time);\n    this.cancelAndHoldAtTime(time);\n\n    if (currentVal === 0) {\n      currentVal = this._minOutput;\n    }\n\n    this.setValueAtTime(this._toUnits(currentVal), time);\n    return this;\n  };\n  /**\n   *  Schedules a linear continuous change in parameter value from the\n   *  previous scheduled parameter value to the given value.\n   *\n   *  @param  {number} value\n   *  @param  {Time} endTime\n   *  @returns {Tone.Param} this\n   */\n\n\n  Tone.Param.prototype.linearRampToValueAtTime = function (value, endTime) {\n    value = this._fromUnits(value);\n    endTime = this.toSeconds(endTime);\n\n    this._events.add({\n      \"type\": Tone.Param.AutomationType.Linear,\n      \"value\": value,\n      \"time\": endTime\n    });\n\n    this._param.linearRampToValueAtTime(value, endTime);\n\n    return this;\n  };\n  /**\n   *  Schedules an exponential continuous change in parameter value from\n   *  the previous scheduled parameter value to the given value.\n   *\n   *  @param  {number} value\n   *  @param  {Time} endTime\n   *  @returns {Tone.Param} this\n   */\n\n\n  Tone.Param.prototype.exponentialRampToValueAtTime = function (value, endTime) {\n    value = this._fromUnits(value);\n    value = Math.max(this._minOutput, value);\n    endTime = this.toSeconds(endTime); //store the event\n\n    this._events.add({\n      \"type\": Tone.Param.AutomationType.Exponential,\n      \"time\": endTime,\n      \"value\": value\n    });\n\n    this._param.exponentialRampToValueAtTime(value, endTime);\n\n    return this;\n  };\n  /**\n   *  Schedules an exponential continuous change in parameter value from\n   *  the current time and current value to the given value over the\n   *  duration of the rampTime.\n   *\n   *  @param  {number} value   The value to ramp to.\n   *  @param  {Time} rampTime the time that it takes the\n   *                               value to ramp from it's current value\n   *  @param {Time}\t[startTime=now] \tWhen the ramp should start.\n   *  @returns {Tone.Param} this\n   *  @example\n   * //exponentially ramp to the value 2 over 4 seconds.\n   * signal.exponentialRampTo(2, 4);\n   */\n\n\n  Tone.Param.prototype.exponentialRampTo = function (value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n    return this;\n  };\n  /**\n   *  Schedules an linear continuous change in parameter value from\n   *  the current time and current value to the given value over the\n   *  duration of the rampTime.\n   *\n   *  @param  {number} value   The value to ramp to.\n   *  @param  {Time} rampTime the time that it takes the\n   *                               value to ramp from it's current value\n   *  @param {Time}\t[startTime=now] \tWhen the ramp should start.\n   *  @returns {Tone.Param} this\n   *  @example\n   * //linearly ramp to the value 4 over 3 seconds.\n   * signal.linearRampTo(4, 3);\n   */\n\n\n  Tone.Param.prototype.linearRampTo = function (value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n    return this;\n  };\n  /**\n   *  Start exponentially approaching the target value at the given time. Since it\n   *  is an exponential approach it will continue approaching after the ramp duration. The\n   *  rampTime is the time that it takes to reach over 99% of the way towards the value.\n   *  @param  {number} value   The value to ramp to.\n   *  @param  {Time} rampTime the time that it takes the\n   *                               value to ramp from it's current value\n   *  @param {Time}\t[startTime=now] \tWhen the ramp should start.\n   *  @returns {Tone.Param} this\n   *  @example\n   * //exponentially ramp to the value 2 over 4 seconds.\n   * signal.exponentialRampTo(2, 4);\n   */\n\n\n  Tone.Param.prototype.targetRampTo = function (value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.exponentialApproachValueAtTime(value, startTime, rampTime);\n    return this;\n  };\n  /**\n   *  Start exponentially approaching the target value at the given time. Since it\n   *  is an exponential approach it will continue approaching after the ramp duration. The\n   *  rampTime is the time that it takes to reach over 99% of the way towards the value. This methods\n   *  is similar to setTargetAtTime except the third argument is a time instead of a 'timeConstant'\n   *  @param  {number} value   The value to ramp to.\n   *  @param {Time}\ttime \tWhen the ramp should start.\n   *  @param  {Time} rampTime the time that it takes the\n   *                               value to ramp from it's current value\n   *  @returns {Tone.Param} this\n   *  @example\n   * //exponentially ramp to the value 2 over 4 seconds.\n   * signal.exponentialRampTo(2, 4);\n   */\n\n\n  Tone.Param.prototype.exponentialApproachValueAtTime = function (value, time, rampTime) {\n    var timeConstant = Math.log(this.toSeconds(rampTime) + 1) / Math.log(200);\n    time = this.toSeconds(time);\n    return this.setTargetAtTime(value, time, timeConstant);\n  };\n  /**\n   *  Start exponentially approaching the target value at the given time with\n   *  a rate having the given time constant.\n   *  @param {number} value\n   *  @param {Time} startTime\n   *  @param {number} timeConstant\n   *  @returns {Tone.Param} this\n   */\n\n\n  Tone.Param.prototype.setTargetAtTime = function (value, startTime, timeConstant) {\n    value = this._fromUnits(value); // The value will never be able to approach without timeConstant > 0.\n\n    if (timeConstant <= 0) {\n      throw new Error(\"timeConstant must be greater than 0\");\n    }\n\n    startTime = this.toSeconds(startTime);\n\n    this._events.add({\n      \"type\": Tone.Param.AutomationType.Target,\n      \"value\": value,\n      \"time\": startTime,\n      \"constant\": timeConstant\n    });\n\n    this._param.setTargetAtTime(value, startTime, timeConstant);\n\n    return this;\n  };\n  /**\n   *  Sets an array of arbitrary parameter values starting at the given time\n   *  for the given duration.\n   *\n   *  @param {Array} values\n   *  @param {Time} startTime\n   *  @param {Time} duration\n   *  @param {NormalRange} [scaling=1] If the values in the curve should be scaled by some value\n   *  @returns {Tone.Param} this\n   */\n\n\n  Tone.Param.prototype.setValueCurveAtTime = function (values, startTime, duration, scaling) {\n    scaling = Tone.defaultArg(scaling, 1);\n    duration = this.toSeconds(duration);\n    startTime = this.toSeconds(startTime);\n    this.setValueAtTime(values[0] * scaling, startTime);\n    var segTime = duration / (values.length - 1);\n\n    for (var i = 1; i < values.length; i++) {\n      this.linearRampToValueAtTime(values[i] * scaling, startTime + i * segTime);\n    }\n\n    return this;\n  };\n  /**\n   *  Cancels all scheduled parameter changes with times greater than or\n   *  equal to startTime.\n   *\n   *  @param  {Time} time\n   *  @returns {Tone.Param} this\n   */\n\n\n  Tone.Param.prototype.cancelScheduledValues = function (time) {\n    time = this.toSeconds(time);\n\n    this._events.cancel(time);\n\n    this._param.cancelScheduledValues(time);\n\n    return this;\n  };\n  /**\n   *  This is similar to [cancelScheduledValues](#cancelScheduledValues) except\n   *  it holds the automated value at time until the next automated event.\n   *  @param  {Time} time\n   *  @returns {Tone.Param} this\n   */\n\n\n  Tone.Param.prototype.cancelAndHoldAtTime = function (time) {\n    var valueAtTime = this.getValueAtTime(time); //if there is an event at the given time\n    //and that even is not a \"set\"\n\n    var before = this._events.get(time);\n\n    var after = this._events.getAfter(time);\n\n    if (before && before.time === time) {\n      //remove everything after\n      if (after) {\n        this._events.cancel(after.time);\n      } else {\n        this._events.cancel(time + 1e-6);\n      }\n    } else if (after) {\n      //cancel the next event(s)\n      this._events.cancel(after.time);\n\n      if (!this._param.cancelAndHoldAtTime) {\n        this._param.cancelScheduledValues(time);\n      }\n\n      if (after.type === Tone.Param.AutomationType.Linear) {\n        if (!this._param.cancelAndHoldAtTime) {\n          this.linearRampToValueAtTime(valueAtTime, time);\n        } else {\n          this._events.add({\n            \"type\": Tone.Param.AutomationType.Linear,\n            \"value\": valueAtTime,\n            \"time\": time\n          });\n        }\n      } else if (after.type === Tone.Param.AutomationType.Exponential) {\n        if (!this._param.cancelAndHoldAtTime) {\n          this.exponentialRampToValueAtTime(valueAtTime, time);\n        } else {\n          this._events.add({\n            \"type\": Tone.Param.AutomationType.Exponential,\n            \"value\": valueAtTime,\n            \"time\": time\n          });\n        }\n      }\n    } //set the value at the given time\n\n\n    this._events.add({\n      \"type\": Tone.Param.AutomationType.SetValue,\n      \"value\": valueAtTime,\n      \"time\": time\n    });\n\n    if (this._param.cancelAndHoldAtTime) {\n      this._param.cancelAndHoldAtTime(time);\n    } else {\n      this._param.setValueAtTime(valueAtTime, time);\n    }\n\n    return this;\n  };\n  /**\n   *  Ramps to the given value over the duration of the rampTime.\n   *  Automatically selects the best ramp type (exponential or linear)\n   *  depending on the `units` of the signal\n   *\n   *  @param  {number} value\n   *  @param  {Time} rampTime \tThe time that it takes the\n   *                              value to ramp from it's current value\n   *  @param {Time}\t[startTime=now] \tWhen the ramp should start.\n   *  @returns {Tone.Param} this\n   *  @example\n   * //ramp to the value either linearly or exponentially\n   * //depending on the \"units\" value of the signal\n   * signal.rampTo(0, 10);\n   *  @example\n   * //schedule it to ramp starting at a specific time\n   * signal.rampTo(0, 10, 5)\n   */\n\n\n  Tone.Param.prototype.rampTo = function (value, rampTime, startTime) {\n    rampTime = Tone.defaultArg(rampTime, 0.1);\n\n    if (this.units === Tone.Type.Frequency || this.units === Tone.Type.BPM || this.units === Tone.Type.Decibels) {\n      this.exponentialRampTo(value, rampTime, startTime);\n    } else {\n      this.linearRampTo(value, rampTime, startTime);\n    }\n\n    return this;\n  }; ///////////////////////////////////////////////////////////////////////////\n  //\tAUTOMATION CURVE CALCULATIONS\n  //\tMIT License, copyright (c) 2014 Jordan Santell\n  ///////////////////////////////////////////////////////////////////////////\n  // Calculates the the value along the curve produced by setTargetAtTime\n\n\n  Tone.Param.prototype._exponentialApproach = function (t0, v0, v1, timeConstant, t) {\n    return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n  }; // Calculates the the value along the curve produced by linearRampToValueAtTime\n\n\n  Tone.Param.prototype._linearInterpolate = function (t0, v0, t1, v1, t) {\n    return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n  }; // Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\n\n  Tone.Param.prototype._exponentialInterpolate = function (t0, v0, t1, v1, t) {\n    return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n  };\n  /**\n   *  Clean up\n   *  @returns {Tone.Param} this\n   */\n\n\n  Tone.Param.prototype.dispose = function () {\n    Tone.AudioNode.prototype.dispose.call(this);\n    this._param = null;\n    this._events = null;\n    return this;\n  };\n\n  return Tone.Param;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvUGFyYW0uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvUGFyYW0uanM/NWNjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoW1wiVG9uZS9jb3JlL1RvbmVcIiwgXCJUb25lL3R5cGUvVHlwZVwiLCBcIlRvbmUvY29yZS9BdWRpb05vZGVcIiwgXCJUb25lL2NvcmUvVGltZWxpbmVcIl0sIGZ1bmN0aW9uKFRvbmUpe1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiAgQGNsYXNzIFRvbmUuUGFyYW0gd3JhcHMgdGhlIG5hdGl2ZSBXZWIgQXVkaW8ncyBBdWRpb1BhcmFtIHRvIHByb3ZpZGVcblx0ICogICAgICAgICBhZGRpdGlvbmFsIHVuaXQgY29udmVyc2lvbiBmdW5jdGlvbmFsaXR5LiBJdCBhbHNvXG5cdCAqICAgICAgICAgc2VydmVzIGFzIGEgYmFzZS1jbGFzcyBmb3IgY2xhc3NlcyB3aGljaCBoYXZlIGEgc2luZ2xlLFxuXHQgKiAgICAgICAgIGF1dG9tYXRhYmxlIHBhcmFtZXRlci5cblx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0ICogIEBwYXJhbSAge0F1ZGlvUGFyYW19ICBwYXJhbSAgVGhlIHBhcmFtZXRlciB0byB3cmFwLlxuXHQgKiAgQHBhcmFtICB7VG9uZS5UeXBlfSB1bml0cyBUaGUgdW5pdHMgb2YgdGhlIGF1ZGlvIHBhcmFtLlxuXHQgKiAgQHBhcmFtICB7Qm9vbGVhbn0gY29udmVydCBJZiB0aGUgcGFyYW0gc2hvdWxkIGJlIGNvbnZlcnRlZC5cblx0ICovXG5cdFRvbmUuUGFyYW0gPSBmdW5jdGlvbigpe1xuXG5cdFx0dmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1wicGFyYW1cIiwgXCJ1bml0c1wiLCBcImNvbnZlcnRcIl0sIFRvbmUuUGFyYW0pO1xuXHRcdFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cblx0XHQvKipcblx0XHQgKiAgVGhlIG5hdGl2ZSBwYXJhbWV0ZXIgdG8gY29udHJvbFxuXHRcdCAqICBAdHlwZSAge0F1ZGlvUGFyYW19XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcGFyYW0gPSB0aGlzLmlucHV0ID0gb3B0aW9ucy5wYXJhbTtcblxuXHRcdC8qKlxuXHRcdCAqICBUaGUgdW5pdHMgb2YgdGhlIHBhcmFtZXRlclxuXHRcdCAqICBAdHlwZSB7VG9uZS5UeXBlfVxuXHRcdCAqL1xuXHRcdHRoaXMudW5pdHMgPSBvcHRpb25zLnVuaXRzO1xuXG5cdFx0LyoqXG5cdFx0ICogIElmIHRoZSB2YWx1ZSBzaG91bGQgYmUgY29udmVydGVkIG9yIG5vdFxuXHRcdCAqICBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHR0aGlzLmNvbnZlcnQgPSBvcHRpb25zLmNvbnZlcnQ7XG5cblx0XHQvKipcblx0XHQgKiAgVHJ1ZSBpZiB0aGUgc2lnbmFsIHZhbHVlIGlzIGJlaW5nIG92ZXJyaWRkZW4gYnlcblx0XHQgKiAgYSBjb25uZWN0ZWQgc2lnbmFsLlxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKiAgQHR5cGUgIHtib29sZWFufVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMub3ZlcnJpZGRlbiA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRpbWVsaW5lIHdoaWNoIHRyYWNrcyBhbGwgb2YgdGhlIGF1dG9tYXRpb25zLlxuXHRcdCAqIEB0eXBlIHtUb25lLlRpbWVsaW5lfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fZXZlbnRzID0gbmV3IFRvbmUuVGltZWxpbmUoMTAwMCk7XG5cblx0XHRpZiAoVG9uZS5pc0RlZmluZWQob3B0aW9ucy52YWx1ZSkgJiYgdGhpcy5fcGFyYW0pe1xuXHRcdFx0dGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG5cdFx0fVxuXHR9O1xuXG5cdFRvbmUuZXh0ZW5kKFRvbmUuUGFyYW0sIFRvbmUuQXVkaW9Ob2RlKTtcblxuXHQvKipcblx0ICogIERlZmF1bHRzXG5cdCAqICBAdHlwZSAge09iamVjdH1cblx0ICogIEBjb25zdFxuXHQgKi9cblx0VG9uZS5QYXJhbS5kZWZhdWx0cyA9IHtcblx0XHRcInVuaXRzXCIgOiBUb25lLlR5cGUuRGVmYXVsdCxcblx0XHRcImNvbnZlcnRcIiA6IHRydWUsXG5cdFx0XCJwYXJhbVwiIDogdW5kZWZpbmVkXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuXG5cdCAqIEBtZW1iZXJPZiBUb25lLlBhcmFtI1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAbmFtZSB2YWx1ZVxuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFyYW0ucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcblx0XHRnZXQgOiBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIG5vdyA9IHRoaXMubm93KCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdG9Vbml0cyh0aGlzLmdldFZhbHVlQXRUaW1lKG5vdykpO1xuXHRcdH0sXG5cdFx0c2V0IDogZnVuY3Rpb24odmFsdWUpe1xuXHRcdFx0dGhpcy5faW5pdGlhbFZhbHVlID0gdGhpcy5fZnJvbVVuaXRzKHZhbHVlKTtcblx0XHRcdHRoaXMuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRoaXMuY29udGV4dC5jdXJyZW50VGltZSk7XG5cdFx0XHR0aGlzLnNldFZhbHVlQXRUaW1lKHZhbHVlLCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUpO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIFRoZSBtaW5pbXVtIG91dHB1dCB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyXG5cdCAqIEBtZW1iZXJPZiBUb25lLlBhcmFtI1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAbmFtZSB2YWx1ZVxuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFyYW0ucHJvdG90eXBlLCBcIm1pblZhbHVlXCIsIHtcblx0XHRnZXQgOiBmdW5jdGlvbigpe1xuXHRcdFx0aWYgKHRoaXMudW5pdHMgPT09IFRvbmUuVHlwZS5UaW1lIHx8IHRoaXMudW5pdHMgPT09IFRvbmUuVHlwZS5GcmVxdWVuY3kgfHxcblx0XHRcdFx0dGhpcy51bml0cyA9PT0gVG9uZS5UeXBlLk5vcm1hbFJhbmdlIHx8IHRoaXMudW5pdHMgPT09IFRvbmUuVHlwZS5Qb3NpdGl2ZSB8fFxuXHRcdFx0XHR0aGlzLnVuaXRzID09PSBUb25lLlR5cGUuQlBNKXtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMudW5pdHMgPT09IFRvbmUuVHlwZS5BdWRpb1JhbmdlKXtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLnVuaXRzID09PSBUb25lLlR5cGUuRGVjaWJlbHMpe1xuXHRcdFx0XHRyZXR1cm4gLUluZmluaXR5O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BhcmFtLm1pblZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIFRoZSBtYXhpbXVtIG91dHB1dCB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyXG5cdCAqIEBtZW1iZXJPZiBUb25lLlBhcmFtI1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAbmFtZSB2YWx1ZVxuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFyYW0ucHJvdG90eXBlLCBcIm1heFZhbHVlXCIsIHtcblx0XHRnZXQgOiBmdW5jdGlvbigpe1xuXHRcdFx0aWYgKHRoaXMudW5pdHMgPT09IFRvbmUuVHlwZS5Ob3JtYWxSYW5nZSB8fFxuXHRcdFx0XHR0aGlzLnVuaXRzID09PSBUb25lLlR5cGUuQXVkaW9SYW5nZSl7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BhcmFtLm1heFZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqICBDb252ZXJ0IHRoZSBnaXZlbiB2YWx1ZSBmcm9tIHRoZSB0eXBlIHNwZWNpZmllZCBieSBUb25lLlBhcmFtLnVuaXRzXG5cdCAqICBpbnRvIHRoZSBkZXN0aW5hdGlvbiB2YWx1ZSAoc3VjaCBhcyBHYWluIG9yIEZyZXF1ZW5jeSkuXG5cdCAqICBAcHJpdmF0ZVxuXHQgKiAgQHBhcmFtICB7Kn0gdmFsIHRoZSB2YWx1ZSB0byBjb252ZXJ0XG5cdCAqICBAcmV0dXJuIHtudW1iZXJ9ICAgICB0aGUgbnVtYmVyIHdoaWNoIHRoZSB2YWx1ZSBzaG91bGQgYmUgc2V0IHRvXG5cdCAqL1xuXHRUb25lLlBhcmFtLnByb3RvdHlwZS5fZnJvbVVuaXRzID0gZnVuY3Rpb24odmFsKXtcblx0XHRpZiAoKHRoaXMuY29udmVydCB8fCBUb25lLmlzVW5kZWYodGhpcy5jb252ZXJ0KSkgJiYgIXRoaXMub3ZlcnJpZGRlbil7XG5cdFx0XHRzd2l0Y2ggKHRoaXMudW5pdHMpe1xuXHRcdFx0XHRjYXNlIFRvbmUuVHlwZS5UaW1lOlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLnRvU2Vjb25kcyh2YWwpO1xuXHRcdFx0XHRjYXNlIFRvbmUuVHlwZS5GcmVxdWVuY3k6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudG9GcmVxdWVuY3kodmFsKTtcblx0XHRcdFx0Y2FzZSBUb25lLlR5cGUuRGVjaWJlbHM6XG5cdFx0XHRcdFx0cmV0dXJuIFRvbmUuZGJUb0dhaW4odmFsKTtcblx0XHRcdFx0Y2FzZSBUb25lLlR5cGUuTm9ybWFsUmFuZ2U6XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbCwgMCksIDEpO1xuXHRcdFx0XHRjYXNlIFRvbmUuVHlwZS5BdWRpb1JhbmdlOlxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWwsIC0xKSwgMSk7XG5cdFx0XHRcdGNhc2UgVG9uZS5UeXBlLlBvc2l0aXZlOlxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heCh2YWwsIDApO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHJldHVybiB2YWw7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IHRoZSBwYXJhbWV0ZXJzIHZhbHVlIGludG8gdGhlIHVuaXRzIHNwZWNpZmllZCBieSBUb25lLlBhcmFtLnVuaXRzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbCB0aGUgdmFsdWUgdG8gY29udmVydFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuXHRUb25lLlBhcmFtLnByb3RvdHlwZS5fdG9Vbml0cyA9IGZ1bmN0aW9uKHZhbCl7XG5cdFx0aWYgKHRoaXMuY29udmVydCB8fCBUb25lLmlzVW5kZWYodGhpcy5jb252ZXJ0KSl7XG5cdFx0XHRzd2l0Y2ggKHRoaXMudW5pdHMpe1xuXHRcdFx0XHRjYXNlIFRvbmUuVHlwZS5EZWNpYmVsczpcblx0XHRcdFx0XHRyZXR1cm4gVG9uZS5nYWluVG9EYih2YWwpO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHJldHVybiB2YWw7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiAgdGhlIG1pbmltdW0gb3V0cHV0IHZhbHVlXG5cdCAqICBAdHlwZSB7TnVtYmVyfVxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdFRvbmUuUGFyYW0ucHJvdG90eXBlLl9taW5PdXRwdXQgPSAwLjAwMDAxO1xuXG5cdC8qKlxuXHQgKiAgVGhlIGV2ZW50IHR5cGVzXG5cdCAqICBAZW51bSB7U3RyaW5nfVxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdFRvbmUuUGFyYW0uQXV0b21hdGlvblR5cGUgPSB7XG5cdFx0TGluZWFyIDogXCJsaW5lYXJSYW1wVG9WYWx1ZUF0VGltZVwiLFxuXHRcdEV4cG9uZW50aWFsIDogXCJleHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lXCIsXG5cdFx0VGFyZ2V0IDogXCJzZXRUYXJnZXRBdFRpbWVcIixcblx0XHRTZXRWYWx1ZSA6IFwic2V0VmFsdWVBdFRpbWVcIlxuXHR9O1xuXG5cdC8qKlxuXHQgKiAgU2NoZWR1bGVzIGEgcGFyYW1ldGVyIHZhbHVlIGNoYW5nZSBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0ICogIEBwYXJhbSB7Kn1cdHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgdGhlIHNpZ25hbC5cblx0ICogIEBwYXJhbSB7VGltZX0gIHRpbWUgVGhlIHRpbWUgd2hlbiB0aGUgY2hhbmdlIHNob3VsZCBvY2N1ci5cblx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAvL3NldCB0aGUgZnJlcXVlbmN5IHRvIFwiRzRcIiBpbiBleGFjdGx5IDEgc2Vjb25kIGZyb20gbm93LlxuXHQgKiBmcmVxLnNldFZhbHVlQXRUaW1lKFwiRzRcIiwgXCIrMVwiKTtcblx0ICovXG5cdFRvbmUuUGFyYW0ucHJvdG90eXBlLnNldFZhbHVlQXRUaW1lID0gZnVuY3Rpb24odmFsdWUsIHRpbWUpe1xuXHRcdHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0XHR2YWx1ZSA9IHRoaXMuX2Zyb21Vbml0cyh2YWx1ZSk7XG5cdFx0dGhpcy5fZXZlbnRzLmFkZCh7XG5cdFx0XHRcInR5cGVcIiA6IFRvbmUuUGFyYW0uQXV0b21hdGlvblR5cGUuU2V0VmFsdWUsXG5cdFx0XHRcInZhbHVlXCIgOiB2YWx1ZSxcblx0XHRcdFwidGltZVwiIDogdGltZSxcblx0XHR9KTtcblx0XHR0aGlzLl9wYXJhbS5zZXRWYWx1ZUF0VGltZSh2YWx1ZSwgdGltZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqICBHZXQgdGhlIHNpZ25hbHMgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWUuIFN1YnNlcXVlbnQgc2NoZWR1bGluZ1xuXHQgKiAgbWF5IGludmFsaWRhdGUgdGhlIHJldHVybmVkIHZhbHVlLlxuXHQgKiAgQHBhcmFtIHtUaW1lfSB0aW1lIFdoZW4gdG8gZ2V0IHRoZSB2YWx1ZVxuXHQgKiAgQHJldHVybnMge051bWJlcn0gVGhlIHZhbHVlIGF0IHRoZSBnaXZlbiB0aW1lXG5cdCAqL1xuXHRUb25lLlBhcmFtLnByb3RvdHlwZS5nZXRWYWx1ZUF0VGltZSA9IGZ1bmN0aW9uKHRpbWUpe1xuXHRcdHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0XHR2YXIgYWZ0ZXIgPSB0aGlzLl9ldmVudHMuZ2V0QWZ0ZXIodGltZSk7XG5cdFx0dmFyIGJlZm9yZSA9IHRoaXMuX2V2ZW50cy5nZXQodGltZSk7XG5cdFx0dmFyIGluaXRpYWxWYWx1ZSA9IFRvbmUuZGVmYXVsdEFyZyh0aGlzLl9pbml0aWFsVmFsdWUsIHRoaXMuX3BhcmFtLmRlZmF1bHRWYWx1ZSk7XG5cdFx0dmFyIHZhbHVlID0gaW5pdGlhbFZhbHVlO1xuXHRcdC8vaWYgaXQgd2FzIHNldCBieVxuXHRcdGlmIChiZWZvcmUgPT09IG51bGwpe1xuXHRcdFx0dmFsdWUgPSBpbml0aWFsVmFsdWU7XG5cdFx0fSBlbHNlIGlmIChiZWZvcmUudHlwZSA9PT0gVG9uZS5QYXJhbS5BdXRvbWF0aW9uVHlwZS5UYXJnZXQpe1xuXHRcdFx0dmFyIHByZXZpb3VzID0gdGhpcy5fZXZlbnRzLmdldEJlZm9yZShiZWZvcmUudGltZSk7XG5cdFx0XHR2YXIgcHJldmlvdXNWYWw7XG5cdFx0XHRpZiAocHJldmlvdXMgPT09IG51bGwpe1xuXHRcdFx0XHRwcmV2aW91c1ZhbCA9IGluaXRpYWxWYWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHByZXZpb3VzVmFsID0gcHJldmlvdXMudmFsdWU7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9IHRoaXMuX2V4cG9uZW50aWFsQXBwcm9hY2goYmVmb3JlLnRpbWUsIHByZXZpb3VzVmFsLCBiZWZvcmUudmFsdWUsIGJlZm9yZS5jb25zdGFudCwgdGltZSk7XG5cdFx0fSBlbHNlIGlmIChhZnRlciA9PT0gbnVsbCl7XG5cdFx0XHR2YWx1ZSA9IGJlZm9yZS52YWx1ZTtcblx0XHR9IGVsc2UgaWYgKGFmdGVyLnR5cGUgPT09IFRvbmUuUGFyYW0uQXV0b21hdGlvblR5cGUuTGluZWFyKXtcblx0XHRcdHZhbHVlID0gdGhpcy5fbGluZWFySW50ZXJwb2xhdGUoYmVmb3JlLnRpbWUsIGJlZm9yZS52YWx1ZSwgYWZ0ZXIudGltZSwgYWZ0ZXIudmFsdWUsIHRpbWUpO1xuXHRcdH0gZWxzZSBpZiAoYWZ0ZXIudHlwZSA9PT0gVG9uZS5QYXJhbS5BdXRvbWF0aW9uVHlwZS5FeHBvbmVudGlhbCl7XG5cdFx0XHR2YWx1ZSA9IHRoaXMuX2V4cG9uZW50aWFsSW50ZXJwb2xhdGUoYmVmb3JlLnRpbWUsIGJlZm9yZS52YWx1ZSwgYWZ0ZXIudGltZSwgYWZ0ZXIudmFsdWUsIHRpbWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWx1ZSA9IGJlZm9yZS52YWx1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgQ3JlYXRlcyBhIHNjaGVkdWxlIHBvaW50IHdpdGggdGhlIGN1cnJlbnQgdmFsdWUgYXQgdGhlIGN1cnJlbnQgdGltZS5cblx0ICogIFRoaXMgaXMgdXNlZnVsIGZvciBjcmVhdGluZyBhbiBhdXRvbWF0aW9uIGFuY2hvciBwb2ludCBpbiBvcmRlciB0b1xuXHQgKiAgc2NoZWR1bGUgY2hhbmdlcyBmcm9tIHRoZSBjdXJyZW50IHZhbHVlLlxuXHQgKlxuXHQgKiAgQHBhcmFtIHtudW1iZXI9fSBub3cgKE9wdGlvbmFsbHkpIHBhc3MgdGhlIG5vdyB2YWx1ZSBpbi5cblx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdCAqL1xuXHRUb25lLlBhcmFtLnByb3RvdHlwZS5zZXRSYW1wUG9pbnQgPSBmdW5jdGlvbih0aW1lKXtcblx0XHR0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdFx0dmFyIGN1cnJlbnRWYWwgPSB0aGlzLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuXHRcdHRoaXMuY2FuY2VsQW5kSG9sZEF0VGltZSh0aW1lKTtcblx0XHRpZiAoY3VycmVudFZhbCA9PT0gMCl7XG5cdFx0XHRjdXJyZW50VmFsID0gdGhpcy5fbWluT3V0cHV0O1xuXHRcdH1cblx0XHR0aGlzLnNldFZhbHVlQXRUaW1lKHRoaXMuX3RvVW5pdHMoY3VycmVudFZhbCksIHRpbWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgU2NoZWR1bGVzIGEgbGluZWFyIGNvbnRpbnVvdXMgY2hhbmdlIGluIHBhcmFtZXRlciB2YWx1ZSBmcm9tIHRoZVxuXHQgKiAgcHJldmlvdXMgc2NoZWR1bGVkIHBhcmFtZXRlciB2YWx1ZSB0byB0aGUgZ2l2ZW4gdmFsdWUuXG5cdCAqXG5cdCAqICBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXG5cdCAqICBAcGFyYW0gIHtUaW1lfSBlbmRUaW1lXG5cdCAqICBAcmV0dXJucyB7VG9uZS5QYXJhbX0gdGhpc1xuXHQgKi9cblx0VG9uZS5QYXJhbS5wcm90b3R5cGUubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUgPSBmdW5jdGlvbih2YWx1ZSwgZW5kVGltZSl7XG5cdFx0dmFsdWUgPSB0aGlzLl9mcm9tVW5pdHModmFsdWUpO1xuXHRcdGVuZFRpbWUgPSB0aGlzLnRvU2Vjb25kcyhlbmRUaW1lKTtcblx0XHR0aGlzLl9ldmVudHMuYWRkKHtcblx0XHRcdFwidHlwZVwiIDogVG9uZS5QYXJhbS5BdXRvbWF0aW9uVHlwZS5MaW5lYXIsXG5cdFx0XHRcInZhbHVlXCIgOiB2YWx1ZSxcblx0XHRcdFwidGltZVwiIDogZW5kVGltZSxcblx0XHR9KTtcblx0XHR0aGlzLl9wYXJhbS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh2YWx1ZSwgZW5kVGltZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqICBTY2hlZHVsZXMgYW4gZXhwb25lbnRpYWwgY29udGludW91cyBjaGFuZ2UgaW4gcGFyYW1ldGVyIHZhbHVlIGZyb21cblx0ICogIHRoZSBwcmV2aW91cyBzY2hlZHVsZWQgcGFyYW1ldGVyIHZhbHVlIHRvIHRoZSBnaXZlbiB2YWx1ZS5cblx0ICpcblx0ICogIEBwYXJhbSAge251bWJlcn0gdmFsdWVcblx0ICogIEBwYXJhbSAge1RpbWV9IGVuZFRpbWVcblx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdCAqL1xuXHRUb25lLlBhcmFtLnByb3RvdHlwZS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lID0gZnVuY3Rpb24odmFsdWUsIGVuZFRpbWUpe1xuXHRcdHZhbHVlID0gdGhpcy5fZnJvbVVuaXRzKHZhbHVlKTtcblx0XHR2YWx1ZSA9IE1hdGgubWF4KHRoaXMuX21pbk91dHB1dCwgdmFsdWUpO1xuXHRcdGVuZFRpbWUgPSB0aGlzLnRvU2Vjb25kcyhlbmRUaW1lKTtcblx0XHQvL3N0b3JlIHRoZSBldmVudFxuXHRcdHRoaXMuX2V2ZW50cy5hZGQoe1xuXHRcdFx0XCJ0eXBlXCIgOiBUb25lLlBhcmFtLkF1dG9tYXRpb25UeXBlLkV4cG9uZW50aWFsLFxuXHRcdFx0XCJ0aW1lXCIgOiBlbmRUaW1lLFxuXHRcdFx0XCJ2YWx1ZVwiIDogdmFsdWVcblx0XHR9KTtcblx0XHR0aGlzLl9wYXJhbS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHZhbHVlLCBlbmRUaW1lKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogIFNjaGVkdWxlcyBhbiBleHBvbmVudGlhbCBjb250aW51b3VzIGNoYW5nZSBpbiBwYXJhbWV0ZXIgdmFsdWUgZnJvbVxuXHQgKiAgdGhlIGN1cnJlbnQgdGltZSBhbmQgY3VycmVudCB2YWx1ZSB0byB0aGUgZ2l2ZW4gdmFsdWUgb3ZlciB0aGVcblx0ICogIGR1cmF0aW9uIG9mIHRoZSByYW1wVGltZS5cblx0ICpcblx0ICogIEBwYXJhbSAge251bWJlcn0gdmFsdWUgICBUaGUgdmFsdWUgdG8gcmFtcCB0by5cblx0ICogIEBwYXJhbSAge1RpbWV9IHJhbXBUaW1lIHRoZSB0aW1lIHRoYXQgaXQgdGFrZXMgdGhlXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIHRvIHJhbXAgZnJvbSBpdCdzIGN1cnJlbnQgdmFsdWVcblx0ICogIEBwYXJhbSB7VGltZX1cdFtzdGFydFRpbWU9bm93XSBcdFdoZW4gdGhlIHJhbXAgc2hvdWxkIHN0YXJ0LlxuXHQgKiAgQHJldHVybnMge1RvbmUuUGFyYW19IHRoaXNcblx0ICogIEBleGFtcGxlXG5cdCAqIC8vZXhwb25lbnRpYWxseSByYW1wIHRvIHRoZSB2YWx1ZSAyIG92ZXIgNCBzZWNvbmRzLlxuXHQgKiBzaWduYWwuZXhwb25lbnRpYWxSYW1wVG8oMiwgNCk7XG5cdCAqL1xuXHRUb25lLlBhcmFtLnByb3RvdHlwZS5leHBvbmVudGlhbFJhbXBUbyA9IGZ1bmN0aW9uKHZhbHVlLCByYW1wVGltZSwgc3RhcnRUaW1lKXtcblx0XHRzdGFydFRpbWUgPSB0aGlzLnRvU2Vjb25kcyhzdGFydFRpbWUpO1xuXHRcdHRoaXMuc2V0UmFtcFBvaW50KHN0YXJ0VGltZSk7XG5cdFx0dGhpcy5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHZhbHVlLCBzdGFydFRpbWUgKyB0aGlzLnRvU2Vjb25kcyhyYW1wVGltZSkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgU2NoZWR1bGVzIGFuIGxpbmVhciBjb250aW51b3VzIGNoYW5nZSBpbiBwYXJhbWV0ZXIgdmFsdWUgZnJvbVxuXHQgKiAgdGhlIGN1cnJlbnQgdGltZSBhbmQgY3VycmVudCB2YWx1ZSB0byB0aGUgZ2l2ZW4gdmFsdWUgb3ZlciB0aGVcblx0ICogIGR1cmF0aW9uIG9mIHRoZSByYW1wVGltZS5cblx0ICpcblx0ICogIEBwYXJhbSAge251bWJlcn0gdmFsdWUgICBUaGUgdmFsdWUgdG8gcmFtcCB0by5cblx0ICogIEBwYXJhbSAge1RpbWV9IHJhbXBUaW1lIHRoZSB0aW1lIHRoYXQgaXQgdGFrZXMgdGhlXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIHRvIHJhbXAgZnJvbSBpdCdzIGN1cnJlbnQgdmFsdWVcblx0ICogIEBwYXJhbSB7VGltZX1cdFtzdGFydFRpbWU9bm93XSBcdFdoZW4gdGhlIHJhbXAgc2hvdWxkIHN0YXJ0LlxuXHQgKiAgQHJldHVybnMge1RvbmUuUGFyYW19IHRoaXNcblx0ICogIEBleGFtcGxlXG5cdCAqIC8vbGluZWFybHkgcmFtcCB0byB0aGUgdmFsdWUgNCBvdmVyIDMgc2Vjb25kcy5cblx0ICogc2lnbmFsLmxpbmVhclJhbXBUbyg0LCAzKTtcblx0ICovXG5cdFRvbmUuUGFyYW0ucHJvdG90eXBlLmxpbmVhclJhbXBUbyA9IGZ1bmN0aW9uKHZhbHVlLCByYW1wVGltZSwgc3RhcnRUaW1lKXtcblx0XHRzdGFydFRpbWUgPSB0aGlzLnRvU2Vjb25kcyhzdGFydFRpbWUpO1xuXHRcdHRoaXMuc2V0UmFtcFBvaW50KHN0YXJ0VGltZSk7XG5cdFx0dGhpcy5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh2YWx1ZSwgc3RhcnRUaW1lICsgdGhpcy50b1NlY29uZHMocmFtcFRpbWUpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogIFN0YXJ0IGV4cG9uZW50aWFsbHkgYXBwcm9hY2hpbmcgdGhlIHRhcmdldCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZS4gU2luY2UgaXRcblx0ICogIGlzIGFuIGV4cG9uZW50aWFsIGFwcHJvYWNoIGl0IHdpbGwgY29udGludWUgYXBwcm9hY2hpbmcgYWZ0ZXIgdGhlIHJhbXAgZHVyYXRpb24uIFRoZVxuXHQgKiAgcmFtcFRpbWUgaXMgdGhlIHRpbWUgdGhhdCBpdCB0YWtlcyB0byByZWFjaCBvdmVyIDk5JSBvZiB0aGUgd2F5IHRvd2FyZHMgdGhlIHZhbHVlLlxuXHQgKiAgQHBhcmFtICB7bnVtYmVyfSB2YWx1ZSAgIFRoZSB2YWx1ZSB0byByYW1wIHRvLlxuXHQgKiAgQHBhcmFtICB7VGltZX0gcmFtcFRpbWUgdGhlIHRpbWUgdGhhdCBpdCB0YWtlcyB0aGVcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgdG8gcmFtcCBmcm9tIGl0J3MgY3VycmVudCB2YWx1ZVxuXHQgKiAgQHBhcmFtIHtUaW1lfVx0W3N0YXJ0VGltZT1ub3ddIFx0V2hlbiB0aGUgcmFtcCBzaG91bGQgc3RhcnQuXG5cdCAqICBAcmV0dXJucyB7VG9uZS5QYXJhbX0gdGhpc1xuXHQgKiAgQGV4YW1wbGVcblx0ICogLy9leHBvbmVudGlhbGx5IHJhbXAgdG8gdGhlIHZhbHVlIDIgb3ZlciA0IHNlY29uZHMuXG5cdCAqIHNpZ25hbC5leHBvbmVudGlhbFJhbXBUbygyLCA0KTtcblx0ICovXG5cdFRvbmUuUGFyYW0ucHJvdG90eXBlLnRhcmdldFJhbXBUbyA9IGZ1bmN0aW9uKHZhbHVlLCByYW1wVGltZSwgc3RhcnRUaW1lKXtcblx0XHRzdGFydFRpbWUgPSB0aGlzLnRvU2Vjb25kcyhzdGFydFRpbWUpO1xuXHRcdHRoaXMuc2V0UmFtcFBvaW50KHN0YXJ0VGltZSk7XG5cdFx0dGhpcy5leHBvbmVudGlhbEFwcHJvYWNoVmFsdWVBdFRpbWUodmFsdWUsIHN0YXJ0VGltZSwgcmFtcFRpbWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgU3RhcnQgZXhwb25lbnRpYWxseSBhcHByb2FjaGluZyB0aGUgdGFyZ2V0IHZhbHVlIGF0IHRoZSBnaXZlbiB0aW1lLiBTaW5jZSBpdFxuXHQgKiAgaXMgYW4gZXhwb25lbnRpYWwgYXBwcm9hY2ggaXQgd2lsbCBjb250aW51ZSBhcHByb2FjaGluZyBhZnRlciB0aGUgcmFtcCBkdXJhdGlvbi4gVGhlXG5cdCAqICByYW1wVGltZSBpcyB0aGUgdGltZSB0aGF0IGl0IHRha2VzIHRvIHJlYWNoIG92ZXIgOTklIG9mIHRoZSB3YXkgdG93YXJkcyB0aGUgdmFsdWUuIFRoaXMgbWV0aG9kc1xuXHQgKiAgaXMgc2ltaWxhciB0byBzZXRUYXJnZXRBdFRpbWUgZXhjZXB0IHRoZSB0aGlyZCBhcmd1bWVudCBpcyBhIHRpbWUgaW5zdGVhZCBvZiBhICd0aW1lQ29uc3RhbnQnXG5cdCAqICBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlICAgVGhlIHZhbHVlIHRvIHJhbXAgdG8uXG5cdCAqICBAcGFyYW0ge1RpbWV9XHR0aW1lIFx0V2hlbiB0aGUgcmFtcCBzaG91bGQgc3RhcnQuXG5cdCAqICBAcGFyYW0gIHtUaW1lfSByYW1wVGltZSB0aGUgdGltZSB0aGF0IGl0IHRha2VzIHRoZVxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSB0byByYW1wIGZyb20gaXQncyBjdXJyZW50IHZhbHVlXG5cdCAqICBAcmV0dXJucyB7VG9uZS5QYXJhbX0gdGhpc1xuXHQgKiAgQGV4YW1wbGVcblx0ICogLy9leHBvbmVudGlhbGx5IHJhbXAgdG8gdGhlIHZhbHVlIDIgb3ZlciA0IHNlY29uZHMuXG5cdCAqIHNpZ25hbC5leHBvbmVudGlhbFJhbXBUbygyLCA0KTtcblx0ICovXG5cdFRvbmUuUGFyYW0ucHJvdG90eXBlLmV4cG9uZW50aWFsQXBwcm9hY2hWYWx1ZUF0VGltZSA9IGZ1bmN0aW9uKHZhbHVlLCB0aW1lLCByYW1wVGltZSl7XG5cdFx0dmFyIHRpbWVDb25zdGFudCA9IE1hdGgubG9nKHRoaXMudG9TZWNvbmRzKHJhbXBUaW1lKSsxKS9NYXRoLmxvZygyMDApO1xuXHRcdHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0XHRyZXR1cm4gdGhpcy5zZXRUYXJnZXRBdFRpbWUodmFsdWUsIHRpbWUsIHRpbWVDb25zdGFudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqICBTdGFydCBleHBvbmVudGlhbGx5IGFwcHJvYWNoaW5nIHRoZSB0YXJnZXQgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWUgd2l0aFxuXHQgKiAgYSByYXRlIGhhdmluZyB0aGUgZ2l2ZW4gdGltZSBjb25zdGFudC5cblx0ICogIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuXHQgKiAgQHBhcmFtIHtUaW1lfSBzdGFydFRpbWVcblx0ICogIEBwYXJhbSB7bnVtYmVyfSB0aW1lQ29uc3RhbnRcblx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdCAqL1xuXHRUb25lLlBhcmFtLnByb3RvdHlwZS5zZXRUYXJnZXRBdFRpbWUgPSBmdW5jdGlvbih2YWx1ZSwgc3RhcnRUaW1lLCB0aW1lQ29uc3RhbnQpe1xuXHRcdHZhbHVlID0gdGhpcy5fZnJvbVVuaXRzKHZhbHVlKTtcblx0XHQvLyBUaGUgdmFsdWUgd2lsbCBuZXZlciBiZSBhYmxlIHRvIGFwcHJvYWNoIHdpdGhvdXQgdGltZUNvbnN0YW50ID4gMC5cblx0XHRpZiAodGltZUNvbnN0YW50IDw9IDApe1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidGltZUNvbnN0YW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcIik7XG5cdFx0fVxuXHRcdHN0YXJ0VGltZSA9IHRoaXMudG9TZWNvbmRzKHN0YXJ0VGltZSk7XG5cdFx0dGhpcy5fZXZlbnRzLmFkZCh7XG5cdFx0XHRcInR5cGVcIiA6IFRvbmUuUGFyYW0uQXV0b21hdGlvblR5cGUuVGFyZ2V0LFxuXHRcdFx0XCJ2YWx1ZVwiIDogdmFsdWUsXG5cdFx0XHRcInRpbWVcIiA6IHN0YXJ0VGltZSxcblx0XHRcdFwiY29uc3RhbnRcIiA6IHRpbWVDb25zdGFudFxuXHRcdH0pO1xuXHRcdHRoaXMuX3BhcmFtLnNldFRhcmdldEF0VGltZSh2YWx1ZSwgc3RhcnRUaW1lLCB0aW1lQ29uc3RhbnQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgU2V0cyBhbiBhcnJheSBvZiBhcmJpdHJhcnkgcGFyYW1ldGVyIHZhbHVlcyBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gdGltZVxuXHQgKiAgZm9yIHRoZSBnaXZlbiBkdXJhdGlvbi5cblx0ICpcblx0ICogIEBwYXJhbSB7QXJyYXl9IHZhbHVlc1xuXHQgKiAgQHBhcmFtIHtUaW1lfSBzdGFydFRpbWVcblx0ICogIEBwYXJhbSB7VGltZX0gZHVyYXRpb25cblx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2V9IFtzY2FsaW5nPTFdIElmIHRoZSB2YWx1ZXMgaW4gdGhlIGN1cnZlIHNob3VsZCBiZSBzY2FsZWQgYnkgc29tZSB2YWx1ZVxuXHQgKiAgQHJldHVybnMge1RvbmUuUGFyYW19IHRoaXNcblx0ICovXG5cdFRvbmUuUGFyYW0ucHJvdG90eXBlLnNldFZhbHVlQ3VydmVBdFRpbWUgPSBmdW5jdGlvbih2YWx1ZXMsIHN0YXJ0VGltZSwgZHVyYXRpb24sIHNjYWxpbmcpe1xuXHRcdHNjYWxpbmcgPSBUb25lLmRlZmF1bHRBcmcoc2NhbGluZywgMSk7XG5cdFx0ZHVyYXRpb24gPSB0aGlzLnRvU2Vjb25kcyhkdXJhdGlvbik7XG5cdFx0c3RhcnRUaW1lID0gdGhpcy50b1NlY29uZHMoc3RhcnRUaW1lKTtcblx0XHR0aGlzLnNldFZhbHVlQXRUaW1lKHZhbHVlc1swXSAqIHNjYWxpbmcsIHN0YXJ0VGltZSk7XG5cdFx0dmFyIHNlZ1RpbWUgPSBkdXJhdGlvbiAvICh2YWx1ZXMubGVuZ3RoIC0gMSk7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspe1xuXHRcdFx0dGhpcy5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh2YWx1ZXNbaV0gKiBzY2FsaW5nLCBzdGFydFRpbWUgKyBpICogc2VnVGltZSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgQ2FuY2VscyBhbGwgc2NoZWR1bGVkIHBhcmFtZXRlciBjaGFuZ2VzIHdpdGggdGltZXMgZ3JlYXRlciB0aGFuIG9yXG5cdCAqICBlcXVhbCB0byBzdGFydFRpbWUuXG5cdCAqXG5cdCAqICBAcGFyYW0gIHtUaW1lfSB0aW1lXG5cdCAqICBAcmV0dXJucyB7VG9uZS5QYXJhbX0gdGhpc1xuXHQgKi9cblx0VG9uZS5QYXJhbS5wcm90b3R5cGUuY2FuY2VsU2NoZWR1bGVkVmFsdWVzID0gZnVuY3Rpb24odGltZSl7XG5cdFx0dGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHRcdHRoaXMuX2V2ZW50cy5jYW5jZWwodGltZSk7XG5cdFx0dGhpcy5fcGFyYW0uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRpbWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgVGhpcyBpcyBzaW1pbGFyIHRvIFtjYW5jZWxTY2hlZHVsZWRWYWx1ZXNdKCNjYW5jZWxTY2hlZHVsZWRWYWx1ZXMpIGV4Y2VwdFxuXHQgKiAgaXQgaG9sZHMgdGhlIGF1dG9tYXRlZCB2YWx1ZSBhdCB0aW1lIHVudGlsIHRoZSBuZXh0IGF1dG9tYXRlZCBldmVudC5cblx0ICogIEBwYXJhbSAge1RpbWV9IHRpbWVcblx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdCAqL1xuXHRUb25lLlBhcmFtLnByb3RvdHlwZS5jYW5jZWxBbmRIb2xkQXRUaW1lID0gZnVuY3Rpb24odGltZSl7XG5cdFx0dmFyIHZhbHVlQXRUaW1lID0gdGhpcy5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcblx0XHQvL2lmIHRoZXJlIGlzIGFuIGV2ZW50IGF0IHRoZSBnaXZlbiB0aW1lXG5cdFx0Ly9hbmQgdGhhdCBldmVuIGlzIG5vdCBhIFwic2V0XCJcblx0XHR2YXIgYmVmb3JlID0gdGhpcy5fZXZlbnRzLmdldCh0aW1lKTtcblx0XHR2YXIgYWZ0ZXIgPSB0aGlzLl9ldmVudHMuZ2V0QWZ0ZXIodGltZSk7XG5cdFx0aWYgKGJlZm9yZSAmJiBiZWZvcmUudGltZSA9PT0gdGltZSl7XG5cdFx0XHQvL3JlbW92ZSBldmVyeXRoaW5nIGFmdGVyXG5cdFx0XHRpZiAoYWZ0ZXIpe1xuXHRcdFx0XHR0aGlzLl9ldmVudHMuY2FuY2VsKGFmdGVyLnRpbWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fZXZlbnRzLmNhbmNlbCh0aW1lICsgMWUtNik7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChhZnRlcil7XG5cdFx0XHQvL2NhbmNlbCB0aGUgbmV4dCBldmVudChzKVxuXHRcdFx0dGhpcy5fZXZlbnRzLmNhbmNlbChhZnRlci50aW1lKTtcblx0XHRcdGlmICghdGhpcy5fcGFyYW0uY2FuY2VsQW5kSG9sZEF0VGltZSl7XG5cdFx0XHRcdHRoaXMuX3BhcmFtLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aW1lKTtcblx0XHRcdH1cblx0XHRcdGlmIChhZnRlci50eXBlID09PSBUb25lLlBhcmFtLkF1dG9tYXRpb25UeXBlLkxpbmVhcil7XG5cdFx0XHRcdGlmICghdGhpcy5fcGFyYW0uY2FuY2VsQW5kSG9sZEF0VGltZSl7XG5cdFx0XHRcdFx0dGhpcy5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh2YWx1ZUF0VGltZSwgdGltZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fZXZlbnRzLmFkZCh7XG5cdFx0XHRcdFx0XHRcInR5cGVcIiA6IFRvbmUuUGFyYW0uQXV0b21hdGlvblR5cGUuTGluZWFyLFxuXHRcdFx0XHRcdFx0XCJ2YWx1ZVwiIDogdmFsdWVBdFRpbWUsXG5cdFx0XHRcdFx0XHRcInRpbWVcIiA6IHRpbWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChhZnRlci50eXBlID09PSBUb25lLlBhcmFtLkF1dG9tYXRpb25UeXBlLkV4cG9uZW50aWFsKXtcblx0XHRcdFx0aWYgKCF0aGlzLl9wYXJhbS5jYW5jZWxBbmRIb2xkQXRUaW1lKXtcblx0XHRcdFx0XHR0aGlzLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodmFsdWVBdFRpbWUsIHRpbWUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2V2ZW50cy5hZGQoe1xuXHRcdFx0XHRcdFx0XCJ0eXBlXCIgOiBUb25lLlBhcmFtLkF1dG9tYXRpb25UeXBlLkV4cG9uZW50aWFsLFxuXHRcdFx0XHRcdFx0XCJ2YWx1ZVwiIDogdmFsdWVBdFRpbWUsXG5cdFx0XHRcdFx0XHRcInRpbWVcIiA6IHRpbWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vc2V0IHRoZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZVxuXHRcdHRoaXMuX2V2ZW50cy5hZGQoe1xuXHRcdFx0XCJ0eXBlXCIgOiBUb25lLlBhcmFtLkF1dG9tYXRpb25UeXBlLlNldFZhbHVlLFxuXHRcdFx0XCJ2YWx1ZVwiIDogdmFsdWVBdFRpbWUsXG5cdFx0XHRcInRpbWVcIiA6IHRpbWVcblx0XHR9KTtcblx0XHRpZiAodGhpcy5fcGFyYW0uY2FuY2VsQW5kSG9sZEF0VGltZSl7XG5cdFx0XHR0aGlzLl9wYXJhbS5jYW5jZWxBbmRIb2xkQXRUaW1lKHRpbWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9wYXJhbS5zZXRWYWx1ZUF0VGltZSh2YWx1ZUF0VGltZSwgdGltZSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgUmFtcHMgdG8gdGhlIGdpdmVuIHZhbHVlIG92ZXIgdGhlIGR1cmF0aW9uIG9mIHRoZSByYW1wVGltZS5cblx0ICogIEF1dG9tYXRpY2FsbHkgc2VsZWN0cyB0aGUgYmVzdCByYW1wIHR5cGUgKGV4cG9uZW50aWFsIG9yIGxpbmVhcilcblx0ICogIGRlcGVuZGluZyBvbiB0aGUgYHVuaXRzYCBvZiB0aGUgc2lnbmFsXG5cdCAqXG5cdCAqICBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXG5cdCAqICBAcGFyYW0gIHtUaW1lfSByYW1wVGltZSBcdFRoZSB0aW1lIHRoYXQgaXQgdGFrZXMgdGhlXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgdG8gcmFtcCBmcm9tIGl0J3MgY3VycmVudCB2YWx1ZVxuXHQgKiAgQHBhcmFtIHtUaW1lfVx0W3N0YXJ0VGltZT1ub3ddIFx0V2hlbiB0aGUgcmFtcCBzaG91bGQgc3RhcnQuXG5cdCAqICBAcmV0dXJucyB7VG9uZS5QYXJhbX0gdGhpc1xuXHQgKiAgQGV4YW1wbGVcblx0ICogLy9yYW1wIHRvIHRoZSB2YWx1ZSBlaXRoZXIgbGluZWFybHkgb3IgZXhwb25lbnRpYWxseVxuXHQgKiAvL2RlcGVuZGluZyBvbiB0aGUgXCJ1bml0c1wiIHZhbHVlIG9mIHRoZSBzaWduYWxcblx0ICogc2lnbmFsLnJhbXBUbygwLCAxMCk7XG5cdCAqICBAZXhhbXBsZVxuXHQgKiAvL3NjaGVkdWxlIGl0IHRvIHJhbXAgc3RhcnRpbmcgYXQgYSBzcGVjaWZpYyB0aW1lXG5cdCAqIHNpZ25hbC5yYW1wVG8oMCwgMTAsIDUpXG5cdCAqL1xuXHRUb25lLlBhcmFtLnByb3RvdHlwZS5yYW1wVG8gPSBmdW5jdGlvbih2YWx1ZSwgcmFtcFRpbWUsIHN0YXJ0VGltZSl7XG5cdFx0cmFtcFRpbWUgPSBUb25lLmRlZmF1bHRBcmcocmFtcFRpbWUsIDAuMSk7XG5cdFx0aWYgKHRoaXMudW5pdHMgPT09IFRvbmUuVHlwZS5GcmVxdWVuY3kgfHwgdGhpcy51bml0cyA9PT0gVG9uZS5UeXBlLkJQTSB8fCB0aGlzLnVuaXRzID09PSBUb25lLlR5cGUuRGVjaWJlbHMpe1xuXHRcdFx0dGhpcy5leHBvbmVudGlhbFJhbXBUbyh2YWx1ZSwgcmFtcFRpbWUsIHN0YXJ0VGltZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubGluZWFyUmFtcFRvKHZhbHVlLCByYW1wVGltZSwgc3RhcnRUaW1lKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vXHRBVVRPTUFUSU9OIENVUlZFIENBTENVTEFUSU9OU1xuXHQvL1x0TUlUIExpY2Vuc2UsIGNvcHlyaWdodCAoYykgMjAxNCBKb3JkYW4gU2FudGVsbFxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHQvLyBDYWxjdWxhdGVzIHRoZSB0aGUgdmFsdWUgYWxvbmcgdGhlIGN1cnZlIHByb2R1Y2VkIGJ5IHNldFRhcmdldEF0VGltZVxuXHRUb25lLlBhcmFtLnByb3RvdHlwZS5fZXhwb25lbnRpYWxBcHByb2FjaCA9IGZ1bmN0aW9uKHQwLCB2MCwgdjEsIHRpbWVDb25zdGFudCwgdCl7XG5cdFx0cmV0dXJuIHYxICsgKHYwIC0gdjEpICogTWF0aC5leHAoLSh0IC0gdDApIC8gdGltZUNvbnN0YW50KTtcblx0fTtcblxuXHQvLyBDYWxjdWxhdGVzIHRoZSB0aGUgdmFsdWUgYWxvbmcgdGhlIGN1cnZlIHByb2R1Y2VkIGJ5IGxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lXG5cdFRvbmUuUGFyYW0ucHJvdG90eXBlLl9saW5lYXJJbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKHQwLCB2MCwgdDEsIHYxLCB0KXtcblx0XHRyZXR1cm4gdjAgKyAodjEgLSB2MCkgKiAoKHQgLSB0MCkgLyAodDEgLSB0MCkpO1xuXHR9O1xuXG5cdC8vIENhbGN1bGF0ZXMgdGhlIHRoZSB2YWx1ZSBhbG9uZyB0aGUgY3VydmUgcHJvZHVjZWQgYnkgZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZVxuXHRUb25lLlBhcmFtLnByb3RvdHlwZS5fZXhwb25lbnRpYWxJbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKHQwLCB2MCwgdDEsIHYxLCB0KXtcblx0XHRyZXR1cm4gdjAgKiBNYXRoLnBvdyh2MSAvIHYwLCAodCAtIHQwKSAvICh0MSAtIHQwKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqICBDbGVhbiB1cFxuXHQgKiAgQHJldHVybnMge1RvbmUuUGFyYW19IHRoaXNcblx0ICovXG5cdFRvbmUuUGFyYW0ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpe1xuXHRcdFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5fcGFyYW0gPSBudWxsO1xuXHRcdHRoaXMuX2V2ZW50cyA9IG51bGw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0cmV0dXJuIFRvbmUuUGFyYW07XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTtBQUVBOzs7Ozs7Ozs7OztBQVVBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7QUFLQTtBQUVBOzs7OztBQUlBO0FBRUE7Ozs7O0FBSUE7QUFFQTs7Ozs7Ozs7QUFPQTtBQUVBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTs7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFBQTtBQUlBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFBQTtBQUxBO0FBWUE7Ozs7Ozs7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFBQTtBQURBO0FBZ0JBOzs7Ozs7O0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUFBO0FBREE7QUFXQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBZEE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/core/Param.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/core/Timeline.js":
/*!*************************************************!*\
  !*** ./node_modules/tone/Tone/core/Timeline.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  \"use strict\";\n  /**\n   *  @class A Timeline class for scheduling and maintaining state\n   *         along a timeline. All events must have a \"time\" property.\n   *         Internally, events are stored in time order for fast\n   *         retrieval.\n   *  @extends {Tone}\n   *  @param {Positive} [memory=Infinity] The number of previous events that are retained.\n   */\n\n  Tone.Timeline = function () {\n    var options = Tone.defaults(arguments, [\"memory\"], Tone.Timeline);\n    Tone.call(this);\n    /**\n     *  The array of scheduled timeline events\n     *  @type  {Array}\n     *  @private\n     */\n\n    this._timeline = [];\n    /**\n     *  The memory of the timeline, i.e.\n     *  how many events in the past it will retain\n     *  @type {Positive}\n     */\n\n    this.memory = options.memory;\n  };\n\n  Tone.extend(Tone.Timeline);\n  /**\n   *  the default parameters\n   *  @static\n   *  @const\n   */\n\n  Tone.Timeline.defaults = {\n    \"memory\": Infinity\n  };\n  /**\n   *  The number of items in the timeline.\n   *  @type {Number}\n   *  @memberOf Tone.Timeline#\n   *  @name length\n   *  @readOnly\n   */\n\n  Object.defineProperty(Tone.Timeline.prototype, \"length\", {\n    get: function () {\n      function get() {\n        return this._timeline.length;\n      }\n\n      return get;\n    }()\n  });\n  /**\n   *  Insert an event object onto the timeline. Events must have a \"time\" attribute.\n   *  @param  {Object}  event  The event object to insert into the\n   *                           timeline.\n   *  @returns {Tone.Timeline} this\n   */\n\n  Tone.Timeline.prototype.add = function (event) {\n    //the event needs to have a time attribute\n    if (Tone.isUndef(event.time)) {\n      throw new Error(\"Tone.Timeline: events must have a time attribute\");\n    }\n\n    event.time = event.time.valueOf();\n\n    var index = this._search(event.time);\n\n    this._timeline.splice(index + 1, 0, event); //if the length is more than the memory, remove the previous ones\n\n\n    if (this.length > this.memory) {\n      var diff = this.length - this.memory;\n\n      this._timeline.splice(0, diff);\n    }\n\n    return this;\n  };\n  /**\n   *  Remove an event from the timeline.\n   *  @param  {Object}  event  The event object to remove from the list.\n   *  @returns {Tone.Timeline} this\n   */\n\n\n  Tone.Timeline.prototype.remove = function (event) {\n    var index = this._timeline.indexOf(event);\n\n    if (index !== -1) {\n      this._timeline.splice(index, 1);\n    }\n\n    return this;\n  };\n  /**\n   *  Get the nearest event whose time is less than or equal to the given time.\n   *  @param  {Number}  time  The time to query.\n   *  @param  {String}  comparator Which value in the object to compare\n   *  @returns {Object} The event object set after that time.\n   */\n\n\n  Tone.Timeline.prototype.get = function (time, comparator) {\n    comparator = Tone.defaultArg(comparator, \"time\");\n\n    var index = this._search(time, comparator);\n\n    if (index !== -1) {\n      return this._timeline[index];\n    } else {\n      return null;\n    }\n  };\n  /**\n   *  Return the first event in the timeline without removing it\n   *  @returns {Object} The first event object\n   */\n\n\n  Tone.Timeline.prototype.peek = function () {\n    return this._timeline[0];\n  };\n  /**\n   *  Return the first event in the timeline and remove it\n   *  @returns {Object} The first event object\n   */\n\n\n  Tone.Timeline.prototype.shift = function () {\n    return this._timeline.shift();\n  };\n  /**\n   *  Get the event which is scheduled after the given time.\n   *  @param  {Number}  time  The time to query.\n   *  @param  {String}  comparator Which value in the object to compare\n   *  @returns {Object} The event object after the given time\n   */\n\n\n  Tone.Timeline.prototype.getAfter = function (time, comparator) {\n    comparator = Tone.defaultArg(comparator, \"time\");\n\n    var index = this._search(time, comparator);\n\n    if (index + 1 < this._timeline.length) {\n      return this._timeline[index + 1];\n    } else {\n      return null;\n    }\n  };\n  /**\n   *  Get the event before the event at the given time.\n   *  @param  {Number}  time  The time to query.\n   *  @param  {String}  comparator Which value in the object to compare\n   *  @returns {Object} The event object before the given time\n   */\n\n\n  Tone.Timeline.prototype.getBefore = function (time, comparator) {\n    comparator = Tone.defaultArg(comparator, \"time\");\n    var len = this._timeline.length; //if it's after the last item, return the last item\n\n    if (len > 0 && this._timeline[len - 1][comparator] < time) {\n      return this._timeline[len - 1];\n    }\n\n    var index = this._search(time, comparator);\n\n    if (index - 1 >= 0) {\n      return this._timeline[index - 1];\n    } else {\n      return null;\n    }\n  };\n  /**\n   *  Cancel events after the given time\n   *  @param  {Number}  time  The time to query.\n   *  @returns {Tone.Timeline} this\n   */\n\n\n  Tone.Timeline.prototype.cancel = function (after) {\n    if (this._timeline.length > 1) {\n      var index = this._search(after);\n\n      if (index >= 0) {\n        if (this._timeline[index].time === after) {\n          //get the first item with that time\n          for (var i = index; i >= 0; i--) {\n            if (this._timeline[i].time === after) {\n              index = i;\n            } else {\n              break;\n            }\n          }\n\n          this._timeline = this._timeline.slice(0, index);\n        } else {\n          this._timeline = this._timeline.slice(0, index + 1);\n        }\n      } else {\n        this._timeline = [];\n      }\n    } else if (this._timeline.length === 1) {\n      //the first item's time\n      if (this._timeline[0].time >= after) {\n        this._timeline = [];\n      }\n    }\n\n    return this;\n  };\n  /**\n   *  Cancel events before or equal to the given time.\n   *  @param  {Number}  time  The time to cancel before.\n   *  @returns {Tone.Timeline} this\n   */\n\n\n  Tone.Timeline.prototype.cancelBefore = function (time) {\n    var index = this._search(time);\n\n    if (index >= 0) {\n      this._timeline = this._timeline.slice(index + 1);\n    }\n\n    return this;\n  };\n  /**\n   * Returns the previous event if there is one. null otherwise\n   * @param  {Object} event The event to find the previous one of\n   * @return {Object}       The event right before the given event\n   */\n\n\n  Tone.Timeline.prototype.previousEvent = function (event) {\n    var index = this._timeline.indexOf(event);\n\n    if (index > 0) {\n      return this._timeline[index - 1];\n    } else {\n      return null;\n    }\n  };\n  /**\n   *  Does a binary search on the timeline array and returns the\n   *  nearest event index whose time is after or equal to the given time.\n   *  If a time is searched before the first index in the timeline, -1 is returned.\n   *  If the time is after the end, the index of the last item is returned.\n   *  @param  {Number}  time\n   *  @param  {String}  comparator Which value in the object to compare\n   *  @return  {Number} the index in the timeline array\n   *  @private\n   */\n\n\n  Tone.Timeline.prototype._search = function (time, comparator) {\n    if (this._timeline.length === 0) {\n      return -1;\n    }\n\n    comparator = Tone.defaultArg(comparator, \"time\");\n    var beginning = 0;\n    var len = this._timeline.length;\n    var end = len;\n\n    if (len > 0 && this._timeline[len - 1][comparator] <= time) {\n      return len - 1;\n    }\n\n    while (beginning < end) {\n      // calculate the midpoint for roughly equal partition\n      var midPoint = Math.floor(beginning + (end - beginning) / 2);\n      var event = this._timeline[midPoint];\n      var nextEvent = this._timeline[midPoint + 1];\n\n      if (event[comparator] === time) {\n        //choose the last one that has the same time\n        for (var i = midPoint; i < this._timeline.length; i++) {\n          var testEvent = this._timeline[i];\n\n          if (testEvent[comparator] === time) {\n            midPoint = i;\n          }\n        }\n\n        return midPoint;\n      } else if (event[comparator] < time && nextEvent[comparator] > time) {\n        return midPoint;\n      } else if (event[comparator] > time) {\n        //search lower\n        end = midPoint;\n      } else {\n        //search upper\n        beginning = midPoint + 1;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   *  Internal iterator. Applies extra safety checks for\n   *  removing items from the array.\n   *  @param  {Function}  callback\n   *  @param  {Number=}    lowerBound\n   *  @param  {Number=}    upperBound\n   *  @private\n   */\n\n\n  Tone.Timeline.prototype._iterate = function (callback, lowerBound, upperBound) {\n    lowerBound = Tone.defaultArg(lowerBound, 0);\n    upperBound = Tone.defaultArg(upperBound, this._timeline.length - 1);\n\n    this._timeline.slice(lowerBound, upperBound + 1).forEach(function (event) {\n      callback.call(this, event);\n    }.bind(this));\n  };\n  /**\n   *  Iterate over everything in the array\n   *  @param  {Function}  callback The callback to invoke with every item\n   *  @returns {Tone.Timeline} this\n   */\n\n\n  Tone.Timeline.prototype.forEach = function (callback) {\n    this._iterate(callback);\n\n    return this;\n  };\n  /**\n   *  Iterate over everything in the array at or before the given time.\n   *  @param  {Number}  time The time to check if items are before\n   *  @param  {Function}  callback The callback to invoke with every item\n   *  @returns {Tone.Timeline} this\n   */\n\n\n  Tone.Timeline.prototype.forEachBefore = function (time, callback) {\n    //iterate over the items in reverse so that removing an item doesn't break things\n    var upperBound = this._search(time);\n\n    if (upperBound !== -1) {\n      this._iterate(callback, 0, upperBound);\n    }\n\n    return this;\n  };\n  /**\n   *  Iterate over everything in the array after the given time.\n   *  @param  {Number}  time The time to check if items are before\n   *  @param  {Function}  callback The callback to invoke with every item\n   *  @returns {Tone.Timeline} this\n   */\n\n\n  Tone.Timeline.prototype.forEachAfter = function (time, callback) {\n    //iterate over the items in reverse so that removing an item doesn't break things\n    var lowerBound = this._search(time);\n\n    this._iterate(callback, lowerBound + 1);\n\n    return this;\n  };\n  /**\n   *  Iterate over everything in the array between the startTime and endTime. \n   *  The timerange is inclusive of the startTime, but exclusive of the endTime. \n   *  range = [startTime, endTime). \n   *  @param  {Number}  startTime The time to check if items are before\n   *  @param  {Number}  endTime The end of the test interval. \n   *  @param  {Function}  callback The callback to invoke with every item\n   *  @returns {Tone.Timeline} this\n   */\n\n\n  Tone.Timeline.prototype.forEachBetween = function (startTime, endTime, callback) {\n    var lowerBound = this._search(startTime);\n\n    var upperBound = this._search(endTime);\n\n    if (lowerBound !== -1 && upperBound !== -1) {\n      if (this._timeline[lowerBound].time !== startTime) {\n        lowerBound += 1;\n      } //exclusive of the end time\n\n\n      if (this._timeline[upperBound].time === endTime) {\n        upperBound -= 1;\n      }\n\n      this._iterate(callback, lowerBound, upperBound);\n    } else if (lowerBound === -1) {\n      this._iterate(callback, 0, upperBound);\n    }\n\n    return this;\n  };\n  /**\n   *  Iterate over everything in the array at or after the given time. Similar to\n   *  forEachAfter, but includes the item(s) at the given time.\n   *  @param  {Number}  time The time to check if items are before\n   *  @param  {Function}  callback The callback to invoke with every item\n   *  @returns {Tone.Timeline} this\n   */\n\n\n  Tone.Timeline.prototype.forEachFrom = function (time, callback) {\n    //iterate over the items in reverse so that removing an item doesn't break things\n    var lowerBound = this._search(time); //work backwards until the event time is less than time\n\n\n    while (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n      lowerBound--;\n    }\n\n    this._iterate(callback, lowerBound + 1);\n\n    return this;\n  };\n  /**\n   *  Iterate over everything in the array at the given time\n   *  @param  {Number}  time The time to check if items are before\n   *  @param  {Function}  callback The callback to invoke with every item\n   *  @returns {Tone.Timeline} this\n   */\n\n\n  Tone.Timeline.prototype.forEachAtTime = function (time, callback) {\n    //iterate over the items in reverse so that removing an item doesn't break things\n    var upperBound = this._search(time);\n\n    if (upperBound !== -1) {\n      this._iterate(function (event) {\n        if (event.time === time) {\n          callback.call(this, event);\n        }\n      }, 0, upperBound);\n    }\n\n    return this;\n  };\n  /**\n   *  Clean up.\n   *  @return  {Tone.Timeline}  this\n   */\n\n\n  Tone.Timeline.prototype.dispose = function () {\n    Tone.prototype.dispose.call(this);\n    this._timeline = null;\n    return this;\n  };\n\n  return Tone.Timeline;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvVGltZWxpbmUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvVGltZWxpbmUuanM/MmVmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoW1wiVG9uZS9jb3JlL1RvbmVcIl0sIGZ1bmN0aW9uKFRvbmUpe1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiAgQGNsYXNzIEEgVGltZWxpbmUgY2xhc3MgZm9yIHNjaGVkdWxpbmcgYW5kIG1haW50YWluaW5nIHN0YXRlXG5cdCAqICAgICAgICAgYWxvbmcgYSB0aW1lbGluZS4gQWxsIGV2ZW50cyBtdXN0IGhhdmUgYSBcInRpbWVcIiBwcm9wZXJ0eS5cblx0ICogICAgICAgICBJbnRlcm5hbGx5LCBldmVudHMgYXJlIHN0b3JlZCBpbiB0aW1lIG9yZGVyIGZvciBmYXN0XG5cdCAqICAgICAgICAgcmV0cmlldmFsLlxuXHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdCAqICBAcGFyYW0ge1Bvc2l0aXZlfSBbbWVtb3J5PUluZmluaXR5XSBUaGUgbnVtYmVyIG9mIHByZXZpb3VzIGV2ZW50cyB0aGF0IGFyZSByZXRhaW5lZC5cblx0ICovXG5cdFRvbmUuVGltZWxpbmUgPSBmdW5jdGlvbigpe1xuXG5cdFx0dmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1wibWVtb3J5XCJdLCBUb25lLlRpbWVsaW5lKTtcblx0XHRUb25lLmNhbGwodGhpcyk7XG5cblx0XHQvKipcblx0XHQgKiAgVGhlIGFycmF5IG9mIHNjaGVkdWxlZCB0aW1lbGluZSBldmVudHNcblx0XHQgKiAgQHR5cGUgIHtBcnJheX1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl90aW1lbGluZSA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogIFRoZSBtZW1vcnkgb2YgdGhlIHRpbWVsaW5lLCBpLmUuXG5cdFx0ICogIGhvdyBtYW55IGV2ZW50cyBpbiB0aGUgcGFzdCBpdCB3aWxsIHJldGFpblxuXHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0ICovXG5cdFx0dGhpcy5tZW1vcnkgPSBvcHRpb25zLm1lbW9yeTtcblx0fTtcblxuXHRUb25lLmV4dGVuZChUb25lLlRpbWVsaW5lKTtcblxuXHQvKipcblx0ICogIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcblx0ICogIEBzdGF0aWNcblx0ICogIEBjb25zdFxuXHQgKi9cblx0VG9uZS5UaW1lbGluZS5kZWZhdWx0cyA9IHtcblx0XHRcIm1lbW9yeVwiIDogSW5maW5pdHlcblx0fTtcblxuXHQvKipcblx0ICogIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHRpbWVsaW5lLlxuXHQgKiAgQHR5cGUge051bWJlcn1cblx0ICogIEBtZW1iZXJPZiBUb25lLlRpbWVsaW5lI1xuXHQgKiAgQG5hbWUgbGVuZ3RoXG5cdCAqICBAcmVhZE9ubHlcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRpbWVsaW5lLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdGltZWxpbmUubGVuZ3RoO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqICBJbnNlcnQgYW4gZXZlbnQgb2JqZWN0IG9udG8gdGhlIHRpbWVsaW5lLiBFdmVudHMgbXVzdCBoYXZlIGEgXCJ0aW1lXCIgYXR0cmlidXRlLlxuXHQgKiAgQHBhcmFtICB7T2JqZWN0fSAgZXZlbnQgIFRoZSBldmVudCBvYmplY3QgdG8gaW5zZXJ0IGludG8gdGhlXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuXG5cdCAqICBAcmV0dXJucyB7VG9uZS5UaW1lbGluZX0gdGhpc1xuXHQgKi9cblx0VG9uZS5UaW1lbGluZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZXZlbnQpe1xuXHRcdC8vdGhlIGV2ZW50IG5lZWRzIHRvIGhhdmUgYSB0aW1lIGF0dHJpYnV0ZVxuXHRcdGlmIChUb25lLmlzVW5kZWYoZXZlbnQudGltZSkpe1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVG9uZS5UaW1lbGluZTogZXZlbnRzIG11c3QgaGF2ZSBhIHRpbWUgYXR0cmlidXRlXCIpO1xuXHRcdH1cblx0XHRldmVudC50aW1lID0gZXZlbnQudGltZS52YWx1ZU9mKCk7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5fc2VhcmNoKGV2ZW50LnRpbWUpO1xuXHRcdHRoaXMuX3RpbWVsaW5lLnNwbGljZShpbmRleCArIDEsIDAsIGV2ZW50KTtcblx0XHQvL2lmIHRoZSBsZW5ndGggaXMgbW9yZSB0aGFuIHRoZSBtZW1vcnksIHJlbW92ZSB0aGUgcHJldmlvdXMgb25lc1xuXHRcdGlmICh0aGlzLmxlbmd0aCA+IHRoaXMubWVtb3J5KXtcblx0XHRcdHZhciBkaWZmID0gdGhpcy5sZW5ndGggLSB0aGlzLm1lbW9yeTtcblx0XHRcdHRoaXMuX3RpbWVsaW5lLnNwbGljZSgwLCBkaWZmKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqICBSZW1vdmUgYW4gZXZlbnQgZnJvbSB0aGUgdGltZWxpbmUuXG5cdCAqICBAcGFyYW0gIHtPYmplY3R9ICBldmVudCAgVGhlIGV2ZW50IG9iamVjdCB0byByZW1vdmUgZnJvbSB0aGUgbGlzdC5cblx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lfSB0aGlzXG5cdCAqL1xuXHRUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihldmVudCl7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5fdGltZWxpbmUuaW5kZXhPZihldmVudCk7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSl7XG5cdFx0XHR0aGlzLl90aW1lbGluZS5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogIEdldCB0aGUgbmVhcmVzdCBldmVudCB3aG9zZSB0aW1lIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gdGltZS5cblx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgIFRoZSB0aW1lIHRvIHF1ZXJ5LlxuXHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgY29tcGFyYXRvciBXaGljaCB2YWx1ZSBpbiB0aGUgb2JqZWN0IHRvIGNvbXBhcmVcblx0ICogIEByZXR1cm5zIHtPYmplY3R9IFRoZSBldmVudCBvYmplY3Qgc2V0IGFmdGVyIHRoYXQgdGltZS5cblx0ICovXG5cdFRvbmUuVGltZWxpbmUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHRpbWUsIGNvbXBhcmF0b3Ipe1xuXHRcdGNvbXBhcmF0b3IgPSBUb25lLmRlZmF1bHRBcmcoY29tcGFyYXRvciwgXCJ0aW1lXCIpO1xuXHRcdHZhciBpbmRleCA9IHRoaXMuX3NlYXJjaCh0aW1lLCBjb21wYXJhdG9yKTtcblx0XHRpZiAoaW5kZXggIT09IC0xKXtcblx0XHRcdHJldHVybiB0aGlzLl90aW1lbGluZVtpbmRleF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogIFJldHVybiB0aGUgZmlyc3QgZXZlbnQgaW4gdGhlIHRpbWVsaW5lIHdpdGhvdXQgcmVtb3ZpbmcgaXRcblx0ICogIEByZXR1cm5zIHtPYmplY3R9IFRoZSBmaXJzdCBldmVudCBvYmplY3Rcblx0ICovXG5cdFRvbmUuVGltZWxpbmUucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpe1xuXHRcdHJldHVybiB0aGlzLl90aW1lbGluZVswXTtcblx0fTtcblxuXHQvKipcblx0ICogIFJldHVybiB0aGUgZmlyc3QgZXZlbnQgaW4gdGhlIHRpbWVsaW5lIGFuZCByZW1vdmUgaXRcblx0ICogIEByZXR1cm5zIHtPYmplY3R9IFRoZSBmaXJzdCBldmVudCBvYmplY3Rcblx0ICovXG5cdFRvbmUuVGltZWxpbmUucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gdGhpcy5fdGltZWxpbmUuc2hpZnQoKTtcblx0fTtcblxuXHQvKipcblx0ICogIEdldCB0aGUgZXZlbnQgd2hpY2ggaXMgc2NoZWR1bGVkIGFmdGVyIHRoZSBnaXZlbiB0aW1lLlxuXHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdG8gcXVlcnkuXG5cdCAqICBAcGFyYW0gIHtTdHJpbmd9ICBjb21wYXJhdG9yIFdoaWNoIHZhbHVlIGluIHRoZSBvYmplY3QgdG8gY29tcGFyZVxuXHQgKiAgQHJldHVybnMge09iamVjdH0gVGhlIGV2ZW50IG9iamVjdCBhZnRlciB0aGUgZ2l2ZW4gdGltZVxuXHQgKi9cblx0VG9uZS5UaW1lbGluZS5wcm90b3R5cGUuZ2V0QWZ0ZXIgPSBmdW5jdGlvbih0aW1lLCBjb21wYXJhdG9yKXtcblx0XHRjb21wYXJhdG9yID0gVG9uZS5kZWZhdWx0QXJnKGNvbXBhcmF0b3IsIFwidGltZVwiKTtcblx0XHR2YXIgaW5kZXggPSB0aGlzLl9zZWFyY2godGltZSwgY29tcGFyYXRvcik7XG5cdFx0aWYgKGluZGV4ICsgMSA8IHRoaXMuX3RpbWVsaW5lLmxlbmd0aCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdGltZWxpbmVbaW5kZXggKyAxXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiAgR2V0IHRoZSBldmVudCBiZWZvcmUgdGhlIGV2ZW50IGF0IHRoZSBnaXZlbiB0aW1lLlxuXHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdG8gcXVlcnkuXG5cdCAqICBAcGFyYW0gIHtTdHJpbmd9ICBjb21wYXJhdG9yIFdoaWNoIHZhbHVlIGluIHRoZSBvYmplY3QgdG8gY29tcGFyZVxuXHQgKiAgQHJldHVybnMge09iamVjdH0gVGhlIGV2ZW50IG9iamVjdCBiZWZvcmUgdGhlIGdpdmVuIHRpbWVcblx0ICovXG5cdFRvbmUuVGltZWxpbmUucHJvdG90eXBlLmdldEJlZm9yZSA9IGZ1bmN0aW9uKHRpbWUsIGNvbXBhcmF0b3Ipe1xuXHRcdGNvbXBhcmF0b3IgPSBUb25lLmRlZmF1bHRBcmcoY29tcGFyYXRvciwgXCJ0aW1lXCIpO1xuXHRcdHZhciBsZW4gPSB0aGlzLl90aW1lbGluZS5sZW5ndGg7XG5cdFx0Ly9pZiBpdCdzIGFmdGVyIHRoZSBsYXN0IGl0ZW0sIHJldHVybiB0aGUgbGFzdCBpdGVtXG5cdFx0aWYgKGxlbiA+IDAgJiYgdGhpcy5fdGltZWxpbmVbbGVuIC0gMV1bY29tcGFyYXRvcl0gPCB0aW1lKXtcblx0XHRcdHJldHVybiB0aGlzLl90aW1lbGluZVtsZW4gLSAxXTtcblx0XHR9XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5fc2VhcmNoKHRpbWUsIGNvbXBhcmF0b3IpO1xuXHRcdGlmIChpbmRleCAtIDEgPj0gMCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdGltZWxpbmVbaW5kZXggLSAxXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiAgQ2FuY2VsIGV2ZW50cyBhZnRlciB0aGUgZ2l2ZW4gdGltZVxuXHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdG8gcXVlcnkuXG5cdCAqICBAcmV0dXJucyB7VG9uZS5UaW1lbGluZX0gdGhpc1xuXHQgKi9cblx0VG9uZS5UaW1lbGluZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24oYWZ0ZXIpe1xuXHRcdGlmICh0aGlzLl90aW1lbGluZS5sZW5ndGggPiAxKXtcblx0XHRcdHZhciBpbmRleCA9IHRoaXMuX3NlYXJjaChhZnRlcik7XG5cdFx0XHRpZiAoaW5kZXggPj0gMCl7XG5cdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZVtpbmRleF0udGltZSA9PT0gYWZ0ZXIpe1xuXHRcdFx0XHRcdC8vZ2V0IHRoZSBmaXJzdCBpdGVtIHdpdGggdGhhdCB0aW1lXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IGluZGV4OyBpID49IDA7IGktLSl7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmVbaV0udGltZSA9PT0gYWZ0ZXIpe1xuXHRcdFx0XHRcdFx0XHRpbmRleCA9IGk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fdGltZWxpbmUgPSB0aGlzLl90aW1lbGluZS5zbGljZSgwLCBpbmRleCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZWxpbmUgPSB0aGlzLl90aW1lbGluZS5zbGljZSgwLCBpbmRleCArIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl90aW1lbGluZSA9IFtdO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodGhpcy5fdGltZWxpbmUubGVuZ3RoID09PSAxKXtcblx0XHRcdC8vdGhlIGZpcnN0IGl0ZW0ncyB0aW1lXG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmVbMF0udGltZSA+PSBhZnRlcil7XG5cdFx0XHRcdHRoaXMuX3RpbWVsaW5lID0gW107XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgQ2FuY2VsIGV2ZW50cyBiZWZvcmUgb3IgZXF1YWwgdG8gdGhlIGdpdmVuIHRpbWUuXG5cdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSB0byBjYW5jZWwgYmVmb3JlLlxuXHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmV9IHRoaXNcblx0ICovXG5cdFRvbmUuVGltZWxpbmUucHJvdG90eXBlLmNhbmNlbEJlZm9yZSA9IGZ1bmN0aW9uKHRpbWUpe1xuXHRcdHZhciBpbmRleCA9IHRoaXMuX3NlYXJjaCh0aW1lKTtcblx0XHRpZiAoaW5kZXggPj0gMCl7XG5cdFx0XHR0aGlzLl90aW1lbGluZSA9IHRoaXMuX3RpbWVsaW5lLnNsaWNlKGluZGV4ICsgMSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBwcmV2aW91cyBldmVudCBpZiB0aGVyZSBpcyBvbmUuIG51bGwgb3RoZXJ3aXNlXG5cdCAqIEBwYXJhbSAge09iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHRvIGZpbmQgdGhlIHByZXZpb3VzIG9uZSBvZlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIFRoZSBldmVudCByaWdodCBiZWZvcmUgdGhlIGdpdmVuIGV2ZW50XG5cdCAqL1xuXHRUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5wcmV2aW91c0V2ZW50ID0gZnVuY3Rpb24oZXZlbnQpe1xuXHRcdHZhciBpbmRleCA9IHRoaXMuX3RpbWVsaW5lLmluZGV4T2YoZXZlbnQpO1xuXHRcdGlmIChpbmRleCA+IDApe1xuXHRcdFx0cmV0dXJuIHRoaXMuX3RpbWVsaW5lW2luZGV4LTFdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqICBEb2VzIGEgYmluYXJ5IHNlYXJjaCBvbiB0aGUgdGltZWxpbmUgYXJyYXkgYW5kIHJldHVybnMgdGhlXG5cdCAqICBuZWFyZXN0IGV2ZW50IGluZGV4IHdob3NlIHRpbWUgaXMgYWZ0ZXIgb3IgZXF1YWwgdG8gdGhlIGdpdmVuIHRpbWUuXG5cdCAqICBJZiBhIHRpbWUgaXMgc2VhcmNoZWQgYmVmb3JlIHRoZSBmaXJzdCBpbmRleCBpbiB0aGUgdGltZWxpbmUsIC0xIGlzIHJldHVybmVkLlxuXHQgKiAgSWYgdGhlIHRpbWUgaXMgYWZ0ZXIgdGhlIGVuZCwgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGl0ZW0gaXMgcmV0dXJuZWQuXG5cdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lXG5cdCAqICBAcGFyYW0gIHtTdHJpbmd9ICBjb21wYXJhdG9yIFdoaWNoIHZhbHVlIGluIHRoZSBvYmplY3QgdG8gY29tcGFyZVxuXHQgKiAgQHJldHVybiAge051bWJlcn0gdGhlIGluZGV4IGluIHRoZSB0aW1lbGluZSBhcnJheVxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdFRvbmUuVGltZWxpbmUucHJvdG90eXBlLl9zZWFyY2ggPSBmdW5jdGlvbih0aW1lLCBjb21wYXJhdG9yKXtcblx0XHRpZiAodGhpcy5fdGltZWxpbmUubGVuZ3RoID09PSAwKXtcblx0XHRcdHJldHVybiAtMTtcblx0XHR9XG5cdFx0Y29tcGFyYXRvciA9IFRvbmUuZGVmYXVsdEFyZyhjb21wYXJhdG9yLCBcInRpbWVcIik7XG5cdFx0dmFyIGJlZ2lubmluZyA9IDA7XG5cdFx0dmFyIGxlbiA9IHRoaXMuX3RpbWVsaW5lLmxlbmd0aDtcblx0XHR2YXIgZW5kID0gbGVuO1xuXHRcdGlmIChsZW4gPiAwICYmIHRoaXMuX3RpbWVsaW5lW2xlbiAtIDFdW2NvbXBhcmF0b3JdIDw9IHRpbWUpe1xuXHRcdFx0cmV0dXJuIGxlbiAtIDE7XG5cdFx0fVxuXHRcdHdoaWxlIChiZWdpbm5pbmcgPCBlbmQpe1xuXHRcdFx0Ly8gY2FsY3VsYXRlIHRoZSBtaWRwb2ludCBmb3Igcm91Z2hseSBlcXVhbCBwYXJ0aXRpb25cblx0XHRcdHZhciBtaWRQb2ludCA9IE1hdGguZmxvb3IoYmVnaW5uaW5nICsgKGVuZCAtIGJlZ2lubmluZykgLyAyKTtcblx0XHRcdHZhciBldmVudCA9IHRoaXMuX3RpbWVsaW5lW21pZFBvaW50XTtcblx0XHRcdHZhciBuZXh0RXZlbnQgPSB0aGlzLl90aW1lbGluZVttaWRQb2ludCArIDFdO1xuXHRcdFx0aWYgKGV2ZW50W2NvbXBhcmF0b3JdID09PSB0aW1lKXtcblx0XHRcdFx0Ly9jaG9vc2UgdGhlIGxhc3Qgb25lIHRoYXQgaGFzIHRoZSBzYW1lIHRpbWVcblx0XHRcdFx0Zm9yICh2YXIgaSA9IG1pZFBvaW50OyBpIDwgdGhpcy5fdGltZWxpbmUubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRcdHZhciB0ZXN0RXZlbnQgPSB0aGlzLl90aW1lbGluZVtpXTtcblx0XHRcdFx0XHRpZiAodGVzdEV2ZW50W2NvbXBhcmF0b3JdID09PSB0aW1lKXtcblx0XHRcdFx0XHRcdG1pZFBvaW50ID0gaTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1pZFBvaW50O1xuXHRcdFx0fSBlbHNlIGlmIChldmVudFtjb21wYXJhdG9yXSA8IHRpbWUgJiYgbmV4dEV2ZW50W2NvbXBhcmF0b3JdID4gdGltZSl7XG5cdFx0XHRcdHJldHVybiBtaWRQb2ludDtcblx0XHRcdH0gZWxzZSBpZiAoZXZlbnRbY29tcGFyYXRvcl0gPiB0aW1lKXtcblx0XHRcdFx0Ly9zZWFyY2ggbG93ZXJcblx0XHRcdFx0ZW5kID0gbWlkUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvL3NlYXJjaCB1cHBlclxuXHRcdFx0XHRiZWdpbm5pbmcgPSBtaWRQb2ludCArIDE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fTtcblxuXHQvKipcblx0ICogIEludGVybmFsIGl0ZXJhdG9yLiBBcHBsaWVzIGV4dHJhIHNhZmV0eSBjaGVja3MgZm9yXG5cdCAqICByZW1vdmluZyBpdGVtcyBmcm9tIHRoZSBhcnJheS5cblx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2tcblx0ICogIEBwYXJhbSAge051bWJlcj19ICAgIGxvd2VyQm91bmRcblx0ICogIEBwYXJhbSAge051bWJlcj19ICAgIHVwcGVyQm91bmRcblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5faXRlcmF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBsb3dlckJvdW5kLCB1cHBlckJvdW5kKXtcblx0XHRsb3dlckJvdW5kID0gVG9uZS5kZWZhdWx0QXJnKGxvd2VyQm91bmQsIDApO1xuXHRcdHVwcGVyQm91bmQgPSBUb25lLmRlZmF1bHRBcmcodXBwZXJCb3VuZCwgdGhpcy5fdGltZWxpbmUubGVuZ3RoLTEpO1xuXHRcdHRoaXMuX3RpbWVsaW5lLnNsaWNlKGxvd2VyQm91bmQsIHVwcGVyQm91bmQrMSkuZm9yRWFjaChmdW5jdGlvbihldmVudCl7XG5cdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIGV2ZW50KTtcblx0XHR9LmJpbmQodGhpcykpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgSXRlcmF0ZSBvdmVyIGV2ZXJ5dGhpbmcgaW4gdGhlIGFycmF5XG5cdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBldmVyeSBpdGVtXG5cdCAqICBAcmV0dXJucyB7VG9uZS5UaW1lbGluZX0gdGhpc1xuXHQgKi9cblx0VG9uZS5UaW1lbGluZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrKXtcblx0XHR0aGlzLl9pdGVyYXRlKGNhbGxiYWNrKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogIEl0ZXJhdGUgb3ZlciBldmVyeXRoaW5nIGluIHRoZSBhcnJheSBhdCBvciBiZWZvcmUgdGhlIGdpdmVuIHRpbWUuXG5cdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lIFRoZSB0aW1lIHRvIGNoZWNrIGlmIGl0ZW1zIGFyZSBiZWZvcmVcblx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIGV2ZXJ5IGl0ZW1cblx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lfSB0aGlzXG5cdCAqL1xuXHRUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoQmVmb3JlID0gZnVuY3Rpb24odGltZSwgY2FsbGJhY2spe1xuXHRcdC8vaXRlcmF0ZSBvdmVyIHRoZSBpdGVtcyBpbiByZXZlcnNlIHNvIHRoYXQgcmVtb3ZpbmcgYW4gaXRlbSBkb2Vzbid0IGJyZWFrIHRoaW5nc1xuXHRcdHZhciB1cHBlckJvdW5kID0gdGhpcy5fc2VhcmNoKHRpbWUpO1xuXHRcdGlmICh1cHBlckJvdW5kICE9PSAtMSl7XG5cdFx0XHR0aGlzLl9pdGVyYXRlKGNhbGxiYWNrLCAwLCB1cHBlckJvdW5kKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqICBJdGVyYXRlIG92ZXIgZXZlcnl0aGluZyBpbiB0aGUgYXJyYXkgYWZ0ZXIgdGhlIGdpdmVuIHRpbWUuXG5cdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lIFRoZSB0aW1lIHRvIGNoZWNrIGlmIGl0ZW1zIGFyZSBiZWZvcmVcblx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIGV2ZXJ5IGl0ZW1cblx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lfSB0aGlzXG5cdCAqL1xuXHRUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoQWZ0ZXIgPSBmdW5jdGlvbih0aW1lLCBjYWxsYmFjayl7XG5cdFx0Ly9pdGVyYXRlIG92ZXIgdGhlIGl0ZW1zIGluIHJldmVyc2Ugc28gdGhhdCByZW1vdmluZyBhbiBpdGVtIGRvZXNuJ3QgYnJlYWsgdGhpbmdzXG5cdFx0dmFyIGxvd2VyQm91bmQgPSB0aGlzLl9zZWFyY2godGltZSk7XG5cdFx0dGhpcy5faXRlcmF0ZShjYWxsYmFjaywgbG93ZXJCb3VuZCArIDEpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgSXRlcmF0ZSBvdmVyIGV2ZXJ5dGhpbmcgaW4gdGhlIGFycmF5IGJldHdlZW4gdGhlIHN0YXJ0VGltZSBhbmQgZW5kVGltZS4gXG5cdCAqICBUaGUgdGltZXJhbmdlIGlzIGluY2x1c2l2ZSBvZiB0aGUgc3RhcnRUaW1lLCBidXQgZXhjbHVzaXZlIG9mIHRoZSBlbmRUaW1lLiBcblx0ICogIHJhbmdlID0gW3N0YXJ0VGltZSwgZW5kVGltZSkuIFxuXHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgc3RhcnRUaW1lIFRoZSB0aW1lIHRvIGNoZWNrIGlmIGl0ZW1zIGFyZSBiZWZvcmVcblx0ICogIEBwYXJhbSAge051bWJlcn0gIGVuZFRpbWUgVGhlIGVuZCBvZiB0aGUgdGVzdCBpbnRlcnZhbC4gXG5cdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBldmVyeSBpdGVtXG5cdCAqICBAcmV0dXJucyB7VG9uZS5UaW1lbGluZX0gdGhpc1xuXHQgKi9cblx0VG9uZS5UaW1lbGluZS5wcm90b3R5cGUuZm9yRWFjaEJldHdlZW4gPSBmdW5jdGlvbihzdGFydFRpbWUsIGVuZFRpbWUsIGNhbGxiYWNrKXtcblx0XHR2YXIgbG93ZXJCb3VuZCA9IHRoaXMuX3NlYXJjaChzdGFydFRpbWUpO1xuXHRcdHZhciB1cHBlckJvdW5kID0gdGhpcy5fc2VhcmNoKGVuZFRpbWUpO1xuXHRcdGlmIChsb3dlckJvdW5kICE9PSAtMSAmJiB1cHBlckJvdW5kICE9PSAtMSl7XG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmVbbG93ZXJCb3VuZF0udGltZSAhPT0gc3RhcnRUaW1lKXtcblx0XHRcdFx0bG93ZXJCb3VuZCArPSAxO1xuXHRcdFx0fVxuXHRcdFx0Ly9leGNsdXNpdmUgb2YgdGhlIGVuZCB0aW1lXG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmVbdXBwZXJCb3VuZF0udGltZSA9PT0gZW5kVGltZSl7XG5cdFx0XHRcdHVwcGVyQm91bmQgLT0gMTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2l0ZXJhdGUoY2FsbGJhY2ssIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpO1xuXHRcdH0gZWxzZSBpZiAobG93ZXJCb3VuZCA9PT0gLTEpe1xuXHRcdFx0dGhpcy5faXRlcmF0ZShjYWxsYmFjaywgMCwgdXBwZXJCb3VuZCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgSXRlcmF0ZSBvdmVyIGV2ZXJ5dGhpbmcgaW4gdGhlIGFycmF5IGF0IG9yIGFmdGVyIHRoZSBnaXZlbiB0aW1lLiBTaW1pbGFyIHRvXG5cdCAqICBmb3JFYWNoQWZ0ZXIsIGJ1dCBpbmNsdWRlcyB0aGUgaXRlbShzKSBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgVGhlIHRpbWUgdG8gY2hlY2sgaWYgaXRlbXMgYXJlIGJlZm9yZVxuXHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZXZlcnkgaXRlbVxuXHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmV9IHRoaXNcblx0ICovXG5cdFRvbmUuVGltZWxpbmUucHJvdG90eXBlLmZvckVhY2hGcm9tID0gZnVuY3Rpb24odGltZSwgY2FsbGJhY2spe1xuXHRcdC8vaXRlcmF0ZSBvdmVyIHRoZSBpdGVtcyBpbiByZXZlcnNlIHNvIHRoYXQgcmVtb3ZpbmcgYW4gaXRlbSBkb2Vzbid0IGJyZWFrIHRoaW5nc1xuXHRcdHZhciBsb3dlckJvdW5kID0gdGhpcy5fc2VhcmNoKHRpbWUpO1xuXHRcdC8vd29yayBiYWNrd2FyZHMgdW50aWwgdGhlIGV2ZW50IHRpbWUgaXMgbGVzcyB0aGFuIHRpbWVcblx0XHR3aGlsZSAobG93ZXJCb3VuZCA+PSAwICYmIHRoaXMuX3RpbWVsaW5lW2xvd2VyQm91bmRdLnRpbWUgPj0gdGltZSl7XG5cdFx0XHRsb3dlckJvdW5kLS07XG5cdFx0fVxuXHRcdHRoaXMuX2l0ZXJhdGUoY2FsbGJhY2ssIGxvd2VyQm91bmQgKyAxKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogIEl0ZXJhdGUgb3ZlciBldmVyeXRoaW5nIGluIHRoZSBhcnJheSBhdCB0aGUgZ2l2ZW4gdGltZVxuXHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSBUaGUgdGltZSB0byBjaGVjayBpZiBpdGVtcyBhcmUgYmVmb3JlXG5cdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBldmVyeSBpdGVtXG5cdCAqICBAcmV0dXJucyB7VG9uZS5UaW1lbGluZX0gdGhpc1xuXHQgKi9cblx0VG9uZS5UaW1lbGluZS5wcm90b3R5cGUuZm9yRWFjaEF0VGltZSA9IGZ1bmN0aW9uKHRpbWUsIGNhbGxiYWNrKXtcblx0XHQvL2l0ZXJhdGUgb3ZlciB0aGUgaXRlbXMgaW4gcmV2ZXJzZSBzbyB0aGF0IHJlbW92aW5nIGFuIGl0ZW0gZG9lc24ndCBicmVhayB0aGluZ3Ncblx0XHR2YXIgdXBwZXJCb3VuZCA9IHRoaXMuX3NlYXJjaCh0aW1lKTtcblx0XHRpZiAodXBwZXJCb3VuZCAhPT0gLTEpe1xuXHRcdFx0dGhpcy5faXRlcmF0ZShmdW5jdGlvbihldmVudCl7XG5cdFx0XHRcdGlmIChldmVudC50aW1lID09PSB0aW1lKXtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgMCwgdXBwZXJCb3VuZCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgQ2xlYW4gdXAuXG5cdCAqICBAcmV0dXJuICB7VG9uZS5UaW1lbGluZX0gIHRoaXNcblx0ICovXG5cdFRvbmUuVGltZWxpbmUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpe1xuXHRcdFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0XHR0aGlzLl90aW1lbGluZSA9IG51bGw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0cmV0dXJuIFRvbmUuVGltZWxpbmU7XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTtBQUVBOzs7Ozs7Ozs7QUFRQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQURBO0FBSUE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQURBO0FBTUE7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/core/Timeline.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/core/TimelineState.js":
/*!******************************************************!*\
  !*** ./node_modules/tone/Tone/core/TimelineState.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/core/Timeline */ \"./node_modules/tone/Tone/core/Timeline.js\"), __webpack_require__(/*! Tone/type/Type */ \"./node_modules/tone/Tone/type/Type.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  \"use strict\";\n  /**\n   *  @class  A Timeline State. Provides the methods: <code>setStateAtTime(\"state\", time)</code>\n   *          and <code>getValueAtTime(time)</code>.\n   *\n   *  @extends {Tone.Timeline}\n   *  @param {String} initial The initial state of the TimelineState. \n   *                          Defaults to <code>undefined</code>\n   */\n\n  Tone.TimelineState = function (initial) {\n    Tone.Timeline.call(this);\n    /**\n     *  The initial state\n     *  @private\n     *  @type {String}\n     */\n\n    this._initial = initial;\n  };\n\n  Tone.extend(Tone.TimelineState, Tone.Timeline);\n  /**\n   *  Returns the scheduled state scheduled before or at\n   *  the given time.\n   *  @param  {Number}  time  The time to query.\n   *  @return  {String}  The name of the state input in setStateAtTime.\n   */\n\n  Tone.TimelineState.prototype.getValueAtTime = function (time) {\n    var event = this.get(time);\n\n    if (event !== null) {\n      return event.state;\n    } else {\n      return this._initial;\n    }\n  };\n  /**\n   *  Add a state to the timeline.\n   *  @param  {String}  state The name of the state to set.\n   *  @param  {Number}  time  The time to query.\n   *  @returns {Tone.TimelineState} this\n   */\n\n\n  Tone.TimelineState.prototype.setStateAtTime = function (state, time) {\n    //all state changes need to be >= the previous state time\n    //TODO throw error if time < the previous event time\n    this.add({\n      \"state\": state,\n      \"time\": time\n    });\n    return this;\n  };\n  /**\n   *  Return the event before the time with the given state\n   *  @param {Tone.State} state The state to look for\n   *  @param  {Time}  time  When to check before\t\t\t\n   *  @return  {Object}  The event with the given state before the time\n   */\n\n\n  Tone.TimelineState.prototype.getLastState = function (state, time) {\n    time = this.toSeconds(time);\n\n    var index = this._search(time);\n\n    for (var i = index; i >= 0; i--) {\n      var event = this._timeline[i];\n\n      if (event.state === state) {\n        return event;\n      }\n    }\n  };\n  /**\n   *  Return the event after the time with the given state\n   *  @param {Tone.State} state The state to look for\n   *  @param  {Time}  time  When to check from\n   *  @return  {Object}  The event with the given state after the time\n   */\n\n\n  Tone.TimelineState.prototype.getNextState = function (state, time) {\n    time = this.toSeconds(time);\n\n    var index = this._search(time);\n\n    if (index !== -1) {\n      for (var i = index; i < this._timeline.length; i++) {\n        var event = this._timeline[i];\n\n        if (event.state === state) {\n          return event;\n        }\n      }\n    }\n  };\n\n  return Tone.TimelineState;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvVGltZWxpbmVTdGF0ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90b25lL1RvbmUvY29yZS9UaW1lbGluZVN0YXRlLmpzPzliNmIiXSwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFtcIlRvbmUvY29yZS9Ub25lXCIsIFwiVG9uZS9jb3JlL1RpbWVsaW5lXCIsIFwiVG9uZS90eXBlL1R5cGVcIl0sIGZ1bmN0aW9uKFRvbmUpe1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiAgQGNsYXNzICBBIFRpbWVsaW5lIFN0YXRlLiBQcm92aWRlcyB0aGUgbWV0aG9kczogPGNvZGU+c2V0U3RhdGVBdFRpbWUoXCJzdGF0ZVwiLCB0aW1lKTwvY29kZT5cblx0ICogICAgICAgICAgYW5kIDxjb2RlPmdldFZhbHVlQXRUaW1lKHRpbWUpPC9jb2RlPi5cblx0ICpcblx0ICogIEBleHRlbmRzIHtUb25lLlRpbWVsaW5lfVxuXHQgKiAgQHBhcmFtIHtTdHJpbmd9IGluaXRpYWwgVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIFRpbWVsaW5lU3RhdGUuIFxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gPGNvZGU+dW5kZWZpbmVkPC9jb2RlPlxuXHQgKi9cblx0VG9uZS5UaW1lbGluZVN0YXRlID0gZnVuY3Rpb24oaW5pdGlhbCl7XG5cblx0XHRUb25lLlRpbWVsaW5lLmNhbGwodGhpcyk7XG5cblx0XHQvKipcblx0XHQgKiAgVGhlIGluaXRpYWwgc3RhdGVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHQgKi9cblx0XHR0aGlzLl9pbml0aWFsID0gaW5pdGlhbDtcblx0fTtcblxuXHRUb25lLmV4dGVuZChUb25lLlRpbWVsaW5lU3RhdGUsIFRvbmUuVGltZWxpbmUpO1xuXG5cdC8qKlxuXHQgKiAgUmV0dXJucyB0aGUgc2NoZWR1bGVkIHN0YXRlIHNjaGVkdWxlZCBiZWZvcmUgb3IgYXRcblx0ICogIHRoZSBnaXZlbiB0aW1lLlxuXHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdG8gcXVlcnkuXG5cdCAqICBAcmV0dXJuICB7U3RyaW5nfSAgVGhlIG5hbWUgb2YgdGhlIHN0YXRlIGlucHV0IGluIHNldFN0YXRlQXRUaW1lLlxuXHQgKi9cblx0VG9uZS5UaW1lbGluZVN0YXRlLnByb3RvdHlwZS5nZXRWYWx1ZUF0VGltZSA9IGZ1bmN0aW9uKHRpbWUpe1xuXHRcdHZhciBldmVudCA9IHRoaXMuZ2V0KHRpbWUpO1xuXHRcdGlmIChldmVudCAhPT0gbnVsbCl7XG5cdFx0XHRyZXR1cm4gZXZlbnQuc3RhdGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLl9pbml0aWFsO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogIEFkZCBhIHN0YXRlIHRvIHRoZSB0aW1lbGluZS5cblx0ICogIEBwYXJhbSAge1N0cmluZ30gIHN0YXRlIFRoZSBuYW1lIG9mIHRoZSBzdGF0ZSB0byBzZXQuXG5cdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSB0byBxdWVyeS5cblx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lU3RhdGV9IHRoaXNcblx0ICovXG5cdFRvbmUuVGltZWxpbmVTdGF0ZS5wcm90b3R5cGUuc2V0U3RhdGVBdFRpbWUgPSBmdW5jdGlvbihzdGF0ZSwgdGltZSl7XG5cdFx0Ly9hbGwgc3RhdGUgY2hhbmdlcyBuZWVkIHRvIGJlID49IHRoZSBwcmV2aW91cyBzdGF0ZSB0aW1lXG5cdFx0Ly9UT0RPIHRocm93IGVycm9yIGlmIHRpbWUgPCB0aGUgcHJldmlvdXMgZXZlbnQgdGltZVxuXHRcdHRoaXMuYWRkKHtcblx0XHRcdFwic3RhdGVcIiA6IHN0YXRlLFxuXHRcdFx0XCJ0aW1lXCIgOiB0aW1lXG5cdFx0fSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqICBSZXR1cm4gdGhlIGV2ZW50IGJlZm9yZSB0aGUgdGltZSB3aXRoIHRoZSBnaXZlbiBzdGF0ZVxuXHQgKiAgQHBhcmFtIHtUb25lLlN0YXRlfSBzdGF0ZSBUaGUgc3RhdGUgdG8gbG9vayBmb3Jcblx0ICogIEBwYXJhbSAge1RpbWV9ICB0aW1lICBXaGVuIHRvIGNoZWNrIGJlZm9yZVx0XHRcdFxuXHQgKiAgQHJldHVybiAge09iamVjdH0gIFRoZSBldmVudCB3aXRoIHRoZSBnaXZlbiBzdGF0ZSBiZWZvcmUgdGhlIHRpbWVcblx0ICovXG5cdFRvbmUuVGltZWxpbmVTdGF0ZS5wcm90b3R5cGUuZ2V0TGFzdFN0YXRlID0gZnVuY3Rpb24oc3RhdGUsIHRpbWUpe1xuXHRcdHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0XHR2YXIgaW5kZXggPSB0aGlzLl9zZWFyY2godGltZSk7XG5cdFx0Zm9yICh2YXIgaSA9IGluZGV4OyBpID49IDA7IGktLSl7XG5cdFx0XHR2YXIgZXZlbnQgPSB0aGlzLl90aW1lbGluZVtpXTtcblx0XHRcdGlmIChldmVudC5zdGF0ZSA9PT0gc3RhdGUpe1xuXHRcdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiAgUmV0dXJuIHRoZSBldmVudCBhZnRlciB0aGUgdGltZSB3aXRoIHRoZSBnaXZlbiBzdGF0ZVxuXHQgKiAgQHBhcmFtIHtUb25lLlN0YXRlfSBzdGF0ZSBUaGUgc3RhdGUgdG8gbG9vayBmb3Jcblx0ICogIEBwYXJhbSAge1RpbWV9ICB0aW1lICBXaGVuIHRvIGNoZWNrIGZyb21cblx0ICogIEByZXR1cm4gIHtPYmplY3R9ICBUaGUgZXZlbnQgd2l0aCB0aGUgZ2l2ZW4gc3RhdGUgYWZ0ZXIgdGhlIHRpbWVcblx0ICovXG5cdFRvbmUuVGltZWxpbmVTdGF0ZS5wcm90b3R5cGUuZ2V0TmV4dFN0YXRlID0gZnVuY3Rpb24oc3RhdGUsIHRpbWUpe1xuXHRcdHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0XHR2YXIgaW5kZXggPSB0aGlzLl9zZWFyY2godGltZSk7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSl7XG5cdFx0XHRmb3IgKHZhciBpID0gaW5kZXg7IGkgPCB0aGlzLl90aW1lbGluZS5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdHZhciBldmVudCA9IHRoaXMuX3RpbWVsaW5lW2ldO1xuXHRcdFx0XHRpZiAoZXZlbnQuc3RhdGUgPT09IHN0YXRlKXtcblx0XHRcdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIFRvbmUuVGltZWxpbmVTdGF0ZTtcbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUVBO0FBRUE7Ozs7Ozs7OztBQVFBO0FBRUE7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/core/TimelineState.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/core/Tone.js":
/*!*********************************************!*\
  !*** ./node_modules/tone/Tone/core/Tone.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/**\n *  Tone.js\n *  @author Yotam Mann\n *  @license http://opensource.org/licenses/MIT MIT License\n *  @copyright 2014-2018 Yotam Mann\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  \"use strict\"; ///////////////////////////////////////////////////////////////////////////\n  //\tTONE\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  @class  Tone is the base class of all other classes.\n   *  @constructor\n   */\n\n  var Tone = function Tone() {\n    if (!(this instanceof Tone)) {\n      throw new Error(\"constructor needs to be called with the 'new' keyword\");\n    }\n  };\n  /**\n   *  @memberOf Tone#\n   *  @returns {String} returns the name of the class as a string\n   */\n\n\n  Tone.prototype.toString = function () {\n    for (var className in Tone) {\n      var isLetter = className[0].match(/^[A-Z]$/);\n      var sameConstructor = Tone[className] === this.constructor;\n\n      if (Tone.isFunction(Tone[className]) && isLetter && sameConstructor) {\n        return className;\n      }\n    }\n\n    return \"Tone\";\n  };\n  /**\n   *  @memberOf Tone#\n   *  disconnect and dispose\n   *  @returns {Tone} this\n   */\n\n\n  Tone.prototype.dispose = function () {\n    return this;\n  }; ///////////////////////////////////////////////////////////////////////////\n  //\tGET/SET\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  Set the parameters at once. Either pass in an\n   *  object mapping parameters to values, or to set a\n   *  single parameter, by passing in a string and value.\n   *  The last argument is an optional ramp time which\n   *  will ramp any signal values to their destination value\n   *  over the duration of the rampTime.\n   *  @param {Object|String} params\n   *  @param {Number=} value\n   *  @param {Time=} rampTime\n   *  @returns {Tone} this\n   *  @memberOf Tone#\n   *  @example\n   * //set values using an object\n   * filter.set({\n   * \t\"frequency\" : 300,\n   * \t\"type\" : highpass\n   * });\n   *  @example\n   * filter.set(\"type\", \"highpass\");\n   *  @example\n   * //ramp to the value 220 over 3 seconds.\n   * oscillator.set({\n   * \t\"frequency\" : 220\n   * }, 3);\n   */\n\n\n  Tone.prototype.set = function (params, value, rampTime) {\n    if (Tone.isObject(params)) {\n      rampTime = value;\n    } else if (Tone.isString(params)) {\n      var tmpObj = {};\n      tmpObj[params] = value;\n      params = tmpObj;\n    }\n\n    paramLoop: for (var attr in params) {\n      value = params[attr];\n      var parent = this;\n\n      if (attr.indexOf(\".\") !== -1) {\n        var attrSplit = attr.split(\".\");\n\n        for (var i = 0; i < attrSplit.length - 1; i++) {\n          parent = parent[attrSplit[i]];\n\n          if (parent instanceof Tone) {\n            attrSplit.splice(0, i + 1);\n            var innerParam = attrSplit.join(\".\");\n            parent.set(innerParam, value);\n            continue paramLoop;\n          }\n        }\n\n        attr = attrSplit[attrSplit.length - 1];\n      }\n\n      var param = parent[attr];\n\n      if (Tone.isUndef(param)) {\n        continue;\n      }\n\n      if (Tone.Signal && param instanceof Tone.Signal || Tone.Param && param instanceof Tone.Param) {\n        if (param.value !== value) {\n          if (Tone.isUndef(rampTime)) {\n            param.value = value;\n          } else {\n            param.rampTo(value, rampTime);\n          }\n        }\n      } else if (param instanceof AudioParam) {\n        if (param.value !== value) {\n          param.value = value;\n        }\n      } else if (Tone.TimeBase && param instanceof Tone.TimeBase) {\n        parent[attr] = value;\n      } else if (param instanceof Tone) {\n        param.set(value);\n      } else if (param !== value) {\n        parent[attr] = value;\n      }\n    }\n\n    return this;\n  };\n  /**\n   *  Get the object's attributes. Given no arguments get\n   *  will return all available object properties and their corresponding\n   *  values. Pass in a single attribute to retrieve or an array\n   *  of attributes. The attribute strings can also include a \".\"\n   *  to access deeper properties.\n   *  @memberOf Tone#\n   *  @example\n   * osc.get();\n   * //returns {\"type\" : \"sine\", \"frequency\" : 440, ...etc}\n   *  @example\n   * osc.get(\"type\");\n   * //returns { \"type\" : \"sine\"}\n   * @example\n   * //use dot notation to access deep properties\n   * synth.get([\"envelope.attack\", \"envelope.release\"]);\n   * //returns {\"envelope\" : {\"attack\" : 0.2, \"release\" : 0.4}}\n   *  @param {Array=|string|undefined} params the parameters to get, otherwise will return\n   *  \t\t\t\t\t                  all available.\n   *  @returns {Object}\n   */\n\n\n  Tone.prototype.get = function (params) {\n    if (Tone.isUndef(params)) {\n      params = this._collectDefaults(this.constructor);\n    } else if (Tone.isString(params)) {\n      params = [params];\n    }\n\n    var ret = {};\n\n    for (var i = 0; i < params.length; i++) {\n      var attr = params[i];\n      var parent = this;\n      var subRet = ret;\n\n      if (attr.indexOf(\".\") !== -1) {\n        var attrSplit = attr.split(\".\");\n\n        for (var j = 0; j < attrSplit.length - 1; j++) {\n          var subAttr = attrSplit[j];\n          subRet[subAttr] = subRet[subAttr] || {};\n          subRet = subRet[subAttr];\n          parent = parent[subAttr];\n        }\n\n        attr = attrSplit[attrSplit.length - 1];\n      }\n\n      var param = parent[attr];\n\n      if (Tone.isObject(params[attr])) {\n        subRet[attr] = param.get();\n      } else if (Tone.Signal && param instanceof Tone.Signal) {\n        subRet[attr] = param.value;\n      } else if (Tone.Param && param instanceof Tone.Param) {\n        subRet[attr] = param.value;\n      } else if (param instanceof AudioParam) {\n        subRet[attr] = param.value;\n      } else if (param instanceof Tone) {\n        subRet[attr] = param.get();\n      } else if (!Tone.isFunction(param) && Tone.isDefined(param)) {\n        subRet[attr] = param;\n      }\n    }\n\n    return ret;\n  };\n  /**\n   *  collect all of the default attributes in one\n   *  @private\n   *  @param {Function} constr the constructor to find the defaults from\n   *  @return {Array} all of the attributes which belong to the class\n   */\n\n\n  Tone.prototype._collectDefaults = function (constr) {\n    var ret = [];\n\n    if (Tone.isDefined(constr.defaults)) {\n      ret = Object.keys(constr.defaults);\n    }\n\n    if (Tone.isDefined(constr._super)) {\n      var superDefs = this._collectDefaults(constr._super); //filter out repeats\n\n\n      for (var i = 0; i < superDefs.length; i++) {\n        if (ret.indexOf(superDefs[i]) === -1) {\n          ret.push(superDefs[i]);\n        }\n      }\n    }\n\n    return ret;\n  }; ///////////////////////////////////////////////////////////////////////////\n  //\tDEFAULTS\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  @memberOf Tone\n   *  @param  {Array}  values  The arguments array\n   *  @param  {Array}  keys    The names of the arguments\n   *  @param {Function|Object} constr The class constructor\n   *  @return  {Object}  An object composed of the  defaults between the class' defaults\n   *                        and the passed in arguments.\n   */\n\n\n  Tone.defaults = function (values, keys, constr) {\n    var options = {};\n\n    if (values.length === 1 && Tone.isObject(values[0])) {\n      options = values[0];\n    } else {\n      for (var i = 0; i < keys.length; i++) {\n        options[keys[i]] = values[i];\n      }\n    }\n\n    if (Tone.isDefined(constr.defaults)) {\n      return Tone.defaultArg(options, constr.defaults);\n    } else if (Tone.isObject(constr)) {\n      return Tone.defaultArg(options, constr);\n    } else {\n      return options;\n    }\n  };\n  /**\n   *  If the `given` parameter is undefined, use the `fallback`.\n   *  If both `given` and `fallback` are object literals, it will\n   *  return a deep copy which includes all of the parameters from both\n   *  objects. If a parameter is undefined in given, it will return\n   *  the fallback property.\n   *  <br><br>\n   *  WARNING: if object is self referential, it will go into an an\n   *  infinite recursive loop.\n   *  @memberOf Tone\n   *  @param  {*} given\n   *  @param  {*} fallback\n   *  @return {*}\n   */\n\n\n  Tone.defaultArg = function (given, fallback) {\n    if (Tone.isObject(given) && Tone.isObject(fallback)) {\n      var ret = {}; //make a deep copy of the given object\n\n      for (var givenProp in given) {\n        ret[givenProp] = Tone.defaultArg(fallback[givenProp], given[givenProp]);\n      }\n\n      for (var fallbackProp in fallback) {\n        ret[fallbackProp] = Tone.defaultArg(given[fallbackProp], fallback[fallbackProp]);\n      }\n\n      return ret;\n    } else {\n      return Tone.isUndef(given) ? fallback : given;\n    }\n  }; ///////////////////////////////////////////////////////////////////////////\n  //\tCONNECTIONS\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  connect together all of the arguments in series\n   *  @param {...AudioParam|Tone|AudioNode} nodes\n   *  @returns {Tone}\n   *  @memberOf Tone\n   *  @static\n   */\n\n\n  Tone.connectSeries = function () {\n    var currentUnit = arguments[0];\n\n    for (var i = 1; i < arguments.length; i++) {\n      var toUnit = arguments[i];\n      currentUnit.connect(toUnit);\n      currentUnit = toUnit;\n    }\n\n    return Tone;\n  }; ///////////////////////////////////////////////////////////////////////////\n  // TYPE CHECKING\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  Test if the arg is undefined\n   *  @param {*} arg the argument to test\n   *  @returns {Boolean} true if the arg is undefined\n   *  @static\n   *  @memberOf Tone\n   */\n\n\n  Tone.isUndef = function (val) {\n    return typeof val === \"undefined\";\n  };\n  /**\n   *  Test if the arg is not undefined\n   *  @param {*} arg the argument to test\n   *  @returns {Boolean} true if the arg is undefined\n   *  @static\n   *  @memberOf Tone\n   */\n\n\n  Tone.isDefined = function (val) {\n    return !Tone.isUndef(val);\n  };\n  /**\n   *  Test if the arg is a function\n   *  @param {*} arg the argument to test\n   *  @returns {Boolean} true if the arg is a function\n   *  @static\n   *  @memberOf Tone\n   */\n\n\n  Tone.isFunction = function (val) {\n    return typeof val === \"function\";\n  };\n  /**\n   *  Test if the argument is a number.\n   *  @param {*} arg the argument to test\n   *  @returns {Boolean} true if the arg is a number\n   *  @static\n   *  @memberOf Tone\n   */\n\n\n  Tone.isNumber = function (arg) {\n    return typeof arg === \"number\";\n  };\n  /**\n   *  Test if the given argument is an object literal (i.e. `{}`);\n   *  @param {*} arg the argument to test\n   *  @returns {Boolean} true if the arg is an object literal.\n   *  @static\n   *  @memberOf Tone\n   */\n\n\n  Tone.isObject = function (arg) {\n    return Object.prototype.toString.call(arg) === \"[object Object]\" && arg.constructor === Object;\n  };\n  /**\n   *  Test if the argument is a boolean.\n   *  @param {*} arg the argument to test\n   *  @returns {Boolean} true if the arg is a boolean\n   *  @static\n   *  @memberOf Tone\n   */\n\n\n  Tone.isBoolean = function (arg) {\n    return typeof arg === \"boolean\";\n  };\n  /**\n   *  Test if the argument is an Array\n   *  @param {*} arg the argument to test\n   *  @returns {Boolean} true if the arg is an array\n   *  @static\n   *  @memberOf Tone\n   */\n\n\n  Tone.isArray = function (arg) {\n    return Array.isArray(arg);\n  };\n  /**\n   *  Test if the argument is a string.\n   *  @param {*} arg the argument to test\n   *  @returns {Boolean} true if the arg is a string\n   *  @static\n   *  @memberOf Tone\n   */\n\n\n  Tone.isString = function (arg) {\n    return typeof arg === \"string\";\n  };\n  /**\n   *  Test if the argument is in the form of a note in scientific pitch notation.\n   *  e.g. \"C4\"\n   *  @param {*} arg the argument to test\n   *  @returns {Boolean} true if the arg is a string\n   *  @static\n   *  @memberOf Tone\n   */\n\n\n  Tone.isNote = function (arg) {\n    return Tone.isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);\n  };\n  /**\n   *  An empty function.\n   *  @static\n   */\n\n\n  Tone.noOp = function () {};\n  /**\n   *  Make the property not writable. Internal use only.\n   *  @private\n   *  @param  {String}  property  the property to make not writable\n   */\n\n\n  Tone.prototype._readOnly = function (property) {\n    if (Array.isArray(property)) {\n      for (var i = 0; i < property.length; i++) {\n        this._readOnly(property[i]);\n      }\n    } else {\n      Object.defineProperty(this, property, {\n        writable: false,\n        enumerable: true\n      });\n    }\n  };\n  /**\n   *  Make an attribute writeable. Interal use only.\n   *  @private\n   *  @param  {String}  property  the property to make writable\n   */\n\n\n  Tone.prototype._writable = function (property) {\n    if (Array.isArray(property)) {\n      for (var i = 0; i < property.length; i++) {\n        this._writable(property[i]);\n      }\n    } else {\n      Object.defineProperty(this, property, {\n        writable: true\n      });\n    }\n  };\n  /**\n   * Possible play states.\n   * @enum {String}\n   */\n\n\n  Tone.State = {\n    Started: \"started\",\n    Stopped: \"stopped\",\n    Paused: \"paused\"\n  }; ///////////////////////////////////////////////////////////////////////////\n  // CONVERSIONS\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  Equal power gain scale. Good for cross-fading.\n   *  @param  {NormalRange} percent (0-1)\n   *  @return {Number}         output gain (0-1)\n   *  @static\n   *  @memberOf Tone\n   */\n\n  Tone.equalPowerScale = function (percent) {\n    var piFactor = 0.5 * Math.PI;\n    return Math.sin(percent * piFactor);\n  };\n  /**\n   *  Convert decibels into gain.\n   *  @param  {Decibels} db\n   *  @return {Number}\n   *  @static\n   *  @memberOf Tone\n   */\n\n\n  Tone.dbToGain = function (db) {\n    return Math.pow(10, db / 20);\n  };\n  /**\n   *  Convert gain to decibels.\n   *  @param  {Number} gain (0-1)\n   *  @return {Decibels}\n   *  @static\n   *  @memberOf Tone\n   */\n\n\n  Tone.gainToDb = function (gain) {\n    return 20 * (Math.log(gain) / Math.LN10);\n  };\n  /**\n   *  Convert an interval (in semitones) to a frequency ratio.\n   *  @param  {Interval} interval the number of semitones above the base note\n   *  @return {Number}          the frequency ratio\n   *  @static\n   *  @memberOf Tone\n   *  @example\n   * tone.intervalToFrequencyRatio(0); // 1\n   * tone.intervalToFrequencyRatio(12); // 2\n   * tone.intervalToFrequencyRatio(-12); // 0.5\n   */\n\n\n  Tone.intervalToFrequencyRatio = function (interval) {\n    return Math.pow(2, interval / 12);\n  }; ///////////////////////////////////////////////////////////////////////////\n  //\tTIMING\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  Return the current time of the AudioContext clock.\n   *  @return {Number} the currentTime from the AudioContext\n   *  @memberOf Tone#\n   */\n\n\n  Tone.prototype.now = function () {\n    return Tone.context.now();\n  };\n  /**\n   *  Return the current time of the AudioContext clock.\n   *  @return {Number} the currentTime from the AudioContext\n   *  @static\n   *  @memberOf Tone\n   */\n\n\n  Tone.now = function () {\n    return Tone.context.now();\n  }; ///////////////////////////////////////////////////////////////////////////\n  //\tINHERITANCE\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  have a child inherit all of Tone's (or a parent's) prototype\n   *  to inherit the parent's properties, make sure to call\n   *  Parent.call(this) in the child's constructor\n   *\n   *  based on closure library's inherit function\n   *\n   *  @memberOf Tone\n   *  @static\n   *  @param  {Function} \tchild\n   *  @param  {Function=} parent (optional) parent to inherit from\n   *                             if no parent is supplied, the child\n   *                             will inherit from Tone\n   */\n\n\n  Tone.extend = function (child, parent) {\n    if (Tone.isUndef(parent)) {\n      parent = Tone;\n    }\n\n    function TempConstructor() {}\n\n    TempConstructor.prototype = parent.prototype;\n    child.prototype = new TempConstructor();\n    /** @override */\n\n    child.prototype.constructor = child;\n    child._super = parent;\n  }; ///////////////////////////////////////////////////////////////////////////\n  //\tCONTEXT\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  Private reference to the global AudioContext\n   *  @type {AudioContext}\n   *  @private\n   */\n\n\n  var audioContext = null;\n  /**\n   *  A static pointer to the audio context accessible as Tone.context.\n   *  @type {Tone.Context}\n   *  @name context\n   *  @memberOf Tone\n   */\n\n  Object.defineProperty(Tone, \"context\", {\n    get: function () {\n      function get() {\n        return audioContext;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(context) {\n        if (Tone.Context && context instanceof Tone.Context) {\n          audioContext = context;\n        } else {\n          audioContext = new Tone.Context(context);\n        } //initialize the new audio context\n\n\n        Tone.Context.emit(\"init\", audioContext);\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  The AudioContext\n   *  @type {Tone.Context}\n   *  @name context\n   *  @memberOf Tone#\n   *  @readOnly\n   */\n\n  Object.defineProperty(Tone.prototype, \"context\", {\n    get: function () {\n      function get() {\n        return Tone.context;\n      }\n\n      return get;\n    }()\n  });\n  /**\n   *  Tone automatically creates a context on init, but if you are working\n   *  with other libraries which also create an AudioContext, it can be\n   *  useful to set your own. If you are going to set your own context,\n   *  be sure to do it at the start of your code, before creating any objects.\n   *  @static\n   *  @param {AudioContext} ctx The new audio context to set\n   */\n\n  Tone.setContext = function (ctx) {\n    Tone.context = ctx;\n  }; ///////////////////////////////////////////////////////////////////////////\n  //\tATTRIBUTES\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  The number of seconds of 1 processing block (128 samples)\n   *  @type {Number}\n   *  @name blockTime\n   *  @memberOf Tone\n   *  @static\n   *  @readOnly\n   */\n\n\n  Object.defineProperty(Tone.prototype, \"blockTime\", {\n    get: function () {\n      function get() {\n        return 128 / this.context.sampleRate;\n      }\n\n      return get;\n    }()\n  });\n  /**\n   *  The duration in seconds of one sample.\n   *  @type {Number}\n   *  @name sampleTime\n   *  @memberOf Tone\n   *  @static\n   *  @readOnly\n   */\n\n  Object.defineProperty(Tone.prototype, \"sampleTime\", {\n    get: function () {\n      function get() {\n        return 1 / this.context.sampleRate;\n      }\n\n      return get;\n    }()\n  });\n  /**\n   *  Whether or not all the technologies that Tone.js relies on are supported by the current browser.\n   *  @type {Boolean}\n   *  @name supported\n   *  @memberOf Tone\n   *  @readOnly\n   *  @static\n   */\n\n  Object.defineProperty(Tone, \"supported\", {\n    get: function () {\n      function get() {\n        var hasAudioContext = window.hasOwnProperty(\"AudioContext\") || window.hasOwnProperty(\"webkitAudioContext\");\n        var hasPromises = window.hasOwnProperty(\"Promise\");\n        var hasWorkers = window.hasOwnProperty(\"Worker\");\n        return hasAudioContext && hasPromises && hasWorkers;\n      }\n\n      return get;\n    }()\n  });\n  /**\n   *  Boolean value if the audio context has been initialized.\n   *  @type {Boolean}\n   *  @memberOf Tone\n   *  @static\n   *  @name initialized\n   */\n\n  Object.defineProperty(Tone, \"initialized\", {\n    get: function () {\n      function get() {\n        return audioContext !== null;\n      }\n\n      return get;\n    }()\n  });\n  /**\n   *  Get the context when it becomes available\n   *  @param  {Function}  resolve  Callback when the context is initialized\n   *  @return  {Tone}\n   */\n\n  Tone.getContext = function (resolve) {\n    if (Tone.initialized) {\n      resolve(Tone.context);\n    } else {\n      var resCallback = function resCallback() {\n        resolve(Tone.context);\n        Tone.Context.off(\"init\", resCallback);\n      };\n\n      Tone.Context.on(\"init\", resCallback);\n    }\n\n    return Tone;\n  };\n  /**\n   * The version number\n   * @type {String}\n   * @static\n   */\n\n\n  Tone.version = \"r12\";\n  return Tone;\n}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvVG9uZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90b25lL1RvbmUvY29yZS9Ub25lLmpzPzE2MjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgVG9uZS5qc1xuICogIEBhdXRob3IgWW90YW0gTWFublxuICogIEBsaWNlbnNlIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQgTUlUIExpY2Vuc2VcbiAqICBAY29weXJpZ2h0IDIwMTQtMjAxOCBZb3RhbSBNYW5uXG4gKi9cbmRlZmluZShmdW5jdGlvbigpe1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvL1x0VE9ORVxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHQvKipcblx0ICogIEBjbGFzcyAgVG9uZSBpcyB0aGUgYmFzZSBjbGFzcyBvZiBhbGwgb3RoZXIgY2xhc3Nlcy5cblx0ICogIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0dmFyIFRvbmUgPSBmdW5jdGlvbigpe1xuXHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBUb25lKSl7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjb25zdHJ1Y3RvciBuZWVkcyB0byBiZSBjYWxsZWQgd2l0aCB0aGUgJ25ldycga2V5d29yZFwiKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqICBAbWVtYmVyT2YgVG9uZSNcblx0ICogIEByZXR1cm5zIHtTdHJpbmd9IHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGNsYXNzIGFzIGEgc3RyaW5nXG5cdCAqL1xuXHRUb25lLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG5cdFx0Zm9yICh2YXIgY2xhc3NOYW1lIGluIFRvbmUpe1xuXHRcdFx0dmFyIGlzTGV0dGVyID0gY2xhc3NOYW1lWzBdLm1hdGNoKC9eW0EtWl0kLyk7XG5cdFx0XHR2YXIgc2FtZUNvbnN0cnVjdG9yID0gVG9uZVtjbGFzc05hbWVdID09PSB0aGlzLmNvbnN0cnVjdG9yO1xuXHRcdFx0aWYgKFRvbmUuaXNGdW5jdGlvbihUb25lW2NsYXNzTmFtZV0pICYmIGlzTGV0dGVyICYmIHNhbWVDb25zdHJ1Y3Rvcil7XG5cdFx0XHRcdHJldHVybiBjbGFzc05hbWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBcIlRvbmVcIjtcblx0fTtcblxuXHQvKipcblx0ICogIEBtZW1iZXJPZiBUb25lI1xuXHQgKiAgZGlzY29ubmVjdCBhbmQgZGlzcG9zZVxuXHQgKiAgQHJldHVybnMge1RvbmV9IHRoaXNcblx0ICovXG5cdFRvbmUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvL1x0R0VUL1NFVFxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHQvKipcblx0ICogIFNldCB0aGUgcGFyYW1ldGVycyBhdCBvbmNlLiBFaXRoZXIgcGFzcyBpbiBhblxuXHQgKiAgb2JqZWN0IG1hcHBpbmcgcGFyYW1ldGVycyB0byB2YWx1ZXMsIG9yIHRvIHNldCBhXG5cdCAqICBzaW5nbGUgcGFyYW1ldGVyLCBieSBwYXNzaW5nIGluIGEgc3RyaW5nIGFuZCB2YWx1ZS5cblx0ICogIFRoZSBsYXN0IGFyZ3VtZW50IGlzIGFuIG9wdGlvbmFsIHJhbXAgdGltZSB3aGljaFxuXHQgKiAgd2lsbCByYW1wIGFueSBzaWduYWwgdmFsdWVzIHRvIHRoZWlyIGRlc3RpbmF0aW9uIHZhbHVlXG5cdCAqICBvdmVyIHRoZSBkdXJhdGlvbiBvZiB0aGUgcmFtcFRpbWUuXG5cdCAqICBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHBhcmFtc1xuXHQgKiAgQHBhcmFtIHtOdW1iZXI9fSB2YWx1ZVxuXHQgKiAgQHBhcmFtIHtUaW1lPX0gcmFtcFRpbWVcblx0ICogIEByZXR1cm5zIHtUb25lfSB0aGlzXG5cdCAqICBAbWVtYmVyT2YgVG9uZSNcblx0ICogIEBleGFtcGxlXG5cdCAqIC8vc2V0IHZhbHVlcyB1c2luZyBhbiBvYmplY3Rcblx0ICogZmlsdGVyLnNldCh7XG5cdCAqIFx0XCJmcmVxdWVuY3lcIiA6IDMwMCxcblx0ICogXHRcInR5cGVcIiA6IGhpZ2hwYXNzXG5cdCAqIH0pO1xuXHQgKiAgQGV4YW1wbGVcblx0ICogZmlsdGVyLnNldChcInR5cGVcIiwgXCJoaWdocGFzc1wiKTtcblx0ICogIEBleGFtcGxlXG5cdCAqIC8vcmFtcCB0byB0aGUgdmFsdWUgMjIwIG92ZXIgMyBzZWNvbmRzLlxuXHQgKiBvc2NpbGxhdG9yLnNldCh7XG5cdCAqIFx0XCJmcmVxdWVuY3lcIiA6IDIyMFxuXHQgKiB9LCAzKTtcblx0ICovXG5cdFRvbmUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHBhcmFtcywgdmFsdWUsIHJhbXBUaW1lKXtcblx0XHRpZiAoVG9uZS5pc09iamVjdChwYXJhbXMpKXtcblx0XHRcdHJhbXBUaW1lID0gdmFsdWU7XG5cdFx0fSBlbHNlIGlmIChUb25lLmlzU3RyaW5nKHBhcmFtcykpe1xuXHRcdFx0dmFyIHRtcE9iaiA9IHt9O1xuXHRcdFx0dG1wT2JqW3BhcmFtc10gPSB2YWx1ZTtcblx0XHRcdHBhcmFtcyA9IHRtcE9iajtcblx0XHR9XG5cblx0XHRwYXJhbUxvb3A6XG5cdFx0Zm9yICh2YXIgYXR0ciBpbiBwYXJhbXMpe1xuXHRcdFx0dmFsdWUgPSBwYXJhbXNbYXR0cl07XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcztcblx0XHRcdGlmIChhdHRyLmluZGV4T2YoXCIuXCIpICE9PSAtMSl7XG5cdFx0XHRcdHZhciBhdHRyU3BsaXQgPSBhdHRyLnNwbGl0KFwiLlwiKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyU3BsaXQubGVuZ3RoIC0gMTsgaSsrKXtcblx0XHRcdFx0XHRwYXJlbnQgPSBwYXJlbnRbYXR0clNwbGl0W2ldXTtcblx0XHRcdFx0XHRpZiAocGFyZW50IGluc3RhbmNlb2YgVG9uZSl7XG5cdFx0XHRcdFx0XHRhdHRyU3BsaXQuc3BsaWNlKDAsIGkrMSk7XG5cdFx0XHRcdFx0XHR2YXIgaW5uZXJQYXJhbSA9IGF0dHJTcGxpdC5qb2luKFwiLlwiKTtcblx0XHRcdFx0XHRcdHBhcmVudC5zZXQoaW5uZXJQYXJhbSwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0Y29udGludWUgcGFyYW1Mb29wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRhdHRyID0gYXR0clNwbGl0W2F0dHJTcGxpdC5sZW5ndGggLSAxXTtcblx0XHRcdH1cblx0XHRcdHZhciBwYXJhbSA9IHBhcmVudFthdHRyXTtcblx0XHRcdGlmIChUb25lLmlzVW5kZWYocGFyYW0pKXtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoKFRvbmUuU2lnbmFsICYmIHBhcmFtIGluc3RhbmNlb2YgVG9uZS5TaWduYWwpIHx8XG5cdFx0XHRcdFx0KFRvbmUuUGFyYW0gJiYgcGFyYW0gaW5zdGFuY2VvZiBUb25lLlBhcmFtKSl7XG5cdFx0XHRcdGlmIChwYXJhbS52YWx1ZSAhPT0gdmFsdWUpe1xuXHRcdFx0XHRcdGlmIChUb25lLmlzVW5kZWYocmFtcFRpbWUpKXtcblx0XHRcdFx0XHRcdHBhcmFtLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHBhcmFtLnJhbXBUbyh2YWx1ZSwgcmFtcFRpbWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChwYXJhbSBpbnN0YW5jZW9mIEF1ZGlvUGFyYW0pe1xuXHRcdFx0XHRpZiAocGFyYW0udmFsdWUgIT09IHZhbHVlKXtcblx0XHRcdFx0XHRwYXJhbS52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKFRvbmUuVGltZUJhc2UgJiYgcGFyYW0gaW5zdGFuY2VvZiBUb25lLlRpbWVCYXNlKXtcblx0XHRcdFx0cGFyZW50W2F0dHJdID0gdmFsdWU7XG5cdFx0XHR9IGVsc2UgaWYgKHBhcmFtIGluc3RhbmNlb2YgVG9uZSl7XG5cdFx0XHRcdHBhcmFtLnNldCh2YWx1ZSk7XG5cdFx0XHR9IGVsc2UgaWYgKHBhcmFtICE9PSB2YWx1ZSl7XG5cdFx0XHRcdHBhcmVudFthdHRyXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogIEdldCB0aGUgb2JqZWN0J3MgYXR0cmlidXRlcy4gR2l2ZW4gbm8gYXJndW1lbnRzIGdldFxuXHQgKiAgd2lsbCByZXR1cm4gYWxsIGF2YWlsYWJsZSBvYmplY3QgcHJvcGVydGllcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZ1xuXHQgKiAgdmFsdWVzLiBQYXNzIGluIGEgc2luZ2xlIGF0dHJpYnV0ZSB0byByZXRyaWV2ZSBvciBhbiBhcnJheVxuXHQgKiAgb2YgYXR0cmlidXRlcy4gVGhlIGF0dHJpYnV0ZSBzdHJpbmdzIGNhbiBhbHNvIGluY2x1ZGUgYSBcIi5cIlxuXHQgKiAgdG8gYWNjZXNzIGRlZXBlciBwcm9wZXJ0aWVzLlxuXHQgKiAgQG1lbWJlck9mIFRvbmUjXG5cdCAqICBAZXhhbXBsZVxuXHQgKiBvc2MuZ2V0KCk7XG5cdCAqIC8vcmV0dXJucyB7XCJ0eXBlXCIgOiBcInNpbmVcIiwgXCJmcmVxdWVuY3lcIiA6IDQ0MCwgLi4uZXRjfVxuXHQgKiAgQGV4YW1wbGVcblx0ICogb3NjLmdldChcInR5cGVcIik7XG5cdCAqIC8vcmV0dXJucyB7IFwidHlwZVwiIDogXCJzaW5lXCJ9XG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vdXNlIGRvdCBub3RhdGlvbiB0byBhY2Nlc3MgZGVlcCBwcm9wZXJ0aWVzXG5cdCAqIHN5bnRoLmdldChbXCJlbnZlbG9wZS5hdHRhY2tcIiwgXCJlbnZlbG9wZS5yZWxlYXNlXCJdKTtcblx0ICogLy9yZXR1cm5zIHtcImVudmVsb3BlXCIgOiB7XCJhdHRhY2tcIiA6IDAuMiwgXCJyZWxlYXNlXCIgOiAwLjR9fVxuXHQgKiAgQHBhcmFtIHtBcnJheT18c3RyaW5nfHVuZGVmaW5lZH0gcGFyYW1zIHRoZSBwYXJhbWV0ZXJzIHRvIGdldCwgb3RoZXJ3aXNlIHdpbGwgcmV0dXJuXG5cdCAqICBcdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAgYWxsIGF2YWlsYWJsZS5cblx0ICogIEByZXR1cm5zIHtPYmplY3R9XG5cdCAqL1xuXHRUb25lLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihwYXJhbXMpe1xuXHRcdGlmIChUb25lLmlzVW5kZWYocGFyYW1zKSl7XG5cdFx0XHRwYXJhbXMgPSB0aGlzLl9jb2xsZWN0RGVmYXVsdHModGhpcy5jb25zdHJ1Y3Rvcik7XG5cdFx0fSBlbHNlIGlmIChUb25lLmlzU3RyaW5nKHBhcmFtcykpe1xuXHRcdFx0cGFyYW1zID0gW3BhcmFtc107XG5cdFx0fVxuXHRcdHZhciByZXQgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKyl7XG5cdFx0XHR2YXIgYXR0ciA9IHBhcmFtc1tpXTtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzO1xuXHRcdFx0dmFyIHN1YlJldCA9IHJldDtcblx0XHRcdGlmIChhdHRyLmluZGV4T2YoXCIuXCIpICE9PSAtMSl7XG5cdFx0XHRcdHZhciBhdHRyU3BsaXQgPSBhdHRyLnNwbGl0KFwiLlwiKTtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBhdHRyU3BsaXQubGVuZ3RoIC0gMTsgaisrKXtcblx0XHRcdFx0XHR2YXIgc3ViQXR0ciA9IGF0dHJTcGxpdFtqXTtcblx0XHRcdFx0XHRzdWJSZXRbc3ViQXR0cl0gPSBzdWJSZXRbc3ViQXR0cl0gfHwge307XG5cdFx0XHRcdFx0c3ViUmV0ID0gc3ViUmV0W3N1YkF0dHJdO1xuXHRcdFx0XHRcdHBhcmVudCA9IHBhcmVudFtzdWJBdHRyXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhdHRyID0gYXR0clNwbGl0W2F0dHJTcGxpdC5sZW5ndGggLSAxXTtcblx0XHRcdH1cblx0XHRcdHZhciBwYXJhbSA9IHBhcmVudFthdHRyXTtcblx0XHRcdGlmIChUb25lLmlzT2JqZWN0KHBhcmFtc1thdHRyXSkpe1xuXHRcdFx0XHRzdWJSZXRbYXR0cl0gPSBwYXJhbS5nZXQoKTtcblx0XHRcdH0gZWxzZSBpZiAoVG9uZS5TaWduYWwgJiYgcGFyYW0gaW5zdGFuY2VvZiBUb25lLlNpZ25hbCl7XG5cdFx0XHRcdHN1YlJldFthdHRyXSA9IHBhcmFtLnZhbHVlO1xuXHRcdFx0fSBlbHNlIGlmIChUb25lLlBhcmFtICYmIHBhcmFtIGluc3RhbmNlb2YgVG9uZS5QYXJhbSl7XG5cdFx0XHRcdHN1YlJldFthdHRyXSA9IHBhcmFtLnZhbHVlO1xuXHRcdFx0fSBlbHNlIGlmIChwYXJhbSBpbnN0YW5jZW9mIEF1ZGlvUGFyYW0pe1xuXHRcdFx0XHRzdWJSZXRbYXR0cl0gPSBwYXJhbS52YWx1ZTtcblx0XHRcdH0gZWxzZSBpZiAocGFyYW0gaW5zdGFuY2VvZiBUb25lKXtcblx0XHRcdFx0c3ViUmV0W2F0dHJdID0gcGFyYW0uZ2V0KCk7XG5cdFx0XHR9IGVsc2UgaWYgKCFUb25lLmlzRnVuY3Rpb24ocGFyYW0pICYmIFRvbmUuaXNEZWZpbmVkKHBhcmFtKSl7XG5cdFx0XHRcdHN1YlJldFthdHRyXSA9IHBhcmFtO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgY29sbGVjdCBhbGwgb2YgdGhlIGRlZmF1bHQgYXR0cmlidXRlcyBpbiBvbmVcblx0ICogIEBwcml2YXRlXG5cdCAqICBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHIgdGhlIGNvbnN0cnVjdG9yIHRvIGZpbmQgdGhlIGRlZmF1bHRzIGZyb21cblx0ICogIEByZXR1cm4ge0FycmF5fSBhbGwgb2YgdGhlIGF0dHJpYnV0ZXMgd2hpY2ggYmVsb25nIHRvIHRoZSBjbGFzc1xuXHQgKi9cblx0VG9uZS5wcm90b3R5cGUuX2NvbGxlY3REZWZhdWx0cyA9IGZ1bmN0aW9uKGNvbnN0cil7XG5cdFx0dmFyIHJldCA9IFtdO1xuXHRcdGlmIChUb25lLmlzRGVmaW5lZChjb25zdHIuZGVmYXVsdHMpKXtcblx0XHRcdHJldCA9IE9iamVjdC5rZXlzKGNvbnN0ci5kZWZhdWx0cyk7XG5cdFx0fVxuXHRcdGlmIChUb25lLmlzRGVmaW5lZChjb25zdHIuX3N1cGVyKSl7XG5cdFx0XHR2YXIgc3VwZXJEZWZzID0gdGhpcy5fY29sbGVjdERlZmF1bHRzKGNvbnN0ci5fc3VwZXIpO1xuXHRcdFx0Ly9maWx0ZXIgb3V0IHJlcGVhdHNcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3VwZXJEZWZzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0aWYgKHJldC5pbmRleE9mKHN1cGVyRGVmc1tpXSkgPT09IC0xKXtcblx0XHRcdFx0XHRyZXQucHVzaChzdXBlckRlZnNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG5cblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vXHRERUZBVUxUU1xuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHQvKipcblx0ICogIEBtZW1iZXJPZiBUb25lXG5cdCAqICBAcGFyYW0gIHtBcnJheX0gIHZhbHVlcyAgVGhlIGFyZ3VtZW50cyBhcnJheVxuXHQgKiAgQHBhcmFtICB7QXJyYXl9ICBrZXlzICAgIFRoZSBuYW1lcyBvZiB0aGUgYXJndW1lbnRzXG5cdCAqICBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gY29uc3RyIFRoZSBjbGFzcyBjb25zdHJ1Y3RvclxuXHQgKiAgQHJldHVybiAge09iamVjdH0gIEFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgIGRlZmF1bHRzIGJldHdlZW4gdGhlIGNsYXNzJyBkZWZhdWx0c1xuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgIGFuZCB0aGUgcGFzc2VkIGluIGFyZ3VtZW50cy5cblx0ICovXG5cdFRvbmUuZGVmYXVsdHMgPSBmdW5jdGlvbih2YWx1ZXMsIGtleXMsIGNvbnN0cil7XG5cdFx0dmFyIG9wdGlvbnMgPSB7fTtcblx0XHRpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSAmJiBUb25lLmlzT2JqZWN0KHZhbHVlc1swXSkpe1xuXHRcdFx0b3B0aW9ucyA9IHZhbHVlc1swXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0b3B0aW9uc1trZXlzW2ldXSA9IHZhbHVlc1tpXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKFRvbmUuaXNEZWZpbmVkKGNvbnN0ci5kZWZhdWx0cykpe1xuXHRcdFx0cmV0dXJuIFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBjb25zdHIuZGVmYXVsdHMpO1xuXHRcdH0gZWxzZSBpZiAoVG9uZS5pc09iamVjdChjb25zdHIpKXtcblx0XHRcdHJldHVybiBUb25lLmRlZmF1bHRBcmcob3B0aW9ucywgY29uc3RyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnM7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiAgSWYgdGhlIGBnaXZlbmAgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZCwgdXNlIHRoZSBgZmFsbGJhY2tgLlxuXHQgKiAgSWYgYm90aCBgZ2l2ZW5gIGFuZCBgZmFsbGJhY2tgIGFyZSBvYmplY3QgbGl0ZXJhbHMsIGl0IHdpbGxcblx0ICogIHJldHVybiBhIGRlZXAgY29weSB3aGljaCBpbmNsdWRlcyBhbGwgb2YgdGhlIHBhcmFtZXRlcnMgZnJvbSBib3RoXG5cdCAqICBvYmplY3RzLiBJZiBhIHBhcmFtZXRlciBpcyB1bmRlZmluZWQgaW4gZ2l2ZW4sIGl0IHdpbGwgcmV0dXJuXG5cdCAqICB0aGUgZmFsbGJhY2sgcHJvcGVydHkuXG5cdCAqICA8YnI+PGJyPlxuXHQgKiAgV0FSTklORzogaWYgb2JqZWN0IGlzIHNlbGYgcmVmZXJlbnRpYWwsIGl0IHdpbGwgZ28gaW50byBhbiBhblxuXHQgKiAgaW5maW5pdGUgcmVjdXJzaXZlIGxvb3AuXG5cdCAqICBAbWVtYmVyT2YgVG9uZVxuXHQgKiAgQHBhcmFtICB7Kn0gZ2l2ZW5cblx0ICogIEBwYXJhbSAgeyp9IGZhbGxiYWNrXG5cdCAqICBAcmV0dXJuIHsqfVxuXHQgKi9cblx0VG9uZS5kZWZhdWx0QXJnID0gZnVuY3Rpb24oZ2l2ZW4sIGZhbGxiYWNrKXtcblx0XHRpZiAoVG9uZS5pc09iamVjdChnaXZlbikgJiYgVG9uZS5pc09iamVjdChmYWxsYmFjaykpe1xuXHRcdFx0dmFyIHJldCA9IHt9O1xuXHRcdFx0Ly9tYWtlIGEgZGVlcCBjb3B5IG9mIHRoZSBnaXZlbiBvYmplY3Rcblx0XHRcdGZvciAodmFyIGdpdmVuUHJvcCBpbiBnaXZlbil7XG5cdFx0XHRcdHJldFtnaXZlblByb3BdID0gVG9uZS5kZWZhdWx0QXJnKGZhbGxiYWNrW2dpdmVuUHJvcF0sIGdpdmVuW2dpdmVuUHJvcF0pO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgZmFsbGJhY2tQcm9wIGluIGZhbGxiYWNrKXtcblx0XHRcdFx0cmV0W2ZhbGxiYWNrUHJvcF0gPSBUb25lLmRlZmF1bHRBcmcoZ2l2ZW5bZmFsbGJhY2tQcm9wXSwgZmFsbGJhY2tbZmFsbGJhY2tQcm9wXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gVG9uZS5pc1VuZGVmKGdpdmVuKSA/IGZhbGxiYWNrIDogZ2l2ZW47XG5cdFx0fVxuXHR9O1xuXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvL1x0Q09OTkVDVElPTlNcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblx0LyoqXG5cdCAqICBjb25uZWN0IHRvZ2V0aGVyIGFsbCBvZiB0aGUgYXJndW1lbnRzIGluIHNlcmllc1xuXHQgKiAgQHBhcmFtIHsuLi5BdWRpb1BhcmFtfFRvbmV8QXVkaW9Ob2RlfSBub2Rlc1xuXHQgKiAgQHJldHVybnMge1RvbmV9XG5cdCAqICBAbWVtYmVyT2YgVG9uZVxuXHQgKiAgQHN0YXRpY1xuXHQgKi9cblx0VG9uZS5jb25uZWN0U2VyaWVzID0gZnVuY3Rpb24oKXtcblx0XHR2YXIgY3VycmVudFVuaXQgPSBhcmd1bWVudHNbMF07XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuXHRcdFx0dmFyIHRvVW5pdCA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGN1cnJlbnRVbml0LmNvbm5lY3QodG9Vbml0KTtcblx0XHRcdGN1cnJlbnRVbml0ID0gdG9Vbml0O1xuXHRcdH1cblx0XHRyZXR1cm4gVG9uZTtcblx0fTtcblxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly8gVFlQRSBDSEVDS0lOR1xuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHQvKipcblx0ICogIFRlc3QgaWYgdGhlIGFyZyBpcyB1bmRlZmluZWRcblx0ICogIEBwYXJhbSB7Kn0gYXJnIHRoZSBhcmd1bWVudCB0byB0ZXN0XG5cdCAqICBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgYXJnIGlzIHVuZGVmaW5lZFxuXHQgKiAgQHN0YXRpY1xuXHQgKiAgQG1lbWJlck9mIFRvbmVcblx0ICovXG5cdFRvbmUuaXNVbmRlZiA9IGZ1bmN0aW9uKHZhbCl7XG5cdFx0cmV0dXJuIHR5cGVvZiB2YWwgPT09IFwidW5kZWZpbmVkXCI7XG5cdH07XG5cblx0LyoqXG5cdCAqICBUZXN0IGlmIHRoZSBhcmcgaXMgbm90IHVuZGVmaW5lZFxuXHQgKiAgQHBhcmFtIHsqfSBhcmcgdGhlIGFyZ3VtZW50IHRvIHRlc3Rcblx0ICogIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBhcmcgaXMgdW5kZWZpbmVkXG5cdCAqICBAc3RhdGljXG5cdCAqICBAbWVtYmVyT2YgVG9uZVxuXHQgKi9cblx0VG9uZS5pc0RlZmluZWQgPSBmdW5jdGlvbih2YWwpe1xuXHRcdHJldHVybiAhVG9uZS5pc1VuZGVmKHZhbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqICBUZXN0IGlmIHRoZSBhcmcgaXMgYSBmdW5jdGlvblxuXHQgKiAgQHBhcmFtIHsqfSBhcmcgdGhlIGFyZ3VtZW50IHRvIHRlc3Rcblx0ICogIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBhcmcgaXMgYSBmdW5jdGlvblxuXHQgKiAgQHN0YXRpY1xuXHQgKiAgQG1lbWJlck9mIFRvbmVcblx0ICovXG5cdFRvbmUuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbCl7XG5cdFx0cmV0dXJuIHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIjtcblx0fTtcblxuXHQvKipcblx0ICogIFRlc3QgaWYgdGhlIGFyZ3VtZW50IGlzIGEgbnVtYmVyLlxuXHQgKiAgQHBhcmFtIHsqfSBhcmcgdGhlIGFyZ3VtZW50IHRvIHRlc3Rcblx0ICogIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBhcmcgaXMgYSBudW1iZXJcblx0ICogIEBzdGF0aWNcblx0ICogIEBtZW1iZXJPZiBUb25lXG5cdCAqL1xuXHRUb25lLmlzTnVtYmVyID0gZnVuY3Rpb24oYXJnKXtcblx0XHRyZXR1cm4gKHR5cGVvZiBhcmcgPT09IFwibnVtYmVyXCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgVGVzdCBpZiB0aGUgZ2l2ZW4gYXJndW1lbnQgaXMgYW4gb2JqZWN0IGxpdGVyYWwgKGkuZS4gYHt9YCk7XG5cdCAqICBAcGFyYW0geyp9IGFyZyB0aGUgYXJndW1lbnQgdG8gdGVzdFxuXHQgKiAgQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIGFyZyBpcyBhbiBvYmplY3QgbGl0ZXJhbC5cblx0ICogIEBzdGF0aWNcblx0ICogIEBtZW1iZXJPZiBUb25lXG5cdCAqL1xuXHRUb25lLmlzT2JqZWN0ID0gZnVuY3Rpb24oYXJnKXtcblx0XHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSBcIltvYmplY3QgT2JqZWN0XVwiICYmIGFyZy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KTtcblx0fTtcblxuXHQvKipcblx0ICogIFRlc3QgaWYgdGhlIGFyZ3VtZW50IGlzIGEgYm9vbGVhbi5cblx0ICogIEBwYXJhbSB7Kn0gYXJnIHRoZSBhcmd1bWVudCB0byB0ZXN0XG5cdCAqICBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgYXJnIGlzIGEgYm9vbGVhblxuXHQgKiAgQHN0YXRpY1xuXHQgKiAgQG1lbWJlck9mIFRvbmVcblx0ICovXG5cdFRvbmUuaXNCb29sZWFuID0gZnVuY3Rpb24oYXJnKXtcblx0XHRyZXR1cm4gKHR5cGVvZiBhcmcgPT09IFwiYm9vbGVhblwiKTtcblx0fTtcblxuXHQvKipcblx0ICogIFRlc3QgaWYgdGhlIGFyZ3VtZW50IGlzIGFuIEFycmF5XG5cdCAqICBAcGFyYW0geyp9IGFyZyB0aGUgYXJndW1lbnQgdG8gdGVzdFxuXHQgKiAgQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIGFyZyBpcyBhbiBhcnJheVxuXHQgKiAgQHN0YXRpY1xuXHQgKiAgQG1lbWJlck9mIFRvbmVcblx0ICovXG5cdFRvbmUuaXNBcnJheSA9IGZ1bmN0aW9uKGFyZyl7XG5cdFx0cmV0dXJuIChBcnJheS5pc0FycmF5KGFyZykpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgVGVzdCBpZiB0aGUgYXJndW1lbnQgaXMgYSBzdHJpbmcuXG5cdCAqICBAcGFyYW0geyp9IGFyZyB0aGUgYXJndW1lbnQgdG8gdGVzdFxuXHQgKiAgQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIGFyZyBpcyBhIHN0cmluZ1xuXHQgKiAgQHN0YXRpY1xuXHQgKiAgQG1lbWJlck9mIFRvbmVcblx0ICovXG5cdFRvbmUuaXNTdHJpbmcgPSBmdW5jdGlvbihhcmcpe1xuXHRcdHJldHVybiAodHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIik7XG5cdH07XG5cblx0LyoqXG5cdCAqICBUZXN0IGlmIHRoZSBhcmd1bWVudCBpcyBpbiB0aGUgZm9ybSBvZiBhIG5vdGUgaW4gc2NpZW50aWZpYyBwaXRjaCBub3RhdGlvbi5cblx0ICogIGUuZy4gXCJDNFwiXG5cdCAqICBAcGFyYW0geyp9IGFyZyB0aGUgYXJndW1lbnQgdG8gdGVzdFxuXHQgKiAgQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIGFyZyBpcyBhIHN0cmluZ1xuXHQgKiAgQHN0YXRpY1xuXHQgKiAgQG1lbWJlck9mIFRvbmVcblx0ICovXG5cdFRvbmUuaXNOb3RlID0gZnVuY3Rpb24oYXJnKXtcblx0XHRyZXR1cm4gVG9uZS5pc1N0cmluZyhhcmcpICYmIC9eKFthLWddezF9KD86YnwjfHh8YmIpPykoLT9bMC05XSspL2kudGVzdChhcmcpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgQW4gZW1wdHkgZnVuY3Rpb24uXG5cdCAqICBAc3RhdGljXG5cdCAqL1xuXHRUb25lLm5vT3AgPSBmdW5jdGlvbigpe307XG5cblx0LyoqXG5cdCAqICBNYWtlIHRoZSBwcm9wZXJ0eSBub3Qgd3JpdGFibGUuIEludGVybmFsIHVzZSBvbmx5LlxuXHQgKiAgQHByaXZhdGVcblx0ICogIEBwYXJhbSAge1N0cmluZ30gIHByb3BlcnR5ICB0aGUgcHJvcGVydHkgdG8gbWFrZSBub3Qgd3JpdGFibGVcblx0ICovXG5cdFRvbmUucHJvdG90eXBlLl9yZWFkT25seSA9IGZ1bmN0aW9uKHByb3BlcnR5KXtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShwcm9wZXJ0eSkpe1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0eS5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdHRoaXMuX3JlYWRPbmx5KHByb3BlcnR5W2ldKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHByb3BlcnR5LCB7XG5cdFx0XHRcdHdyaXRhYmxlIDogZmFsc2UsXG5cdFx0XHRcdGVudW1lcmFibGUgOiB0cnVlLFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiAgTWFrZSBhbiBhdHRyaWJ1dGUgd3JpdGVhYmxlLiBJbnRlcmFsIHVzZSBvbmx5LlxuXHQgKiAgQHByaXZhdGVcblx0ICogIEBwYXJhbSAge1N0cmluZ30gIHByb3BlcnR5ICB0aGUgcHJvcGVydHkgdG8gbWFrZSB3cml0YWJsZVxuXHQgKi9cblx0VG9uZS5wcm90b3R5cGUuX3dyaXRhYmxlID0gZnVuY3Rpb24ocHJvcGVydHkpe1xuXHRcdGlmIChBcnJheS5pc0FycmF5KHByb3BlcnR5KSl7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnR5Lmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0dGhpcy5fd3JpdGFibGUocHJvcGVydHlbaV0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcGVydHksIHtcblx0XHRcdFx0d3JpdGFibGUgOiB0cnVlLFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBQb3NzaWJsZSBwbGF5IHN0YXRlcy5cblx0ICogQGVudW0ge1N0cmluZ31cblx0ICovXG5cdFRvbmUuU3RhdGUgPSB7XG5cdFx0U3RhcnRlZCA6IFwic3RhcnRlZFwiLFxuXHRcdFN0b3BwZWQgOiBcInN0b3BwZWRcIixcblx0XHRQYXVzZWQgOiBcInBhdXNlZFwiLFxuXHR9O1xuXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBDT05WRVJTSU9OU1xuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHQvKipcblx0ICogIEVxdWFsIHBvd2VyIGdhaW4gc2NhbGUuIEdvb2QgZm9yIGNyb3NzLWZhZGluZy5cblx0ICogIEBwYXJhbSAge05vcm1hbFJhbmdlfSBwZXJjZW50ICgwLTEpXG5cdCAqICBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgb3V0cHV0IGdhaW4gKDAtMSlcblx0ICogIEBzdGF0aWNcblx0ICogIEBtZW1iZXJPZiBUb25lXG5cdCAqL1xuXHRUb25lLmVxdWFsUG93ZXJTY2FsZSA9IGZ1bmN0aW9uKHBlcmNlbnQpe1xuXHRcdHZhciBwaUZhY3RvciA9IDAuNSAqIE1hdGguUEk7XG5cdFx0cmV0dXJuIE1hdGguc2luKHBlcmNlbnQgKiBwaUZhY3Rvcik7XG5cdH07XG5cblx0LyoqXG5cdCAqICBDb252ZXJ0IGRlY2liZWxzIGludG8gZ2Fpbi5cblx0ICogIEBwYXJhbSAge0RlY2liZWxzfSBkYlxuXHQgKiAgQHJldHVybiB7TnVtYmVyfVxuXHQgKiAgQHN0YXRpY1xuXHQgKiAgQG1lbWJlck9mIFRvbmVcblx0ICovXG5cdFRvbmUuZGJUb0dhaW4gPSBmdW5jdGlvbihkYil7XG5cdFx0cmV0dXJuIE1hdGgucG93KDEwLCBkYiAvIDIwKTtcblx0fTtcblxuXHQvKipcblx0ICogIENvbnZlcnQgZ2FpbiB0byBkZWNpYmVscy5cblx0ICogIEBwYXJhbSAge051bWJlcn0gZ2FpbiAoMC0xKVxuXHQgKiAgQHJldHVybiB7RGVjaWJlbHN9XG5cdCAqICBAc3RhdGljXG5cdCAqICBAbWVtYmVyT2YgVG9uZVxuXHQgKi9cblx0VG9uZS5nYWluVG9EYiA9IGZ1bmN0aW9uKGdhaW4pe1xuXHRcdHJldHVybiAyMCAqIChNYXRoLmxvZyhnYWluKSAvIE1hdGguTE4xMCk7XG5cdH07XG5cblx0LyoqXG5cdCAqICBDb252ZXJ0IGFuIGludGVydmFsIChpbiBzZW1pdG9uZXMpIHRvIGEgZnJlcXVlbmN5IHJhdGlvLlxuXHQgKiAgQHBhcmFtICB7SW50ZXJ2YWx9IGludGVydmFsIHRoZSBudW1iZXIgb2Ygc2VtaXRvbmVzIGFib3ZlIHRoZSBiYXNlIG5vdGVcblx0ICogIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgdGhlIGZyZXF1ZW5jeSByYXRpb1xuXHQgKiAgQHN0YXRpY1xuXHQgKiAgQG1lbWJlck9mIFRvbmVcblx0ICogIEBleGFtcGxlXG5cdCAqIHRvbmUuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvKDApOyAvLyAxXG5cdCAqIHRvbmUuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvKDEyKTsgLy8gMlxuXHQgKiB0b25lLmludGVydmFsVG9GcmVxdWVuY3lSYXRpbygtMTIpOyAvLyAwLjVcblx0ICovXG5cdFRvbmUuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvID0gZnVuY3Rpb24oaW50ZXJ2YWwpe1xuXHRcdHJldHVybiBNYXRoLnBvdygyLCAoaW50ZXJ2YWwvMTIpKTtcblx0fTtcblxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly9cdFRJTUlOR1xuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHQvKipcblx0ICogIFJldHVybiB0aGUgY3VycmVudCB0aW1lIG9mIHRoZSBBdWRpb0NvbnRleHQgY2xvY2suXG5cdCAqICBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBjdXJyZW50VGltZSBmcm9tIHRoZSBBdWRpb0NvbnRleHRcblx0ICogIEBtZW1iZXJPZiBUb25lI1xuXHQgKi9cblx0VG9uZS5wcm90b3R5cGUubm93ID0gZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gVG9uZS5jb250ZXh0Lm5vdygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgUmV0dXJuIHRoZSBjdXJyZW50IHRpbWUgb2YgdGhlIEF1ZGlvQ29udGV4dCBjbG9jay5cblx0ICogIEByZXR1cm4ge051bWJlcn0gdGhlIGN1cnJlbnRUaW1lIGZyb20gdGhlIEF1ZGlvQ29udGV4dFxuXHQgKiAgQHN0YXRpY1xuXHQgKiAgQG1lbWJlck9mIFRvbmVcblx0ICovXG5cdFRvbmUubm93ID0gZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gVG9uZS5jb250ZXh0Lm5vdygpO1xuXHR9O1xuXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvL1x0SU5IRVJJVEFOQ0Vcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblx0LyoqXG5cdCAqICBoYXZlIGEgY2hpbGQgaW5oZXJpdCBhbGwgb2YgVG9uZSdzIChvciBhIHBhcmVudCdzKSBwcm90b3R5cGVcblx0ICogIHRvIGluaGVyaXQgdGhlIHBhcmVudCdzIHByb3BlcnRpZXMsIG1ha2Ugc3VyZSB0byBjYWxsXG5cdCAqICBQYXJlbnQuY2FsbCh0aGlzKSBpbiB0aGUgY2hpbGQncyBjb25zdHJ1Y3RvclxuXHQgKlxuXHQgKiAgYmFzZWQgb24gY2xvc3VyZSBsaWJyYXJ5J3MgaW5oZXJpdCBmdW5jdGlvblxuXHQgKlxuXHQgKiAgQG1lbWJlck9mIFRvbmVcblx0ICogIEBzdGF0aWNcblx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSBcdGNoaWxkXG5cdCAqICBAcGFyYW0gIHtGdW5jdGlvbj19IHBhcmVudCAob3B0aW9uYWwpIHBhcmVudCB0byBpbmhlcml0IGZyb21cblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIG5vIHBhcmVudCBpcyBzdXBwbGllZCwgdGhlIGNoaWxkXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGluaGVyaXQgZnJvbSBUb25lXG5cdCAqL1xuXHRUb25lLmV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpe1xuXHRcdGlmIChUb25lLmlzVW5kZWYocGFyZW50KSl7XG5cdFx0XHRwYXJlbnQgPSBUb25lO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBUZW1wQ29uc3RydWN0b3IoKXt9XG5cdFx0VGVtcENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG5cdFx0Y2hpbGQucHJvdG90eXBlID0gbmV3IFRlbXBDb25zdHJ1Y3RvcigpO1xuXHRcdC8qKiBAb3ZlcnJpZGUgKi9cblx0XHRjaGlsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjaGlsZDtcblx0XHRjaGlsZC5fc3VwZXIgPSBwYXJlbnQ7XG5cdH07XG5cblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vXHRDT05URVhUXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cdC8qKlxuXHQgKiAgUHJpdmF0ZSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBBdWRpb0NvbnRleHRcblx0ICogIEB0eXBlIHtBdWRpb0NvbnRleHR9XG5cdCAqICBAcHJpdmF0ZVxuXHQgKi9cblx0dmFyIGF1ZGlvQ29udGV4dCA9IG51bGw7XG5cblx0LyoqXG5cdCAqICBBIHN0YXRpYyBwb2ludGVyIHRvIHRoZSBhdWRpbyBjb250ZXh0IGFjY2Vzc2libGUgYXMgVG9uZS5jb250ZXh0LlxuXHQgKiAgQHR5cGUge1RvbmUuQ29udGV4dH1cblx0ICogIEBuYW1lIGNvbnRleHRcblx0ICogIEBtZW1iZXJPZiBUb25lXG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZSwgXCJjb250ZXh0XCIsIHtcblx0XHRnZXQgOiBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIGF1ZGlvQ29udGV4dDtcblx0XHR9LFxuXHRcdHNldCA6IGZ1bmN0aW9uKGNvbnRleHQpe1xuXHRcdFx0aWYgKFRvbmUuQ29udGV4dCAmJiBjb250ZXh0IGluc3RhbmNlb2YgVG9uZS5Db250ZXh0KXtcblx0XHRcdFx0YXVkaW9Db250ZXh0ID0gY29udGV4dDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF1ZGlvQ29udGV4dCA9IG5ldyBUb25lLkNvbnRleHQoY29udGV4dCk7XG5cdFx0XHR9XG5cdFx0XHQvL2luaXRpYWxpemUgdGhlIG5ldyBhdWRpbyBjb250ZXh0XG5cdFx0XHRUb25lLkNvbnRleHQuZW1pdChcImluaXRcIiwgYXVkaW9Db250ZXh0KTtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiAgVGhlIEF1ZGlvQ29udGV4dFxuXHQgKiAgQHR5cGUge1RvbmUuQ29udGV4dH1cblx0ICogIEBuYW1lIGNvbnRleHRcblx0ICogIEBtZW1iZXJPZiBUb25lI1xuXHQgKiAgQHJlYWRPbmx5XG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB7XG5cdFx0Z2V0IDogZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiBUb25lLmNvbnRleHQ7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogIFRvbmUgYXV0b21hdGljYWxseSBjcmVhdGVzIGEgY29udGV4dCBvbiBpbml0LCBidXQgaWYgeW91IGFyZSB3b3JraW5nXG5cdCAqICB3aXRoIG90aGVyIGxpYnJhcmllcyB3aGljaCBhbHNvIGNyZWF0ZSBhbiBBdWRpb0NvbnRleHQsIGl0IGNhbiBiZVxuXHQgKiAgdXNlZnVsIHRvIHNldCB5b3VyIG93bi4gSWYgeW91IGFyZSBnb2luZyB0byBzZXQgeW91ciBvd24gY29udGV4dCxcblx0ICogIGJlIHN1cmUgdG8gZG8gaXQgYXQgdGhlIHN0YXJ0IG9mIHlvdXIgY29kZSwgYmVmb3JlIGNyZWF0aW5nIGFueSBvYmplY3RzLlxuXHQgKiAgQHN0YXRpY1xuXHQgKiAgQHBhcmFtIHtBdWRpb0NvbnRleHR9IGN0eCBUaGUgbmV3IGF1ZGlvIGNvbnRleHQgdG8gc2V0XG5cdCAqL1xuXHRUb25lLnNldENvbnRleHQgPSBmdW5jdGlvbihjdHgpe1xuXHRcdFRvbmUuY29udGV4dCA9IGN0eDtcblx0fTtcblxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly9cdEFUVFJJQlVURVNcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblx0LyoqXG5cdCAqICBUaGUgbnVtYmVyIG9mIHNlY29uZHMgb2YgMSBwcm9jZXNzaW5nIGJsb2NrICgxMjggc2FtcGxlcylcblx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdCAqICBAbmFtZSBibG9ja1RpbWVcblx0ICogIEBtZW1iZXJPZiBUb25lXG5cdCAqICBAc3RhdGljXG5cdCAqICBAcmVhZE9ubHlcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLnByb3RvdHlwZSwgXCJibG9ja1RpbWVcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gMTI4IC8gdGhpcy5jb250ZXh0LnNhbXBsZVJhdGU7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogIFRoZSBkdXJhdGlvbiBpbiBzZWNvbmRzIG9mIG9uZSBzYW1wbGUuXG5cdCAqICBAdHlwZSB7TnVtYmVyfVxuXHQgKiAgQG5hbWUgc2FtcGxlVGltZVxuXHQgKiAgQG1lbWJlck9mIFRvbmVcblx0ICogIEBzdGF0aWNcblx0ICogIEByZWFkT25seVxuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUucHJvdG90eXBlLCBcInNhbXBsZVRpbWVcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gMSAvIHRoaXMuY29udGV4dC5zYW1wbGVSYXRlO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqICBXaGV0aGVyIG9yIG5vdCBhbGwgdGhlIHRlY2hub2xvZ2llcyB0aGF0IFRvbmUuanMgcmVsaWVzIG9uIGFyZSBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgYnJvd3Nlci5cblx0ICogIEB0eXBlIHtCb29sZWFufVxuXHQgKiAgQG5hbWUgc3VwcG9ydGVkXG5cdCAqICBAbWVtYmVyT2YgVG9uZVxuXHQgKiAgQHJlYWRPbmx5XG5cdCAqICBAc3RhdGljXG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZSwgXCJzdXBwb3J0ZWRcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgaGFzQXVkaW9Db250ZXh0ID0gd2luZG93Lmhhc093blByb3BlcnR5KFwiQXVkaW9Db250ZXh0XCIpIHx8IHdpbmRvdy5oYXNPd25Qcm9wZXJ0eShcIndlYmtpdEF1ZGlvQ29udGV4dFwiKTtcblx0XHRcdHZhciBoYXNQcm9taXNlcyA9IHdpbmRvdy5oYXNPd25Qcm9wZXJ0eShcIlByb21pc2VcIik7XG5cdFx0XHR2YXIgaGFzV29ya2VycyA9IHdpbmRvdy5oYXNPd25Qcm9wZXJ0eShcIldvcmtlclwiKTtcblx0XHRcdHJldHVybiBoYXNBdWRpb0NvbnRleHQgJiYgaGFzUHJvbWlzZXMgJiYgaGFzV29ya2Vycztcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiAgQm9vbGVhbiB2YWx1ZSBpZiB0aGUgYXVkaW8gY29udGV4dCBoYXMgYmVlbiBpbml0aWFsaXplZC5cblx0ICogIEB0eXBlIHtCb29sZWFufVxuXHQgKiAgQG1lbWJlck9mIFRvbmVcblx0ICogIEBzdGF0aWNcblx0ICogIEBuYW1lIGluaXRpYWxpemVkXG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZSwgXCJpbml0aWFsaXplZFwiLCB7XG5cdFx0Z2V0IDogZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiBhdWRpb0NvbnRleHQgIT09IG51bGw7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogIEdldCB0aGUgY29udGV4dCB3aGVuIGl0IGJlY29tZXMgYXZhaWxhYmxlXG5cdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIHJlc29sdmUgIENhbGxiYWNrIHdoZW4gdGhlIGNvbnRleHQgaXMgaW5pdGlhbGl6ZWRcblx0ICogIEByZXR1cm4gIHtUb25lfVxuXHQgKi9cblx0VG9uZS5nZXRDb250ZXh0ID0gZnVuY3Rpb24ocmVzb2x2ZSl7XG5cdFx0aWYgKFRvbmUuaW5pdGlhbGl6ZWQpe1xuXHRcdFx0cmVzb2x2ZShUb25lLmNvbnRleHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcmVzQ2FsbGJhY2sgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRyZXNvbHZlKFRvbmUuY29udGV4dCk7XG5cdFx0XHRcdFRvbmUuQ29udGV4dC5vZmYoXCJpbml0XCIsIHJlc0NhbGxiYWNrKTtcblx0XHRcdH07XG5cdFx0XHRUb25lLkNvbnRleHQub24oXCJpbml0XCIsIHJlc0NhbGxiYWNrKTtcblx0XHR9XG5cdFx0cmV0dXJuIFRvbmU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSB2ZXJzaW9uIG51bWJlclxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXG5cdFRvbmUudmVyc2lvbiA9IFwicjEyXCI7XG5cblx0cmV0dXJuIFRvbmU7XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQU1BO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU9BO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFLQTtBQUVBOzs7Ozs7O0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQVRBO0FBQUE7QUFKQTtBQWVBOzs7Ozs7OztBQU9BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFEQTtBQU1BOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFEQTtBQU1BOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBREE7QUFNQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFBQTtBQURBO0FBU0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQURBO0FBTUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7OztBQU1BO0FBRUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/core/Tone.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/core/Transport.js":
/*!**************************************************!*\
  !*** ./node_modules/tone/Tone/core/Transport.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/core/Clock */ \"./node_modules/tone/Tone/core/Clock.js\"), __webpack_require__(/*! Tone/type/Type */ \"./node_modules/tone/Tone/type/Type.js\"), __webpack_require__(/*! Tone/core/Timeline */ \"./node_modules/tone/Tone/core/Timeline.js\"), __webpack_require__(/*! Tone/core/Emitter */ \"./node_modules/tone/Tone/core/Emitter.js\"), __webpack_require__(/*! Tone/core/Gain */ \"./node_modules/tone/Tone/core/Gain.js\"), __webpack_require__(/*! Tone/core/IntervalTimeline */ \"./node_modules/tone/Tone/core/IntervalTimeline.js\"), __webpack_require__(/*! Tone/core/TransportRepeatEvent */ \"./node_modules/tone/Tone/core/TransportRepeatEvent.js\"), __webpack_require__(/*! Tone/core/TransportEvent */ \"./node_modules/tone/Tone/core/TransportEvent.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  \"use strict\";\n  /**\n   *  @class  Transport for timing musical events.\n   *          Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n   *          Tone.Transport timing events pass in the exact time of the scheduled event\n   *          in the argument of the callback function. Pass that time value to the object\n   *          you're scheduling. <br><br>\n   *          A single transport is created for you when the library is initialized.\n   *          <br><br>\n   *          The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n   *          called with the time of that event as the argument.\n   *\n   *  @extends {Tone.Emitter}\n   *  @singleton\n   *  @example\n   * //repeated event every 8th note\n   * Tone.Transport.scheduleRepeat(function(time){\n   * \t//do something with the time\n   * }, \"8n\");\n   *  @example\n   * //schedule an event on the 16th measure\n   * Tone.Transport.schedule(function(time){\n   * \t//do something with the time\n   * }, \"16:0:0\");\n   */\n\n  Tone.Transport = function () {\n    Tone.Emitter.call(this);\n    Tone.getContext(function () {\n      ///////////////////////////////////////////////////////////////////////\n      //\tLOOPING\n      //////////////////////////////////////////////////////////////////////\n\n      /**\n       * \tIf the transport loops or not.\n       *  @type {boolean}\n       */\n      this.loop = false;\n      /**\n       * \tThe loop start position in ticks\n       *  @type {Ticks}\n       *  @private\n       */\n\n      this._loopStart = 0;\n      /**\n       * \tThe loop end position in ticks\n       *  @type {Ticks}\n       *  @private\n       */\n\n      this._loopEnd = 0; ///////////////////////////////////////////////////////////////////////\n      //\tCLOCK/TEMPO\n      //////////////////////////////////////////////////////////////////////\n\n      /**\n       *  Pulses per quarter is the number of ticks per quarter note.\n       *  @private\n       *  @type  {Number}\n       */\n\n      this._ppq = TransportConstructor.defaults.PPQ;\n      /**\n       *  watches the main oscillator for timing ticks\n       *  initially starts at 120bpm\n       *  @private\n       *  @type {Tone.Clock}\n       */\n\n      this._clock = new Tone.Clock({\n        \"callback\": this._processTick.bind(this),\n        \"frequency\": 0\n      });\n\n      this._bindClockEvents();\n      /**\n       *  The Beats Per Minute of the Transport.\n       *  @type {BPM}\n       *  @signal\n       *  @example\n       * Tone.Transport.bpm.value = 80;\n       * //ramp the bpm to 120 over 10 seconds\n       * Tone.Transport.bpm.rampTo(120, 10);\n       */\n\n\n      this.bpm = this._clock.frequency;\n      this.bpm._toUnits = this._toUnits.bind(this);\n      this.bpm._fromUnits = this._fromUnits.bind(this);\n      this.bpm.units = Tone.Type.BPM;\n      this.bpm.value = TransportConstructor.defaults.bpm;\n\n      this._readOnly(\"bpm\");\n      /**\n       *  The time signature, or more accurately the numerator\n       *  of the time signature over a denominator of 4.\n       *  @type {Number}\n       *  @private\n       */\n\n\n      this._timeSignature = TransportConstructor.defaults.timeSignature; ///////////////////////////////////////////////////////////////////////\n      //\tTIMELINE EVENTS\n      //////////////////////////////////////////////////////////////////////\n\n      /**\n       *  All the events in an object to keep track by ID\n       *  @type {Object}\n       *  @private\n       */\n\n      this._scheduledEvents = {};\n      /**\n       * \tThe scheduled events.\n       *  @type {Tone.Timeline}\n       *  @private\n       */\n\n      this._timeline = new Tone.Timeline();\n      /**\n       *  Repeated events\n       *  @type {Array}\n       *  @private\n       */\n\n      this._repeatedEvents = new Tone.IntervalTimeline();\n      /**\n       *  All of the synced Signals\n       *  @private\n       *  @type {Array}\n       */\n\n      this._syncedSignals = []; ///////////////////////////////////////////////////////////////////////\n      //\tSWING\n      //////////////////////////////////////////////////////////////////////\n\n      /**\n       *  The subdivision of the swing\n       *  @type  {Ticks}\n       *  @private\n       */\n\n      this._swingTicks = TransportConstructor.defaults.PPQ / 2; //8n\n\n      /**\n       *  The swing amount\n       *  @type {NormalRange}\n       *  @private\n       */\n\n      this._swingAmount = 0;\n    }.bind(this));\n  };\n\n  Tone.extend(Tone.Transport, Tone.Emitter);\n  /**\n   *  the defaults\n   *  @type {Object}\n   *  @const\n   *  @static\n   */\n\n  Tone.Transport.defaults = {\n    \"bpm\": 120,\n    \"swing\": 0,\n    \"swingSubdivision\": \"8n\",\n    \"timeSignature\": 4,\n    \"loopStart\": 0,\n    \"loopEnd\": \"4m\",\n    \"PPQ\": 192\n  }; ///////////////////////////////////////////////////////////////////////////////\n  //\tTICKS\n  ///////////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  called on every tick\n   *  @param   {number} tickTime clock relative tick time\n   *  @private\n   */\n\n  Tone.Transport.prototype._processTick = function (tickTime, ticks) {\n    //handle swing\n    if (this._swingAmount > 0 && ticks % this._ppq !== 0 && //not on a downbeat\n    ticks % (this._swingTicks * 2) !== 0) {\n      //add some swing\n      var progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);\n\n      var amount = Math.sin(progress * Math.PI) * this._swingAmount;\n\n      tickTime += Tone.Ticks(this._swingTicks * 2 / 3).toSeconds() * amount;\n    } //do the loop test\n\n\n    if (this.loop) {\n      if (ticks >= this._loopEnd) {\n        this.emit(\"loopEnd\", tickTime);\n\n        this._clock.setTicksAtTime(this._loopStart, tickTime);\n\n        ticks = this._loopStart;\n        this.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n        this.emit(\"loop\", tickTime);\n      }\n    } //invoke the timeline events scheduled on this tick\n\n\n    this._timeline.forEachAtTime(ticks, function (event) {\n      event.invoke(tickTime);\n    });\n  }; ///////////////////////////////////////////////////////////////////////////////\n  //\tSCHEDULABLE EVENTS\n  ///////////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  Schedule an event along the timeline.\n   *  @param {Function} callback The callback to be invoked at the time.\n   *  @param {TransportTime}  time The time to invoke the callback at.\n   *  @return {Number} The id of the event which can be used for canceling the event.\n   *  @example\n   * //trigger the callback when the Transport reaches the desired time\n   * Tone.Transport.schedule(function(time){\n   * \tenvelope.triggerAttack(time);\n   * }, \"128i\");\n   */\n\n\n  Tone.Transport.prototype.schedule = function (callback, time) {\n    var event = new Tone.TransportEvent(this, {\n      \"time\": Tone.TransportTime(time),\n      \"callback\": callback\n    });\n    return this._addEvent(event, this._timeline);\n  };\n  /**\n   *  Schedule a repeated event along the timeline. The event will fire\n   *  at the `interval` starting at the `startTime` and for the specified\n   *  `duration`.\n   *  @param  {Function}  callback   The callback to invoke.\n   *  @param  {Time}    interval   The duration between successive\n   *                               callbacks. Must be a positive number.\n   *  @param  {TransportTime=}    startTime  When along the timeline the events should\n   *                               start being invoked.\n   *  @param {Time} [duration=Infinity] How long the event should repeat.\n   *  @return  {Number}    The ID of the scheduled event. Use this to cancel\n   *                           the event.\n   *  @example\n   * //a callback invoked every eighth note after the first measure\n   * Tone.Transport.scheduleRepeat(callback, \"8n\", \"1m\");\n   */\n\n\n  Tone.Transport.prototype.scheduleRepeat = function (callback, interval, startTime, duration) {\n    var event = new Tone.TransportRepeatEvent(this, {\n      \"callback\": callback,\n      \"interval\": Tone.Time(interval),\n      \"time\": Tone.TransportTime(startTime),\n      \"duration\": Tone.Time(Tone.defaultArg(duration, Infinity))\n    }); //kick it off if the Transport is started\n\n    return this._addEvent(event, this._repeatedEvents);\n  };\n  /**\n   *  Schedule an event that will be removed after it is invoked.\n   *  Note that if the given time is less than the current transport time,\n   *  the event will be invoked immediately.\n   *  @param {Function} callback The callback to invoke once.\n   *  @param {TransportTime} time The time the callback should be invoked.\n   *  @returns {Number} The ID of the scheduled event.\n   */\n\n\n  Tone.Transport.prototype.scheduleOnce = function (callback, time) {\n    var event = new Tone.TransportEvent(this, {\n      \"time\": Tone.TransportTime(time),\n      \"callback\": callback,\n      \"once\": true\n    });\n    return this._addEvent(event, this._timeline);\n  };\n  /**\n   *  Clear the passed in event id from the timeline\n   *  @param {Number} eventId The id of the event.\n   *  @returns {Tone.Transport} this\n   */\n\n\n  Tone.Transport.prototype.clear = function (eventId) {\n    if (this._scheduledEvents.hasOwnProperty(eventId)) {\n      var item = this._scheduledEvents[eventId.toString()];\n\n      item.timeline.remove(item.event);\n      item.event.dispose();\n      delete this._scheduledEvents[eventId.toString()];\n    }\n\n    return this;\n  };\n  /**\n   * Add an event to the correct timeline. Keep track of the\n   * timeline it was added to.\n   * @param {Tone.TransportEvent}\tevent\n   * @param {Tone.Timeline} timeline\n   * @returns {Number} the event id which was just added\n   * @private\n   */\n\n\n  Tone.Transport.prototype._addEvent = function (event, timeline) {\n    this._scheduledEvents[event.id.toString()] = {\n      \"event\": event,\n      \"timeline\": timeline\n    };\n    timeline.add(event);\n    return event.id;\n  };\n  /**\n   *  Remove scheduled events from the timeline after\n   *  the given time. Repeated events will be removed\n   *  if their startTime is after the given time\n   *  @param {TransportTime} [after=0] Clear all events after\n   *                          this time.\n   *  @returns {Tone.Transport} this\n   */\n\n\n  Tone.Transport.prototype.cancel = function (after) {\n    after = Tone.defaultArg(after, 0);\n    after = this.toTicks(after);\n\n    this._timeline.forEachFrom(after, function (event) {\n      this.clear(event.id);\n    }.bind(this));\n\n    this._repeatedEvents.forEachFrom(after, function (event) {\n      this.clear(event.id);\n    }.bind(this));\n\n    return this;\n  }; ///////////////////////////////////////////////////////////////////////////////\n  //\tSTART/STOP/PAUSE\n  ///////////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  Bind start/stop/pause events from the clock and emit them.\n   *  @private\n   */\n\n\n  Tone.Transport.prototype._bindClockEvents = function () {\n    this._clock.on(\"start\", function (time, offset) {\n      offset = Tone.Ticks(offset).toSeconds();\n      this.emit(\"start\", time, offset);\n    }.bind(this));\n\n    this._clock.on(\"stop\", function (time) {\n      this.emit(\"stop\", time);\n    }.bind(this));\n\n    this._clock.on(\"pause\", function (time) {\n      this.emit(\"pause\", time);\n    }.bind(this));\n  };\n  /**\n   *  Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n   *  @type {Tone.State}\n   *  @readOnly\n   *  @memberOf Tone.Transport#\n   *  @name state\n   */\n\n\n  Object.defineProperty(Tone.Transport.prototype, \"state\", {\n    get: function () {\n      function get() {\n        return this._clock.getStateAtTime(this.now());\n      }\n\n      return get;\n    }()\n  });\n  /**\n   *  Start the transport and all sources synced to the transport.\n   *  @param  {Time} [time=now] The time when the transport should start.\n   *  @param  {TransportTime=} offset The timeline offset to start the transport.\n   *  @returns {Tone.Transport} this\n   *  @example\n   * //start the transport in one second starting at beginning of the 5th measure.\n   * Tone.Transport.start(\"+1\", \"4:0:0\");\n   */\n\n  Tone.Transport.prototype.start = function (time, offset) {\n    //start the clock\n    if (Tone.isDefined(offset)) {\n      offset = this.toTicks(offset);\n    }\n\n    this._clock.start(time, offset);\n\n    return this;\n  };\n  /**\n   *  Stop the transport and all sources synced to the transport.\n   *  @param  {Time} [time=now] The time when the transport should stop.\n   *  @returns {Tone.Transport} this\n   *  @example\n   * Tone.Transport.stop();\n   */\n\n\n  Tone.Transport.prototype.stop = function (time) {\n    this._clock.stop(time);\n\n    return this;\n  };\n  /**\n   *  Pause the transport and all sources synced to the transport.\n   *  @param  {Time} [time=now]\n   *  @returns {Tone.Transport} this\n   */\n\n\n  Tone.Transport.prototype.pause = function (time) {\n    this._clock.pause(time);\n\n    return this;\n  };\n  /**\n   * Toggle the current state of the transport. If it is\n   * started, it will stop it, otherwise it will start the Transport.\n   * @param  {Time=} time The time of the event\n   * @return {Tone.Transport}      this\n   */\n\n\n  Tone.Transport.prototype.toggle = function (time) {\n    time = this.toSeconds(time);\n\n    if (this._clock.getStateAtTime(time) !== Tone.State.Started) {\n      this.start(time);\n    } else {\n      this.stop(time);\n    }\n\n    return this;\n  }; ///////////////////////////////////////////////////////////////////////////////\n  //\tSETTERS/GETTERS\n  ///////////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  The time signature as just the numerator over 4.\n   *  For example 4/4 would be just 4 and 6/8 would be 3.\n   *  @memberOf Tone.Transport#\n   *  @type {Number|Array}\n   *  @name timeSignature\n   *  @example\n   * //common time\n   * Tone.Transport.timeSignature = 4;\n   * // 7/8\n   * Tone.Transport.timeSignature = [7, 8];\n   * //this will be reduced to a single number\n   * Tone.Transport.timeSignature; //returns 3.5\n   */\n\n\n  Object.defineProperty(Tone.Transport.prototype, \"timeSignature\", {\n    get: function () {\n      function get() {\n        return this._timeSignature;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(timeSig) {\n        if (Tone.isArray(timeSig)) {\n          timeSig = timeSig[0] / timeSig[1] * 4;\n        }\n\n        this._timeSignature = timeSig;\n      }\n\n      return set;\n    }()\n  });\n  /**\n   * When the Tone.Transport.loop = true, this is the starting position of the loop.\n   * @memberOf Tone.Transport#\n   * @type {Time}\n   * @name loopStart\n   */\n\n  Object.defineProperty(Tone.Transport.prototype, \"loopStart\", {\n    get: function () {\n      function get() {\n        return Tone.Ticks(this._loopStart).toSeconds();\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(startPosition) {\n        this._loopStart = this.toTicks(startPosition);\n      }\n\n      return set;\n    }()\n  });\n  /**\n   * When the Tone.Transport.loop = true, this is the ending position of the loop.\n   * @memberOf Tone.Transport#\n   * @type {Time}\n   * @name loopEnd\n   */\n\n  Object.defineProperty(Tone.Transport.prototype, \"loopEnd\", {\n    get: function () {\n      function get() {\n        return Tone.Ticks(this._loopEnd).toSeconds();\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(endPosition) {\n        this._loopEnd = this.toTicks(endPosition);\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  Set the loop start and stop at the same time.\n   *  @param {TransportTime} startPosition\n   *  @param {TransportTime} endPosition\n   *  @returns {Tone.Transport} this\n   *  @example\n   * //loop over the first measure\n   * Tone.Transport.setLoopPoints(0, \"1m\");\n   * Tone.Transport.loop = true;\n   */\n\n  Tone.Transport.prototype.setLoopPoints = function (startPosition, endPosition) {\n    this.loopStart = startPosition;\n    this.loopEnd = endPosition;\n    return this;\n  };\n  /**\n   *  The swing value. Between 0-1 where 1 equal to\n   *  the note + half the subdivision.\n   *  @memberOf Tone.Transport#\n   *  @type {NormalRange}\n   *  @name swing\n   */\n\n\n  Object.defineProperty(Tone.Transport.prototype, \"swing\", {\n    get: function () {\n      function get() {\n        return this._swingAmount;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(amount) {\n        //scale the values to a normal range\n        this._swingAmount = amount;\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  Set the subdivision which the swing will be applied to.\n   *  The default value is an 8th note. Value must be less\n   *  than a quarter note.\n   *\n   *  @memberOf Tone.Transport#\n   *  @type {Time}\n   *  @name swingSubdivision\n   */\n\n  Object.defineProperty(Tone.Transport.prototype, \"swingSubdivision\", {\n    get: function () {\n      function get() {\n        return Tone.Ticks(this._swingTicks).toNotation();\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(subdivision) {\n        this._swingTicks = this.toTicks(subdivision);\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  The Transport's position in Bars:Beats:Sixteenths.\n   *  Setting the value will jump to that position right away.\n   *  @memberOf Tone.Transport#\n   *  @type {BarsBeatsSixteenths}\n   *  @name position\n   */\n\n  Object.defineProperty(Tone.Transport.prototype, \"position\", {\n    get: function () {\n      function get() {\n        var now = this.now();\n\n        var ticks = this._clock.getTicksAtTime(now);\n\n        return Tone.Ticks(ticks).toBarsBeatsSixteenths();\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(progress) {\n        var ticks = this.toTicks(progress);\n        this.ticks = ticks;\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  The Transport's position in seconds\n   *  Setting the value will jump to that position right away.\n   *  @memberOf Tone.Transport#\n   *  @type {Seconds}\n   *  @name seconds\n   */\n\n  Object.defineProperty(Tone.Transport.prototype, \"seconds\", {\n    get: function () {\n      function get() {\n        return this._clock.seconds;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(s) {\n        var now = this.now();\n        var ticks = this.bpm.timeToTicks(s, now);\n        this.ticks = ticks;\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  The Transport's loop position as a normalized value. Always\n   *  returns 0 if the transport if loop is not true.\n   *  @memberOf Tone.Transport#\n   *  @name progress\n   *  @type {NormalRange}\n   */\n\n  Object.defineProperty(Tone.Transport.prototype, \"progress\", {\n    get: function () {\n      function get() {\n        if (this.loop) {\n          var now = this.now();\n\n          var ticks = this._clock.getTicksAtTime(now);\n\n          return (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n        } else {\n          return 0;\n        }\n      }\n\n      return get;\n    }()\n  });\n  /**\n   *  The transports current tick position.\n   *\n   *  @memberOf Tone.Transport#\n   *  @type {Ticks}\n   *  @name ticks\n   */\n\n  Object.defineProperty(Tone.Transport.prototype, \"ticks\", {\n    get: function () {\n      function get() {\n        return this._clock.ticks;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(t) {\n        if (this._clock.ticks !== t) {\n          var now = this.now(); //stop everything synced to the transport\n\n          if (this.state === Tone.State.Started) {\n            this.emit(\"stop\", now);\n\n            this._clock.setTicksAtTime(t, now); //restart it with the new time\n\n\n            this.emit(\"start\", now, this.seconds);\n          } else {\n            this._clock.setTicksAtTime(t, now);\n          }\n        }\n      }\n\n      return set;\n    }()\n  });\n  /**\n   * Get the clock's ticks at the given time.\n   * @param  {Time} time  When to get the tick value\n   * @return {Ticks}       The tick value at the given time.\n   */\n\n  Tone.Transport.prototype.getTicksAtTime = function (time) {\n    return Math.round(this._clock.getTicksAtTime(time));\n  };\n  /**\n   *  Return the elapsed seconds at the given time.\n   *  @param  {Time}  time  When to get the elapsed seconds\n   *  @return  {Seconds}  The number of elapsed seconds\n   */\n\n\n  Tone.Transport.prototype.getSecondsAtTime = function (time) {\n    return this._clock.getSecondsAtTime(time);\n  };\n  /**\n   *  Pulses Per Quarter note. This is the smallest resolution\n   *  the Transport timing supports. This should be set once\n   *  on initialization and not set again. Changing this value\n   *  after other objects have been created can cause problems.\n   *\n   *  @memberOf Tone.Transport#\n   *  @type {Number}\n   *  @name PPQ\n   */\n\n\n  Object.defineProperty(Tone.Transport.prototype, \"PPQ\", {\n    get: function () {\n      function get() {\n        return this._ppq;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(ppq) {\n        var bpm = this.bpm.value;\n        this._ppq = ppq;\n        this.bpm.value = bpm;\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  Convert from BPM to frequency (factoring in PPQ)\n   *  @param  {BPM}  bpm The BPM value to convert to frequency\n   *  @return  {Frequency}  The BPM as a frequency with PPQ factored in.\n   *  @private\n   */\n\n  Tone.Transport.prototype._fromUnits = function (bpm) {\n    return 1 / (60 / bpm / this.PPQ);\n  };\n  /**\n   *  Convert from frequency (with PPQ) into BPM\n   *  @param  {Frequency}  freq The clocks frequency to convert to BPM\n   *  @return  {BPM}  The frequency value as BPM.\n   *  @private\n   */\n\n\n  Tone.Transport.prototype._toUnits = function (freq) {\n    return freq / this.PPQ * 60;\n  }; ///////////////////////////////////////////////////////////////////////////////\n  //\tSYNCING\n  ///////////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  Returns the time aligned to the next subdivision\n   *  of the Transport. If the Transport is not started,\n   *  it will return 0.\n   *  Note: this will not work precisely during tempo ramps.\n   *  @param  {Time}  subdivision  The subdivision to quantize to\n   *  @return  {Number}  The context time of the next subdivision.\n   *  @example\n   * Tone.Transport.start(); //the transport must be started\n   * Tone.Transport.nextSubdivision(\"4n\");\n   */\n\n\n  Tone.Transport.prototype.nextSubdivision = function (subdivision) {\n    subdivision = this.toTicks(subdivision);\n\n    if (this.state !== Tone.State.Started) {\n      //if the transport's not started, return 0\n      return 0;\n    } else {\n      var now = this.now(); //the remainder of the current ticks and the subdivision\n\n      var transportPos = this.getTicksAtTime(now);\n      var remainingTicks = subdivision - transportPos % subdivision;\n      return this._clock.nextTickTime(remainingTicks, now);\n    }\n  };\n  /**\n   *  Attaches the signal to the tempo control signal so that\n   *  any changes in the tempo will change the signal in the same\n   *  ratio.\n   *\n   *  @param  {Tone.Signal} signal\n   *  @param {number=} ratio Optionally pass in the ratio between\n   *                         the two signals. Otherwise it will be computed\n   *                         based on their current values.\n   *  @returns {Tone.Transport} this\n   */\n\n\n  Tone.Transport.prototype.syncSignal = function (signal, ratio) {\n    if (!ratio) {\n      //get the sync ratio\n      var now = this.now();\n\n      if (signal.getValueAtTime(now) !== 0) {\n        ratio = signal.getValueAtTime(now) / this.bpm.getValueAtTime(now);\n      } else {\n        ratio = 0;\n      }\n    }\n\n    var ratioSignal = new Tone.Gain(ratio);\n    this.bpm.chain(ratioSignal, signal._param);\n\n    this._syncedSignals.push({\n      \"ratio\": ratioSignal,\n      \"signal\": signal,\n      \"initial\": signal.value\n    });\n\n    signal.value = 0;\n    return this;\n  };\n  /**\n   *  Unsyncs a previously synced signal from the transport's control.\n   *  See Tone.Transport.syncSignal.\n   *  @param  {Tone.Signal} signal\n   *  @returns {Tone.Transport} this\n   */\n\n\n  Tone.Transport.prototype.unsyncSignal = function (signal) {\n    for (var i = this._syncedSignals.length - 1; i >= 0; i--) {\n      var syncedSignal = this._syncedSignals[i];\n\n      if (syncedSignal.signal === signal) {\n        syncedSignal.ratio.dispose();\n        syncedSignal.signal.value = syncedSignal.initial;\n\n        this._syncedSignals.splice(i, 1);\n      }\n    }\n\n    return this;\n  };\n  /**\n   *  Clean up.\n   *  @returns {Tone.Transport} this\n   *  @private\n   */\n\n\n  Tone.Transport.prototype.dispose = function () {\n    Tone.Emitter.prototype.dispose.call(this);\n\n    this._clock.dispose();\n\n    this._clock = null;\n\n    this._writable(\"bpm\");\n\n    this.bpm = null;\n\n    this._timeline.dispose();\n\n    this._timeline = null;\n\n    this._repeatedEvents.dispose();\n\n    this._repeatedEvents = null;\n    return this;\n  }; ///////////////////////////////////////////////////////////////////////////////\n  //\tINITIALIZATION\n  ///////////////////////////////////////////////////////////////////////////////\n\n\n  var TransportConstructor = Tone.Transport;\n  Tone.Transport = new TransportConstructor();\n  Tone.Context.on(\"init\", function (context) {\n    if (context.Transport instanceof TransportConstructor) {\n      Tone.Transport = context.Transport;\n    } else {\n      Tone.Transport = new TransportConstructor();\n    } //store the Transport on the context so it can be retrieved later\n\n\n    context.Transport = Tone.Transport;\n  });\n  Tone.Context.on(\"close\", function (context) {\n    if (context.Transport instanceof TransportConstructor) {\n      context.Transport.dispose();\n    }\n  });\n  return Tone.Transport;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvVHJhbnNwb3J0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RvbmUvVG9uZS9jb3JlL1RyYW5zcG9ydC5qcz8yZDNjIl0sInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbXCJUb25lL2NvcmUvVG9uZVwiLCBcIlRvbmUvY29yZS9DbG9ja1wiLCBcIlRvbmUvdHlwZS9UeXBlXCIsIFwiVG9uZS9jb3JlL1RpbWVsaW5lXCIsXG5cdFwiVG9uZS9jb3JlL0VtaXR0ZXJcIiwgXCJUb25lL2NvcmUvR2FpblwiLCBcIlRvbmUvY29yZS9JbnRlcnZhbFRpbWVsaW5lXCIsXG5cdFwiVG9uZS9jb3JlL1RyYW5zcG9ydFJlcGVhdEV2ZW50XCIsIFwiVG9uZS9jb3JlL1RyYW5zcG9ydEV2ZW50XCJdLCBmdW5jdGlvbihUb25lKXtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogIEBjbGFzcyAgVHJhbnNwb3J0IGZvciB0aW1pbmcgbXVzaWNhbCBldmVudHMuXG5cdCAqICAgICAgICAgIFN1cHBvcnRzIHRlbXBvIGN1cnZlcyBhbmQgdGltZSBjaGFuZ2VzLiBVbmxpa2UgYnJvd3Nlci1iYXNlZCB0aW1pbmcgKHNldEludGVydmFsLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpXG5cdCAqICAgICAgICAgIFRvbmUuVHJhbnNwb3J0IHRpbWluZyBldmVudHMgcGFzcyBpbiB0aGUgZXhhY3QgdGltZSBvZiB0aGUgc2NoZWR1bGVkIGV2ZW50XG5cdCAqICAgICAgICAgIGluIHRoZSBhcmd1bWVudCBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uIFBhc3MgdGhhdCB0aW1lIHZhbHVlIHRvIHRoZSBvYmplY3Rcblx0ICogICAgICAgICAgeW91J3JlIHNjaGVkdWxpbmcuIDxicj48YnI+XG5cdCAqICAgICAgICAgIEEgc2luZ2xlIHRyYW5zcG9ydCBpcyBjcmVhdGVkIGZvciB5b3Ugd2hlbiB0aGUgbGlicmFyeSBpcyBpbml0aWFsaXplZC5cblx0ICogICAgICAgICAgPGJyPjxicj5cblx0ICogICAgICAgICAgVGhlIHRyYW5zcG9ydCBlbWl0cyB0aGUgZXZlbnRzOiBcInN0YXJ0XCIsIFwic3RvcFwiLCBcInBhdXNlXCIsIGFuZCBcImxvb3BcIiB3aGljaCBhcmVcblx0ICogICAgICAgICAgY2FsbGVkIHdpdGggdGhlIHRpbWUgb2YgdGhhdCBldmVudCBhcyB0aGUgYXJndW1lbnQuXG5cdCAqXG5cdCAqICBAZXh0ZW5kcyB7VG9uZS5FbWl0dGVyfVxuXHQgKiAgQHNpbmdsZXRvblxuXHQgKiAgQGV4YW1wbGVcblx0ICogLy9yZXBlYXRlZCBldmVudCBldmVyeSA4dGggbm90ZVxuXHQgKiBUb25lLlRyYW5zcG9ydC5zY2hlZHVsZVJlcGVhdChmdW5jdGlvbih0aW1lKXtcblx0ICogXHQvL2RvIHNvbWV0aGluZyB3aXRoIHRoZSB0aW1lXG5cdCAqIH0sIFwiOG5cIik7XG5cdCAqICBAZXhhbXBsZVxuXHQgKiAvL3NjaGVkdWxlIGFuIGV2ZW50IG9uIHRoZSAxNnRoIG1lYXN1cmVcblx0ICogVG9uZS5UcmFuc3BvcnQuc2NoZWR1bGUoZnVuY3Rpb24odGltZSl7XG5cdCAqIFx0Ly9kbyBzb21ldGhpbmcgd2l0aCB0aGUgdGltZVxuXHQgKiB9LCBcIjE2OjA6MFwiKTtcblx0ICovXG5cdFRvbmUuVHJhbnNwb3J0ID0gZnVuY3Rpb24oKXtcblxuXHRcdFRvbmUuRW1pdHRlci5jYWxsKHRoaXMpO1xuXG5cdFx0VG9uZS5nZXRDb250ZXh0KGZ1bmN0aW9uKCl7XG5cblx0XHRcdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdFx0XHQvL1x0TE9PUElOR1xuXHRcdFx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIFx0SWYgdGhlIHRyYW5zcG9ydCBsb29wcyBvciBub3QuXG5cdFx0XHQgKiAgQHR5cGUge2Jvb2xlYW59XG5cdFx0XHQgKi9cblx0XHRcdHRoaXMubG9vcCA9IGZhbHNlO1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIFx0VGhlIGxvb3Agc3RhcnQgcG9zaXRpb24gaW4gdGlja3Ncblx0XHRcdCAqICBAdHlwZSB7VGlja3N9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy5fbG9vcFN0YXJ0ID0gMDtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBcdFRoZSBsb29wIGVuZCBwb3NpdGlvbiBpbiB0aWNrc1xuXHRcdFx0ICogIEB0eXBlIHtUaWNrc31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLl9sb29wRW5kID0gMDtcblxuXHRcdFx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0XHRcdC8vXHRDTE9DSy9URU1QT1xuXHRcdFx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cdFx0XHQvKipcblx0XHRcdCAqICBQdWxzZXMgcGVyIHF1YXJ0ZXIgaXMgdGhlIG51bWJlciBvZiB0aWNrcyBwZXIgcXVhcnRlciBub3RlLlxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKi9cblx0XHRcdHRoaXMuX3BwcSA9IFRyYW5zcG9ydENvbnN0cnVjdG9yLmRlZmF1bHRzLlBQUTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiAgd2F0Y2hlcyB0aGUgbWFpbiBvc2NpbGxhdG9yIGZvciB0aW1pbmcgdGlja3Ncblx0XHRcdCAqICBpbml0aWFsbHkgc3RhcnRzIGF0IDEyMGJwbVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQ2xvY2t9XG5cdFx0XHQgKi9cblx0XHRcdHRoaXMuX2Nsb2NrID0gbmV3IFRvbmUuQ2xvY2soe1xuXHRcdFx0XHRcImNhbGxiYWNrXCIgOiB0aGlzLl9wcm9jZXNzVGljay5iaW5kKHRoaXMpLFxuXHRcdFx0XHRcImZyZXF1ZW5jeVwiIDogMCxcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLl9iaW5kQ2xvY2tFdmVudHMoKTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiAgVGhlIEJlYXRzIFBlciBNaW51dGUgb2YgdGhlIFRyYW5zcG9ydC5cblx0XHRcdCAqICBAdHlwZSB7QlBNfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogVG9uZS5UcmFuc3BvcnQuYnBtLnZhbHVlID0gODA7XG5cdFx0XHQgKiAvL3JhbXAgdGhlIGJwbSB0byAxMjAgb3ZlciAxMCBzZWNvbmRzXG5cdFx0XHQgKiBUb25lLlRyYW5zcG9ydC5icG0ucmFtcFRvKDEyMCwgMTApO1xuXHRcdFx0ICovXG5cdFx0XHR0aGlzLmJwbSA9IHRoaXMuX2Nsb2NrLmZyZXF1ZW5jeTtcblx0XHRcdHRoaXMuYnBtLl90b1VuaXRzID0gdGhpcy5fdG9Vbml0cy5iaW5kKHRoaXMpO1xuXHRcdFx0dGhpcy5icG0uX2Zyb21Vbml0cyA9IHRoaXMuX2Zyb21Vbml0cy5iaW5kKHRoaXMpO1xuXHRcdFx0dGhpcy5icG0udW5pdHMgPSBUb25lLlR5cGUuQlBNO1xuXHRcdFx0dGhpcy5icG0udmFsdWUgPSBUcmFuc3BvcnRDb25zdHJ1Y3Rvci5kZWZhdWx0cy5icG07XG5cdFx0XHR0aGlzLl9yZWFkT25seShcImJwbVwiKTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiAgVGhlIHRpbWUgc2lnbmF0dXJlLCBvciBtb3JlIGFjY3VyYXRlbHkgdGhlIG51bWVyYXRvclxuXHRcdFx0ICogIG9mIHRoZSB0aW1lIHNpZ25hdHVyZSBvdmVyIGEgZGVub21pbmF0b3Igb2YgNC5cblx0XHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMuX3RpbWVTaWduYXR1cmUgPSBUcmFuc3BvcnRDb25zdHJ1Y3Rvci5kZWZhdWx0cy50aW1lU2lnbmF0dXJlO1xuXG5cdFx0XHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHRcdFx0Ly9cdFRJTUVMSU5FIEVWRU5UU1xuXHRcdFx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cdFx0XHQvKipcblx0XHRcdCAqICBBbGwgdGhlIGV2ZW50cyBpbiBhbiBvYmplY3QgdG8ga2VlcCB0cmFjayBieSBJRFxuXHRcdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy5fc2NoZWR1bGVkRXZlbnRzID0ge307XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogXHRUaGUgc2NoZWR1bGVkIGV2ZW50cy5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5UaW1lbGluZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLl90aW1lbGluZSA9IG5ldyBUb25lLlRpbWVsaW5lKCk7XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogIFJlcGVhdGVkIGV2ZW50c1xuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLl9yZXBlYXRlZEV2ZW50cyA9IG5ldyBUb25lLkludGVydmFsVGltZWxpbmUoKTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiAgQWxsIG9mIHRoZSBzeW5jZWQgU2lnbmFsc1xuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLl9zeW5jZWRTaWduYWxzID0gW107XG5cblx0XHRcdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdFx0XHQvL1x0U1dJTkdcblx0XHRcdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiAgVGhlIHN1YmRpdmlzaW9uIG9mIHRoZSBzd2luZ1xuXHRcdFx0ICogIEB0eXBlICB7VGlja3N9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy5fc3dpbmdUaWNrcyA9IFRyYW5zcG9ydENvbnN0cnVjdG9yLmRlZmF1bHRzLlBQUSAvIDI7IC8vOG5cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiAgVGhlIHN3aW5nIGFtb3VudFxuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLl9zd2luZ0Ftb3VudCA9IDA7XG5cblx0XHR9LmJpbmQodGhpcykpO1xuXHR9O1xuXG5cdFRvbmUuZXh0ZW5kKFRvbmUuVHJhbnNwb3J0LCBUb25lLkVtaXR0ZXIpO1xuXG5cdC8qKlxuXHQgKiAgdGhlIGRlZmF1bHRzXG5cdCAqICBAdHlwZSB7T2JqZWN0fVxuXHQgKiAgQGNvbnN0XG5cdCAqICBAc3RhdGljXG5cdCAqL1xuXHRUb25lLlRyYW5zcG9ydC5kZWZhdWx0cyA9IHtcblx0XHRcImJwbVwiIDogMTIwLFxuXHRcdFwic3dpbmdcIiA6IDAsXG5cdFx0XCJzd2luZ1N1YmRpdmlzaW9uXCIgOiBcIjhuXCIsXG5cdFx0XCJ0aW1lU2lnbmF0dXJlXCIgOiA0LFxuXHRcdFwibG9vcFN0YXJ0XCIgOiAwLFxuXHRcdFwibG9vcEVuZFwiIDogXCI0bVwiLFxuXHRcdFwiUFBRXCIgOiAxOTJcblx0fTtcblxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vXHRUSUNLU1xuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblx0LyoqXG5cdCAqICBjYWxsZWQgb24gZXZlcnkgdGlja1xuXHQgKiAgQHBhcmFtICAge251bWJlcn0gdGlja1RpbWUgY2xvY2sgcmVsYXRpdmUgdGljayB0aW1lXG5cdCAqICBAcHJpdmF0ZVxuXHQgKi9cblx0VG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLl9wcm9jZXNzVGljayA9IGZ1bmN0aW9uKHRpY2tUaW1lLCB0aWNrcyl7XG5cdFx0Ly9oYW5kbGUgc3dpbmdcblx0XHRpZiAodGhpcy5fc3dpbmdBbW91bnQgPiAwICYmXG5cdFx0XHR0aWNrcyAlIHRoaXMuX3BwcSAhPT0gMCAmJiAvL25vdCBvbiBhIGRvd25iZWF0XG5cdFx0XHR0aWNrcyAlICh0aGlzLl9zd2luZ1RpY2tzICogMikgIT09IDApe1xuXHRcdFx0Ly9hZGQgc29tZSBzd2luZ1xuXHRcdFx0dmFyIHByb2dyZXNzID0gKHRpY2tzICUgKHRoaXMuX3N3aW5nVGlja3MgKiAyKSkgLyAodGhpcy5fc3dpbmdUaWNrcyAqIDIpO1xuXHRcdFx0dmFyIGFtb3VudCA9IE1hdGguc2luKChwcm9ncmVzcykgKiBNYXRoLlBJKSAqIHRoaXMuX3N3aW5nQW1vdW50O1xuXHRcdFx0dGlja1RpbWUgKz0gVG9uZS5UaWNrcyh0aGlzLl9zd2luZ1RpY2tzICogMi8zKS50b1NlY29uZHMoKSAqIGFtb3VudDtcblx0XHR9XG5cdFx0Ly9kbyB0aGUgbG9vcCB0ZXN0XG5cdFx0aWYgKHRoaXMubG9vcCl7XG5cdFx0XHRpZiAodGlja3MgPj0gdGhpcy5fbG9vcEVuZCl7XG5cdFx0XHRcdHRoaXMuZW1pdChcImxvb3BFbmRcIiwgdGlja1RpbWUpO1xuXHRcdFx0XHR0aGlzLl9jbG9jay5zZXRUaWNrc0F0VGltZSh0aGlzLl9sb29wU3RhcnQsIHRpY2tUaW1lKTtcblx0XHRcdFx0dGlja3MgPSB0aGlzLl9sb29wU3RhcnQ7XG5cdFx0XHRcdHRoaXMuZW1pdChcImxvb3BTdGFydFwiLCB0aWNrVGltZSwgdGhpcy5fY2xvY2suZ2V0U2Vjb25kc0F0VGltZSh0aWNrVGltZSkpO1xuXHRcdFx0XHR0aGlzLmVtaXQoXCJsb29wXCIsIHRpY2tUaW1lKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly9pbnZva2UgdGhlIHRpbWVsaW5lIGV2ZW50cyBzY2hlZHVsZWQgb24gdGhpcyB0aWNrXG5cdFx0dGhpcy5fdGltZWxpbmUuZm9yRWFjaEF0VGltZSh0aWNrcywgZnVuY3Rpb24oZXZlbnQpe1xuXHRcdFx0ZXZlbnQuaW52b2tlKHRpY2tUaW1lKTtcblx0XHR9KTtcblx0fTtcblxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vXHRTQ0hFRFVMQUJMRSBFVkVOVFNcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cdC8qKlxuXHQgKiAgU2NoZWR1bGUgYW4gZXZlbnQgYWxvbmcgdGhlIHRpbWVsaW5lLlxuXHQgKiAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgYXQgdGhlIHRpbWUuXG5cdCAqICBAcGFyYW0ge1RyYW5zcG9ydFRpbWV9ICB0aW1lIFRoZSB0aW1lIHRvIGludm9rZSB0aGUgY2FsbGJhY2sgYXQuXG5cdCAqICBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBpZCBvZiB0aGUgZXZlbnQgd2hpY2ggY2FuIGJlIHVzZWQgZm9yIGNhbmNlbGluZyB0aGUgZXZlbnQuXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAvL3RyaWdnZXIgdGhlIGNhbGxiYWNrIHdoZW4gdGhlIFRyYW5zcG9ydCByZWFjaGVzIHRoZSBkZXNpcmVkIHRpbWVcblx0ICogVG9uZS5UcmFuc3BvcnQuc2NoZWR1bGUoZnVuY3Rpb24odGltZSl7XG5cdCAqIFx0ZW52ZWxvcGUudHJpZ2dlckF0dGFjayh0aW1lKTtcblx0ICogfSwgXCIxMjhpXCIpO1xuXHQgKi9cblx0VG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRpbWUpe1xuXHRcdHZhciBldmVudCA9IG5ldyBUb25lLlRyYW5zcG9ydEV2ZW50KHRoaXMsIHtcblx0XHRcdFwidGltZVwiIDogVG9uZS5UcmFuc3BvcnRUaW1lKHRpbWUpLFxuXHRcdFx0XCJjYWxsYmFja1wiIDogY2FsbGJhY2tcblx0XHR9KTtcblx0XHRyZXR1cm4gdGhpcy5fYWRkRXZlbnQoZXZlbnQsIHRoaXMuX3RpbWVsaW5lKTtcblx0fTtcblxuXHQvKipcblx0ICogIFNjaGVkdWxlIGEgcmVwZWF0ZWQgZXZlbnQgYWxvbmcgdGhlIHRpbWVsaW5lLiBUaGUgZXZlbnQgd2lsbCBmaXJlXG5cdCAqICBhdCB0aGUgYGludGVydmFsYCBzdGFydGluZyBhdCB0aGUgYHN0YXJ0VGltZWAgYW5kIGZvciB0aGUgc3BlY2lmaWVkXG5cdCAqICBgZHVyYXRpb25gLlxuXHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFjayAgIFRoZSBjYWxsYmFjayB0byBpbnZva2UuXG5cdCAqICBAcGFyYW0gIHtUaW1lfSAgICBpbnRlcnZhbCAgIFRoZSBkdXJhdGlvbiBiZXR3ZWVuIHN1Y2Nlc3NpdmVcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLiBNdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyLlxuXHQgKiAgQHBhcmFtICB7VHJhbnNwb3J0VGltZT19ICAgIHN0YXJ0VGltZSAgV2hlbiBhbG9uZyB0aGUgdGltZWxpbmUgdGhlIGV2ZW50cyBzaG91bGRcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgYmVpbmcgaW52b2tlZC5cblx0ICogIEBwYXJhbSB7VGltZX0gW2R1cmF0aW9uPUluZmluaXR5XSBIb3cgbG9uZyB0aGUgZXZlbnQgc2hvdWxkIHJlcGVhdC5cblx0ICogIEByZXR1cm4gIHtOdW1iZXJ9ICAgIFRoZSBJRCBvZiB0aGUgc2NoZWR1bGVkIGV2ZW50LiBVc2UgdGhpcyB0byBjYW5jZWxcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgZXZlbnQuXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAvL2EgY2FsbGJhY2sgaW52b2tlZCBldmVyeSBlaWdodGggbm90ZSBhZnRlciB0aGUgZmlyc3QgbWVhc3VyZVxuXHQgKiBUb25lLlRyYW5zcG9ydC5zY2hlZHVsZVJlcGVhdChjYWxsYmFjaywgXCI4blwiLCBcIjFtXCIpO1xuXHQgKi9cblx0VG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnNjaGVkdWxlUmVwZWF0ID0gZnVuY3Rpb24oY2FsbGJhY2ssIGludGVydmFsLCBzdGFydFRpbWUsIGR1cmF0aW9uKXtcblx0XHR2YXIgZXZlbnQgPSBuZXcgVG9uZS5UcmFuc3BvcnRSZXBlYXRFdmVudCh0aGlzLCB7XG5cdFx0XHRcImNhbGxiYWNrXCIgOiBjYWxsYmFjayxcblx0XHRcdFwiaW50ZXJ2YWxcIiA6IFRvbmUuVGltZShpbnRlcnZhbCksXG5cdFx0XHRcInRpbWVcIiA6IFRvbmUuVHJhbnNwb3J0VGltZShzdGFydFRpbWUpLFxuXHRcdFx0XCJkdXJhdGlvblwiIDogVG9uZS5UaW1lKFRvbmUuZGVmYXVsdEFyZyhkdXJhdGlvbiwgSW5maW5pdHkpKSxcblx0XHR9KTtcblx0XHQvL2tpY2sgaXQgb2ZmIGlmIHRoZSBUcmFuc3BvcnQgaXMgc3RhcnRlZFxuXHRcdHJldHVybiB0aGlzLl9hZGRFdmVudChldmVudCwgdGhpcy5fcmVwZWF0ZWRFdmVudHMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgU2NoZWR1bGUgYW4gZXZlbnQgdGhhdCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgaXQgaXMgaW52b2tlZC5cblx0ICogIE5vdGUgdGhhdCBpZiB0aGUgZ2l2ZW4gdGltZSBpcyBsZXNzIHRoYW4gdGhlIGN1cnJlbnQgdHJhbnNwb3J0IHRpbWUsXG5cdCAqICB0aGUgZXZlbnQgd2lsbCBiZSBpbnZva2VkIGltbWVkaWF0ZWx5LlxuXHQgKiAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSBvbmNlLlxuXHQgKiAgQHBhcmFtIHtUcmFuc3BvcnRUaW1lfSB0aW1lIFRoZSB0aW1lIHRoZSBjYWxsYmFjayBzaG91bGQgYmUgaW52b2tlZC5cblx0ICogIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBJRCBvZiB0aGUgc2NoZWR1bGVkIGV2ZW50LlxuXHQgKi9cblx0VG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnNjaGVkdWxlT25jZSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aW1lKXtcblx0XHR2YXIgZXZlbnQgPSBuZXcgVG9uZS5UcmFuc3BvcnRFdmVudCh0aGlzLCB7XG5cdFx0XHRcInRpbWVcIiA6IFRvbmUuVHJhbnNwb3J0VGltZSh0aW1lKSxcblx0XHRcdFwiY2FsbGJhY2tcIiA6IGNhbGxiYWNrLFxuXHRcdFx0XCJvbmNlXCIgOiB0cnVlXG5cdFx0fSk7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZEV2ZW50KGV2ZW50LCB0aGlzLl90aW1lbGluZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqICBDbGVhciB0aGUgcGFzc2VkIGluIGV2ZW50IGlkIGZyb20gdGhlIHRpbWVsaW5lXG5cdCAqICBAcGFyYW0ge051bWJlcn0gZXZlbnRJZCBUaGUgaWQgb2YgdGhlIGV2ZW50LlxuXHQgKiAgQHJldHVybnMge1RvbmUuVHJhbnNwb3J0fSB0aGlzXG5cdCAqL1xuXHRUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbihldmVudElkKXtcblx0XHRpZiAodGhpcy5fc2NoZWR1bGVkRXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50SWQpKXtcblx0XHRcdHZhciBpdGVtID0gdGhpcy5fc2NoZWR1bGVkRXZlbnRzW2V2ZW50SWQudG9TdHJpbmcoKV07XG5cdFx0XHRpdGVtLnRpbWVsaW5lLnJlbW92ZShpdGVtLmV2ZW50KTtcblx0XHRcdGl0ZW0uZXZlbnQuZGlzcG9zZSgpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuX3NjaGVkdWxlZEV2ZW50c1tldmVudElkLnRvU3RyaW5nKCldO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQWRkIGFuIGV2ZW50IHRvIHRoZSBjb3JyZWN0IHRpbWVsaW5lLiBLZWVwIHRyYWNrIG9mIHRoZVxuXHQgKiB0aW1lbGluZSBpdCB3YXMgYWRkZWQgdG8uXG5cdCAqIEBwYXJhbSB7VG9uZS5UcmFuc3BvcnRFdmVudH1cdGV2ZW50XG5cdCAqIEBwYXJhbSB7VG9uZS5UaW1lbGluZX0gdGltZWxpbmVcblx0ICogQHJldHVybnMge051bWJlcn0gdGhlIGV2ZW50IGlkIHdoaWNoIHdhcyBqdXN0IGFkZGVkXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuX2FkZEV2ZW50ID0gZnVuY3Rpb24oZXZlbnQsIHRpbWVsaW5lKXtcblx0XHR0aGlzLl9zY2hlZHVsZWRFdmVudHNbZXZlbnQuaWQudG9TdHJpbmcoKV0gPSB7XG5cdFx0XHRcImV2ZW50XCIgOiBldmVudCxcblx0XHRcdFwidGltZWxpbmVcIiA6IHRpbWVsaW5lXG5cdFx0fTtcblx0XHR0aW1lbGluZS5hZGQoZXZlbnQpO1xuXHRcdHJldHVybiBldmVudC5pZDtcblx0fTtcblxuXHQvKipcblx0ICogIFJlbW92ZSBzY2hlZHVsZWQgZXZlbnRzIGZyb20gdGhlIHRpbWVsaW5lIGFmdGVyXG5cdCAqICB0aGUgZ2l2ZW4gdGltZS4gUmVwZWF0ZWQgZXZlbnRzIHdpbGwgYmUgcmVtb3ZlZFxuXHQgKiAgaWYgdGhlaXIgc3RhcnRUaW1lIGlzIGFmdGVyIHRoZSBnaXZlbiB0aW1lXG5cdCAqICBAcGFyYW0ge1RyYW5zcG9ydFRpbWV9IFthZnRlcj0wXSBDbGVhciBhbGwgZXZlbnRzIGFmdGVyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHRpbWUuXG5cdCAqICBAcmV0dXJucyB7VG9uZS5UcmFuc3BvcnR9IHRoaXNcblx0ICovXG5cdFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbihhZnRlcil7XG5cdFx0YWZ0ZXIgPSBUb25lLmRlZmF1bHRBcmcoYWZ0ZXIsIDApO1xuXHRcdGFmdGVyID0gdGhpcy50b1RpY2tzKGFmdGVyKTtcblx0XHR0aGlzLl90aW1lbGluZS5mb3JFYWNoRnJvbShhZnRlciwgZnVuY3Rpb24oZXZlbnQpe1xuXHRcdFx0dGhpcy5jbGVhcihldmVudC5pZCk7XG5cdFx0fS5iaW5kKHRoaXMpKTtcblx0XHR0aGlzLl9yZXBlYXRlZEV2ZW50cy5mb3JFYWNoRnJvbShhZnRlciwgZnVuY3Rpb24oZXZlbnQpe1xuXHRcdFx0dGhpcy5jbGVhcihldmVudC5pZCk7XG5cdFx0fS5iaW5kKHRoaXMpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vXHRTVEFSVC9TVE9QL1BBVVNFXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHQvKipcblx0ICogIEJpbmQgc3RhcnQvc3RvcC9wYXVzZSBldmVudHMgZnJvbSB0aGUgY2xvY2sgYW5kIGVtaXQgdGhlbS5cblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuX2JpbmRDbG9ja0V2ZW50cyA9IGZ1bmN0aW9uKCl7XG5cdFx0dGhpcy5fY2xvY2sub24oXCJzdGFydFwiLCBmdW5jdGlvbih0aW1lLCBvZmZzZXQpe1xuXHRcdFx0b2Zmc2V0ID0gVG9uZS5UaWNrcyhvZmZzZXQpLnRvU2Vjb25kcygpO1xuXHRcdFx0dGhpcy5lbWl0KFwic3RhcnRcIiwgdGltZSwgb2Zmc2V0KTtcblx0XHR9LmJpbmQodGhpcykpO1xuXG5cdFx0dGhpcy5fY2xvY2sub24oXCJzdG9wXCIsIGZ1bmN0aW9uKHRpbWUpe1xuXHRcdFx0dGhpcy5lbWl0KFwic3RvcFwiLCB0aW1lKTtcblx0XHR9LmJpbmQodGhpcykpO1xuXG5cdFx0dGhpcy5fY2xvY2sub24oXCJwYXVzZVwiLCBmdW5jdGlvbih0aW1lKXtcblx0XHRcdHRoaXMuZW1pdChcInBhdXNlXCIsIHRpbWUpO1xuXHRcdH0uYmluZCh0aGlzKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqICBSZXR1cm5zIHRoZSBwbGF5YmFjayBzdGF0ZSBvZiB0aGUgc291cmNlLCBlaXRoZXIgXCJzdGFydGVkXCIsIFwic3RvcHBlZFwiLCBvciBcInBhdXNlZFwiXG5cdCAqICBAdHlwZSB7VG9uZS5TdGF0ZX1cblx0ICogIEByZWFkT25seVxuXHQgKiAgQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHQgKiAgQG5hbWUgc3RhdGVcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUsIFwic3RhdGVcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2xvY2suZ2V0U3RhdGVBdFRpbWUodGhpcy5ub3coKSk7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogIFN0YXJ0IHRoZSB0cmFuc3BvcnQgYW5kIGFsbCBzb3VyY2VzIHN5bmNlZCB0byB0aGUgdHJhbnNwb3J0LlxuXHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSBUaGUgdGltZSB3aGVuIHRoZSB0cmFuc3BvcnQgc2hvdWxkIHN0YXJ0LlxuXHQgKiAgQHBhcmFtICB7VHJhbnNwb3J0VGltZT19IG9mZnNldCBUaGUgdGltZWxpbmUgb2Zmc2V0IHRvIHN0YXJ0IHRoZSB0cmFuc3BvcnQuXG5cdCAqICBAcmV0dXJucyB7VG9uZS5UcmFuc3BvcnR9IHRoaXNcblx0ICogIEBleGFtcGxlXG5cdCAqIC8vc3RhcnQgdGhlIHRyYW5zcG9ydCBpbiBvbmUgc2Vjb25kIHN0YXJ0aW5nIGF0IGJlZ2lubmluZyBvZiB0aGUgNXRoIG1lYXN1cmUuXG5cdCAqIFRvbmUuVHJhbnNwb3J0LnN0YXJ0KFwiKzFcIiwgXCI0OjA6MFwiKTtcblx0ICovXG5cdFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKHRpbWUsIG9mZnNldCl7XG5cdFx0Ly9zdGFydCB0aGUgY2xvY2tcblx0XHRpZiAoVG9uZS5pc0RlZmluZWQob2Zmc2V0KSl7XG5cdFx0XHRvZmZzZXQgPSB0aGlzLnRvVGlja3Mob2Zmc2V0KTtcblx0XHR9XG5cdFx0dGhpcy5fY2xvY2suc3RhcnQodGltZSwgb2Zmc2V0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogIFN0b3AgdGhlIHRyYW5zcG9ydCBhbmQgYWxsIHNvdXJjZXMgc3luY2VkIHRvIHRoZSB0cmFuc3BvcnQuXG5cdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddIFRoZSB0aW1lIHdoZW4gdGhlIHRyYW5zcG9ydCBzaG91bGQgc3RvcC5cblx0ICogIEByZXR1cm5zIHtUb25lLlRyYW5zcG9ydH0gdGhpc1xuXHQgKiAgQGV4YW1wbGVcblx0ICogVG9uZS5UcmFuc3BvcnQuc3RvcCgpO1xuXHQgKi9cblx0VG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbih0aW1lKXtcblx0XHR0aGlzLl9jbG9jay5zdG9wKHRpbWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgUGF1c2UgdGhlIHRyYW5zcG9ydCBhbmQgYWxsIHNvdXJjZXMgc3luY2VkIHRvIHRoZSB0cmFuc3BvcnQuXG5cdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddXG5cdCAqICBAcmV0dXJucyB7VG9uZS5UcmFuc3BvcnR9IHRoaXNcblx0ICovXG5cdFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKHRpbWUpe1xuXHRcdHRoaXMuX2Nsb2NrLnBhdXNlKHRpbWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUb2dnbGUgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHRyYW5zcG9ydC4gSWYgaXQgaXNcblx0ICogc3RhcnRlZCwgaXQgd2lsbCBzdG9wIGl0LCBvdGhlcndpc2UgaXQgd2lsbCBzdGFydCB0aGUgVHJhbnNwb3J0LlxuXHQgKiBAcGFyYW0gIHtUaW1lPX0gdGltZSBUaGUgdGltZSBvZiB0aGUgZXZlbnRcblx0ICogQHJldHVybiB7VG9uZS5UcmFuc3BvcnR9ICAgICAgdGhpc1xuXHQgKi9cblx0VG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKHRpbWUpe1xuXHRcdHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0XHRpZiAodGhpcy5fY2xvY2suZ2V0U3RhdGVBdFRpbWUodGltZSkgIT09IFRvbmUuU3RhdGUuU3RhcnRlZCl7XG5cdFx0XHR0aGlzLnN0YXJ0KHRpbWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnN0b3AodGltZSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly9cdFNFVFRFUlMvR0VUVEVSU1xuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblx0LyoqXG5cdCAqICBUaGUgdGltZSBzaWduYXR1cmUgYXMganVzdCB0aGUgbnVtZXJhdG9yIG92ZXIgNC5cblx0ICogIEZvciBleGFtcGxlIDQvNCB3b3VsZCBiZSBqdXN0IDQgYW5kIDYvOCB3b3VsZCBiZSAzLlxuXHQgKiAgQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHQgKiAgQHR5cGUge051bWJlcnxBcnJheX1cblx0ICogIEBuYW1lIHRpbWVTaWduYXR1cmVcblx0ICogIEBleGFtcGxlXG5cdCAqIC8vY29tbW9uIHRpbWVcblx0ICogVG9uZS5UcmFuc3BvcnQudGltZVNpZ25hdHVyZSA9IDQ7XG5cdCAqIC8vIDcvOFxuXHQgKiBUb25lLlRyYW5zcG9ydC50aW1lU2lnbmF0dXJlID0gWzcsIDhdO1xuXHQgKiAvL3RoaXMgd2lsbCBiZSByZWR1Y2VkIHRvIGEgc2luZ2xlIG51bWJlclxuXHQgKiBUb25lLlRyYW5zcG9ydC50aW1lU2lnbmF0dXJlOyAvL3JldHVybnMgMy41XG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLCBcInRpbWVTaWduYXR1cmVcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdGltZVNpZ25hdHVyZTtcblx0XHR9LFxuXHRcdHNldCA6IGZ1bmN0aW9uKHRpbWVTaWcpe1xuXHRcdFx0aWYgKFRvbmUuaXNBcnJheSh0aW1lU2lnKSl7XG5cdFx0XHRcdHRpbWVTaWcgPSAodGltZVNpZ1swXSAvIHRpbWVTaWdbMV0pICogNDtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3RpbWVTaWduYXR1cmUgPSB0aW1lU2lnO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIFdoZW4gdGhlIFRvbmUuVHJhbnNwb3J0Lmxvb3AgPSB0cnVlLCB0aGlzIGlzIHRoZSBzdGFydGluZyBwb3NpdGlvbiBvZiB0aGUgbG9vcC5cblx0ICogQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHQgKiBAdHlwZSB7VGltZX1cblx0ICogQG5hbWUgbG9vcFN0YXJ0XG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLCBcImxvb3BTdGFydFwiLCB7XG5cdFx0Z2V0IDogZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiBUb25lLlRpY2tzKHRoaXMuX2xvb3BTdGFydCkudG9TZWNvbmRzKCk7XG5cdFx0fSxcblx0XHRzZXQgOiBmdW5jdGlvbihzdGFydFBvc2l0aW9uKXtcblx0XHRcdHRoaXMuX2xvb3BTdGFydCA9IHRoaXMudG9UaWNrcyhzdGFydFBvc2l0aW9uKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBXaGVuIHRoZSBUb25lLlRyYW5zcG9ydC5sb29wID0gdHJ1ZSwgdGhpcyBpcyB0aGUgZW5kaW5nIHBvc2l0aW9uIG9mIHRoZSBsb29wLlxuXHQgKiBAbWVtYmVyT2YgVG9uZS5UcmFuc3BvcnQjXG5cdCAqIEB0eXBlIHtUaW1lfVxuXHQgKiBAbmFtZSBsb29wRW5kXG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLCBcImxvb3BFbmRcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gVG9uZS5UaWNrcyh0aGlzLl9sb29wRW5kKS50b1NlY29uZHMoKTtcblx0XHR9LFxuXHRcdHNldCA6IGZ1bmN0aW9uKGVuZFBvc2l0aW9uKXtcblx0XHRcdHRoaXMuX2xvb3BFbmQgPSB0aGlzLnRvVGlja3MoZW5kUG9zaXRpb24pO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqICBTZXQgdGhlIGxvb3Agc3RhcnQgYW5kIHN0b3AgYXQgdGhlIHNhbWUgdGltZS5cblx0ICogIEBwYXJhbSB7VHJhbnNwb3J0VGltZX0gc3RhcnRQb3NpdGlvblxuXHQgKiAgQHBhcmFtIHtUcmFuc3BvcnRUaW1lfSBlbmRQb3NpdGlvblxuXHQgKiAgQHJldHVybnMge1RvbmUuVHJhbnNwb3J0fSB0aGlzXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAvL2xvb3Agb3ZlciB0aGUgZmlyc3QgbWVhc3VyZVxuXHQgKiBUb25lLlRyYW5zcG9ydC5zZXRMb29wUG9pbnRzKDAsIFwiMW1cIik7XG5cdCAqIFRvbmUuVHJhbnNwb3J0Lmxvb3AgPSB0cnVlO1xuXHQgKi9cblx0VG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnNldExvb3BQb2ludHMgPSBmdW5jdGlvbihzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbil7XG5cdFx0dGhpcy5sb29wU3RhcnQgPSBzdGFydFBvc2l0aW9uO1xuXHRcdHRoaXMubG9vcEVuZCA9IGVuZFBvc2l0aW9uO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgVGhlIHN3aW5nIHZhbHVlLiBCZXR3ZWVuIDAtMSB3aGVyZSAxIGVxdWFsIHRvXG5cdCAqICB0aGUgbm90ZSArIGhhbGYgdGhlIHN1YmRpdmlzaW9uLlxuXHQgKiAgQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHQgKiAgQG5hbWUgc3dpbmdcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUsIFwic3dpbmdcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3dpbmdBbW91bnQ7XG5cdFx0fSxcblx0XHRzZXQgOiBmdW5jdGlvbihhbW91bnQpe1xuXHRcdFx0Ly9zY2FsZSB0aGUgdmFsdWVzIHRvIGEgbm9ybWFsIHJhbmdlXG5cdFx0XHR0aGlzLl9zd2luZ0Ftb3VudCA9IGFtb3VudDtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiAgU2V0IHRoZSBzdWJkaXZpc2lvbiB3aGljaCB0aGUgc3dpbmcgd2lsbCBiZSBhcHBsaWVkIHRvLlxuXHQgKiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgYW4gOHRoIG5vdGUuIFZhbHVlIG11c3QgYmUgbGVzc1xuXHQgKiAgdGhhbiBhIHF1YXJ0ZXIgbm90ZS5cblx0ICpcblx0ICogIEBtZW1iZXJPZiBUb25lLlRyYW5zcG9ydCNcblx0ICogIEB0eXBlIHtUaW1lfVxuXHQgKiAgQG5hbWUgc3dpbmdTdWJkaXZpc2lvblxuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgXCJzd2luZ1N1YmRpdmlzaW9uXCIsIHtcblx0XHRnZXQgOiBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIFRvbmUuVGlja3ModGhpcy5fc3dpbmdUaWNrcykudG9Ob3RhdGlvbigpO1xuXHRcdH0sXG5cdFx0c2V0IDogZnVuY3Rpb24oc3ViZGl2aXNpb24pe1xuXHRcdFx0dGhpcy5fc3dpbmdUaWNrcyA9IHRoaXMudG9UaWNrcyhzdWJkaXZpc2lvbik7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogIFRoZSBUcmFuc3BvcnQncyBwb3NpdGlvbiBpbiBCYXJzOkJlYXRzOlNpeHRlZW50aHMuXG5cdCAqICBTZXR0aW5nIHRoZSB2YWx1ZSB3aWxsIGp1bXAgdG8gdGhhdCBwb3NpdGlvbiByaWdodCBhd2F5LlxuXHQgKiAgQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHQgKiAgQHR5cGUge0JhcnNCZWF0c1NpeHRlZW50aHN9XG5cdCAqICBAbmFtZSBwb3NpdGlvblxuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB7XG5cdFx0Z2V0IDogZnVuY3Rpb24oKXtcblx0XHRcdHZhciBub3cgPSB0aGlzLm5vdygpO1xuXHRcdFx0dmFyIHRpY2tzID0gdGhpcy5fY2xvY2suZ2V0VGlja3NBdFRpbWUobm93KTtcblx0XHRcdHJldHVybiBUb25lLlRpY2tzKHRpY2tzKS50b0JhcnNCZWF0c1NpeHRlZW50aHMoKTtcblx0XHR9LFxuXHRcdHNldCA6IGZ1bmN0aW9uKHByb2dyZXNzKXtcblx0XHRcdHZhciB0aWNrcyA9IHRoaXMudG9UaWNrcyhwcm9ncmVzcyk7XG5cdFx0XHR0aGlzLnRpY2tzID0gdGlja3M7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogIFRoZSBUcmFuc3BvcnQncyBwb3NpdGlvbiBpbiBzZWNvbmRzXG5cdCAqICBTZXR0aW5nIHRoZSB2YWx1ZSB3aWxsIGp1bXAgdG8gdGhhdCBwb3NpdGlvbiByaWdodCBhd2F5LlxuXHQgKiAgQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHQgKiAgQHR5cGUge1NlY29uZHN9XG5cdCAqICBAbmFtZSBzZWNvbmRzXG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLCBcInNlY29uZHNcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2xvY2suc2Vjb25kcztcblx0XHR9LFxuXHRcdHNldCA6IGZ1bmN0aW9uKHMpe1xuXHRcdFx0dmFyIG5vdyA9IHRoaXMubm93KCk7XG5cdFx0XHR2YXIgdGlja3MgPSB0aGlzLmJwbS50aW1lVG9UaWNrcyhzLCBub3cpO1xuXHRcdFx0dGhpcy50aWNrcyA9IHRpY2tzO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqICBUaGUgVHJhbnNwb3J0J3MgbG9vcCBwb3NpdGlvbiBhcyBhIG5vcm1hbGl6ZWQgdmFsdWUuIEFsd2F5c1xuXHQgKiAgcmV0dXJucyAwIGlmIHRoZSB0cmFuc3BvcnQgaWYgbG9vcCBpcyBub3QgdHJ1ZS5cblx0ICogIEBtZW1iZXJPZiBUb25lLlRyYW5zcG9ydCNcblx0ICogIEBuYW1lIHByb2dyZXNzXG5cdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLCBcInByb2dyZXNzXCIsIHtcblx0XHRnZXQgOiBmdW5jdGlvbigpe1xuXHRcdFx0aWYgKHRoaXMubG9vcCl7XG5cdFx0XHRcdHZhciBub3cgPSB0aGlzLm5vdygpO1xuXHRcdFx0XHR2YXIgdGlja3MgPSB0aGlzLl9jbG9jay5nZXRUaWNrc0F0VGltZShub3cpO1xuXHRcdFx0XHRyZXR1cm4gKHRpY2tzIC0gdGhpcy5fbG9vcFN0YXJ0KSAvICh0aGlzLl9sb29wRW5kIC0gdGhpcy5fbG9vcFN0YXJ0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqICBUaGUgdHJhbnNwb3J0cyBjdXJyZW50IHRpY2sgcG9zaXRpb24uXG5cdCAqXG5cdCAqICBAbWVtYmVyT2YgVG9uZS5UcmFuc3BvcnQjXG5cdCAqICBAdHlwZSB7VGlja3N9XG5cdCAqICBAbmFtZSB0aWNrc1xuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgXCJ0aWNrc1wiLCB7XG5cdFx0Z2V0IDogZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiB0aGlzLl9jbG9jay50aWNrcztcblx0XHR9LFxuXHRcdHNldCA6IGZ1bmN0aW9uKHQpe1xuXHRcdFx0aWYgKHRoaXMuX2Nsb2NrLnRpY2tzICE9PSB0KXtcblx0XHRcdFx0dmFyIG5vdyA9IHRoaXMubm93KCk7XG5cdFx0XHRcdC8vc3RvcCBldmVyeXRoaW5nIHN5bmNlZCB0byB0aGUgdHJhbnNwb3J0XG5cdFx0XHRcdGlmICh0aGlzLnN0YXRlID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpe1xuXHRcdFx0XHRcdHRoaXMuZW1pdChcInN0b3BcIiwgbm93KTtcblx0XHRcdFx0XHR0aGlzLl9jbG9jay5zZXRUaWNrc0F0VGltZSh0LCBub3cpO1xuXHRcdFx0XHRcdC8vcmVzdGFydCBpdCB3aXRoIHRoZSBuZXcgdGltZVxuXHRcdFx0XHRcdHRoaXMuZW1pdChcInN0YXJ0XCIsIG5vdywgdGhpcy5zZWNvbmRzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9jbG9jay5zZXRUaWNrc0F0VGltZSh0LCBub3cpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogR2V0IHRoZSBjbG9jaydzIHRpY2tzIGF0IHRoZSBnaXZlbiB0aW1lLlxuXHQgKiBAcGFyYW0gIHtUaW1lfSB0aW1lICBXaGVuIHRvIGdldCB0aGUgdGljayB2YWx1ZVxuXHQgKiBAcmV0dXJuIHtUaWNrc30gICAgICAgVGhlIHRpY2sgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWUuXG5cdCAqL1xuXHRUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuZ2V0VGlja3NBdFRpbWUgPSBmdW5jdGlvbih0aW1lKXtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCh0aGlzLl9jbG9jay5nZXRUaWNrc0F0VGltZSh0aW1lKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqICBSZXR1cm4gdGhlIGVsYXBzZWQgc2Vjb25kcyBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0ICogIEBwYXJhbSAge1RpbWV9ICB0aW1lICBXaGVuIHRvIGdldCB0aGUgZWxhcHNlZCBzZWNvbmRzXG5cdCAqICBAcmV0dXJuICB7U2Vjb25kc30gIFRoZSBudW1iZXIgb2YgZWxhcHNlZCBzZWNvbmRzXG5cdCAqL1xuXHRUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuZ2V0U2Vjb25kc0F0VGltZSA9IGZ1bmN0aW9uKHRpbWUpe1xuXHRcdHJldHVybiB0aGlzLl9jbG9jay5nZXRTZWNvbmRzQXRUaW1lKHRpbWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgUHVsc2VzIFBlciBRdWFydGVyIG5vdGUuIFRoaXMgaXMgdGhlIHNtYWxsZXN0IHJlc29sdXRpb25cblx0ICogIHRoZSBUcmFuc3BvcnQgdGltaW5nIHN1cHBvcnRzLiBUaGlzIHNob3VsZCBiZSBzZXQgb25jZVxuXHQgKiAgb24gaW5pdGlhbGl6YXRpb24gYW5kIG5vdCBzZXQgYWdhaW4uIENoYW5naW5nIHRoaXMgdmFsdWVcblx0ICogIGFmdGVyIG90aGVyIG9iamVjdHMgaGF2ZSBiZWVuIGNyZWF0ZWQgY2FuIGNhdXNlIHByb2JsZW1zLlxuXHQgKlxuXHQgKiAgQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHQgKiAgQHR5cGUge051bWJlcn1cblx0ICogIEBuYW1lIFBQUVxuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgXCJQUFFcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcHBxO1xuXHRcdH0sXG5cdFx0c2V0IDogZnVuY3Rpb24ocHBxKXtcblx0XHRcdHZhciBicG0gPSB0aGlzLmJwbS52YWx1ZTtcblx0XHRcdHRoaXMuX3BwcSA9IHBwcTtcblx0XHRcdHRoaXMuYnBtLnZhbHVlID0gYnBtO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqICBDb252ZXJ0IGZyb20gQlBNIHRvIGZyZXF1ZW5jeSAoZmFjdG9yaW5nIGluIFBQUSlcblx0ICogIEBwYXJhbSAge0JQTX0gIGJwbSBUaGUgQlBNIHZhbHVlIHRvIGNvbnZlcnQgdG8gZnJlcXVlbmN5XG5cdCAqICBAcmV0dXJuICB7RnJlcXVlbmN5fSAgVGhlIEJQTSBhcyBhIGZyZXF1ZW5jeSB3aXRoIFBQUSBmYWN0b3JlZCBpbi5cblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuX2Zyb21Vbml0cyA9IGZ1bmN0aW9uKGJwbSl7XG5cdFx0cmV0dXJuIDEgLyAoNjAgLyBicG0gLyB0aGlzLlBQUSk7XG5cdH07XG5cblx0LyoqXG5cdCAqICBDb252ZXJ0IGZyb20gZnJlcXVlbmN5ICh3aXRoIFBQUSkgaW50byBCUE1cblx0ICogIEBwYXJhbSAge0ZyZXF1ZW5jeX0gIGZyZXEgVGhlIGNsb2NrcyBmcmVxdWVuY3kgdG8gY29udmVydCB0byBCUE1cblx0ICogIEByZXR1cm4gIHtCUE19ICBUaGUgZnJlcXVlbmN5IHZhbHVlIGFzIEJQTS5cblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuX3RvVW5pdHMgPSBmdW5jdGlvbihmcmVxKXtcblx0XHRyZXR1cm4gKGZyZXEgLyB0aGlzLlBQUSkgKiA2MDtcblx0fTtcblxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vXHRTWU5DSU5HXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHQvKipcblx0ICogIFJldHVybnMgdGhlIHRpbWUgYWxpZ25lZCB0byB0aGUgbmV4dCBzdWJkaXZpc2lvblxuXHQgKiAgb2YgdGhlIFRyYW5zcG9ydC4gSWYgdGhlIFRyYW5zcG9ydCBpcyBub3Qgc3RhcnRlZCxcblx0ICogIGl0IHdpbGwgcmV0dXJuIDAuXG5cdCAqICBOb3RlOiB0aGlzIHdpbGwgbm90IHdvcmsgcHJlY2lzZWx5IGR1cmluZyB0ZW1wbyByYW1wcy5cblx0ICogIEBwYXJhbSAge1RpbWV9ICBzdWJkaXZpc2lvbiAgVGhlIHN1YmRpdmlzaW9uIHRvIHF1YW50aXplIHRvXG5cdCAqICBAcmV0dXJuICB7TnVtYmVyfSAgVGhlIGNvbnRleHQgdGltZSBvZiB0aGUgbmV4dCBzdWJkaXZpc2lvbi5cblx0ICogIEBleGFtcGxlXG5cdCAqIFRvbmUuVHJhbnNwb3J0LnN0YXJ0KCk7IC8vdGhlIHRyYW5zcG9ydCBtdXN0IGJlIHN0YXJ0ZWRcblx0ICogVG9uZS5UcmFuc3BvcnQubmV4dFN1YmRpdmlzaW9uKFwiNG5cIik7XG5cdCAqL1xuXHRUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUubmV4dFN1YmRpdmlzaW9uID0gZnVuY3Rpb24oc3ViZGl2aXNpb24pe1xuXHRcdHN1YmRpdmlzaW9uID0gdGhpcy50b1RpY2tzKHN1YmRpdmlzaW9uKTtcblx0XHRpZiAodGhpcy5zdGF0ZSAhPT0gVG9uZS5TdGF0ZS5TdGFydGVkKXtcblx0XHRcdC8vaWYgdGhlIHRyYW5zcG9ydCdzIG5vdCBzdGFydGVkLCByZXR1cm4gMFxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBub3cgPSB0aGlzLm5vdygpO1xuXHRcdFx0Ly90aGUgcmVtYWluZGVyIG9mIHRoZSBjdXJyZW50IHRpY2tzIGFuZCB0aGUgc3ViZGl2aXNpb25cblx0XHRcdHZhciB0cmFuc3BvcnRQb3MgPSB0aGlzLmdldFRpY2tzQXRUaW1lKG5vdyk7XG5cdFx0XHR2YXIgcmVtYWluaW5nVGlja3MgPSBzdWJkaXZpc2lvbiAtIHRyYW5zcG9ydFBvcyAlIHN1YmRpdmlzaW9uO1xuXHRcdFx0cmV0dXJuIHRoaXMuX2Nsb2NrLm5leHRUaWNrVGltZShyZW1haW5pbmdUaWNrcywgbm93KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqICBBdHRhY2hlcyB0aGUgc2lnbmFsIHRvIHRoZSB0ZW1wbyBjb250cm9sIHNpZ25hbCBzbyB0aGF0XG5cdCAqICBhbnkgY2hhbmdlcyBpbiB0aGUgdGVtcG8gd2lsbCBjaGFuZ2UgdGhlIHNpZ25hbCBpbiB0aGUgc2FtZVxuXHQgKiAgcmF0aW8uXG5cdCAqXG5cdCAqICBAcGFyYW0gIHtUb25lLlNpZ25hbH0gc2lnbmFsXG5cdCAqICBAcGFyYW0ge251bWJlcj19IHJhdGlvIE9wdGlvbmFsbHkgcGFzcyBpbiB0aGUgcmF0aW8gYmV0d2VlblxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgdHdvIHNpZ25hbHMuIE90aGVyd2lzZSBpdCB3aWxsIGJlIGNvbXB1dGVkXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VkIG9uIHRoZWlyIGN1cnJlbnQgdmFsdWVzLlxuXHQgKiAgQHJldHVybnMge1RvbmUuVHJhbnNwb3J0fSB0aGlzXG5cdCAqL1xuXHRUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuc3luY1NpZ25hbCA9IGZ1bmN0aW9uKHNpZ25hbCwgcmF0aW8pe1xuXHRcdGlmICghcmF0aW8pe1xuXHRcdFx0Ly9nZXQgdGhlIHN5bmMgcmF0aW9cblx0XHRcdHZhciBub3cgPSB0aGlzLm5vdygpO1xuXHRcdFx0aWYgKHNpZ25hbC5nZXRWYWx1ZUF0VGltZShub3cpICE9PSAwKXtcblx0XHRcdFx0cmF0aW8gPSBzaWduYWwuZ2V0VmFsdWVBdFRpbWUobm93KSAvIHRoaXMuYnBtLmdldFZhbHVlQXRUaW1lKG5vdyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyYXRpbyA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciByYXRpb1NpZ25hbCA9IG5ldyBUb25lLkdhaW4ocmF0aW8pO1xuXHRcdHRoaXMuYnBtLmNoYWluKHJhdGlvU2lnbmFsLCBzaWduYWwuX3BhcmFtKTtcblx0XHR0aGlzLl9zeW5jZWRTaWduYWxzLnB1c2goe1xuXHRcdFx0XCJyYXRpb1wiIDogcmF0aW9TaWduYWwsXG5cdFx0XHRcInNpZ25hbFwiIDogc2lnbmFsLFxuXHRcdFx0XCJpbml0aWFsXCIgOiBzaWduYWwudmFsdWVcblx0XHR9KTtcblx0XHRzaWduYWwudmFsdWUgPSAwO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgVW5zeW5jcyBhIHByZXZpb3VzbHkgc3luY2VkIHNpZ25hbCBmcm9tIHRoZSB0cmFuc3BvcnQncyBjb250cm9sLlxuXHQgKiAgU2VlIFRvbmUuVHJhbnNwb3J0LnN5bmNTaWduYWwuXG5cdCAqICBAcGFyYW0gIHtUb25lLlNpZ25hbH0gc2lnbmFsXG5cdCAqICBAcmV0dXJucyB7VG9uZS5UcmFuc3BvcnR9IHRoaXNcblx0ICovXG5cdFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS51bnN5bmNTaWduYWwgPSBmdW5jdGlvbihzaWduYWwpe1xuXHRcdGZvciAodmFyIGkgPSB0aGlzLl9zeW5jZWRTaWduYWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcblx0XHRcdHZhciBzeW5jZWRTaWduYWwgPSB0aGlzLl9zeW5jZWRTaWduYWxzW2ldO1xuXHRcdFx0aWYgKHN5bmNlZFNpZ25hbC5zaWduYWwgPT09IHNpZ25hbCl7XG5cdFx0XHRcdHN5bmNlZFNpZ25hbC5yYXRpby5kaXNwb3NlKCk7XG5cdFx0XHRcdHN5bmNlZFNpZ25hbC5zaWduYWwudmFsdWUgPSBzeW5jZWRTaWduYWwuaW5pdGlhbDtcblx0XHRcdFx0dGhpcy5fc3luY2VkU2lnbmFscy5zcGxpY2UoaSwgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgQ2xlYW4gdXAuXG5cdCAqICBAcmV0dXJucyB7VG9uZS5UcmFuc3BvcnR9IHRoaXNcblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCl7XG5cdFx0VG9uZS5FbWl0dGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5fY2xvY2suZGlzcG9zZSgpO1xuXHRcdHRoaXMuX2Nsb2NrID0gbnVsbDtcblx0XHR0aGlzLl93cml0YWJsZShcImJwbVwiKTtcblx0XHR0aGlzLmJwbSA9IG51bGw7XG5cdFx0dGhpcy5fdGltZWxpbmUuZGlzcG9zZSgpO1xuXHRcdHRoaXMuX3RpbWVsaW5lID0gbnVsbDtcblx0XHR0aGlzLl9yZXBlYXRlZEV2ZW50cy5kaXNwb3NlKCk7XG5cdFx0dGhpcy5fcmVwZWF0ZWRFdmVudHMgPSBudWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly9cdElOSVRJQUxJWkFUSU9OXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHR2YXIgVHJhbnNwb3J0Q29uc3RydWN0b3IgPSBUb25lLlRyYW5zcG9ydDtcblx0VG9uZS5UcmFuc3BvcnQgPSBuZXcgVHJhbnNwb3J0Q29uc3RydWN0b3IoKTtcblxuXHRUb25lLkNvbnRleHQub24oXCJpbml0XCIsIGZ1bmN0aW9uKGNvbnRleHQpe1xuXHRcdGlmIChjb250ZXh0LlRyYW5zcG9ydCBpbnN0YW5jZW9mIFRyYW5zcG9ydENvbnN0cnVjdG9yKXtcblx0XHRcdFRvbmUuVHJhbnNwb3J0ID0gY29udGV4dC5UcmFuc3BvcnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFRvbmUuVHJhbnNwb3J0ID0gbmV3IFRyYW5zcG9ydENvbnN0cnVjdG9yKCk7XG5cdFx0fVxuXHRcdC8vc3RvcmUgdGhlIFRyYW5zcG9ydCBvbiB0aGUgY29udGV4dCBzbyBpdCBjYW4gYmUgcmV0cmlldmVkIGxhdGVyXG5cdFx0Y29udGV4dC5UcmFuc3BvcnQgPSBUb25lLlRyYW5zcG9ydDtcblx0fSk7XG5cblx0VG9uZS5Db250ZXh0Lm9uKFwiY2xvc2VcIiwgZnVuY3Rpb24oY29udGV4dCl7XG5cdFx0aWYgKGNvbnRleHQuVHJhbnNwb3J0IGluc3RhbmNlb2YgVHJhbnNwb3J0Q29uc3RydWN0b3Ipe1xuXHRcdFx0Y29udGV4dC5UcmFuc3BvcnQuZGlzcG9zZSgpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIFRvbmUuVHJhbnNwb3J0O1xufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBSUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUVBOzs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBREE7QUFNQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBTkE7QUFBQTtBQUpBO0FBWUE7Ozs7Ozs7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFKQTtBQVNBOzs7Ozs7O0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBSkE7QUFTQTs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUFBO0FBSkE7QUFVQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUpBO0FBU0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFMQTtBQUFBO0FBS0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFBQTtBQU5BO0FBWUE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFBQTtBQUpBO0FBV0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQUE7QUFEQTtBQVlBOzs7Ozs7OztBQU9BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQUFBO0FBSkE7QUFvQkE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQUE7QUFKQTtBQVdBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/core/Transport.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/core/TransportEvent.js":
/*!*******************************************************!*\
  !*** ./node_modules/tone/Tone/core/TransportEvent.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/type/Ticks */ \"./node_modules/tone/Tone/type/Ticks.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  /**\n   *  @class Tone.TransportEvent is an internal class used by (Tone.Transport)[Transport]\n   *         to schedule events. Do no invoke this class directly, it is\n   *         handled from within Tone.Transport.\n   *  @extends {Tone}\n   *  @param {Object} options\n   */\n  Tone.TransportEvent = function (Transport, options) {\n    options = Tone.defaultArg(options, Tone.TransportEvent.defaults);\n    Tone.call(this);\n    /**\n     * Reference to the Transport that created it\n     * @type {Tone.Transport}\n     */\n\n    this.Transport = Transport;\n    /**\n     * The unique id of the event\n     * @type {Number}\n     */\n\n    this.id = Tone.TransportEvent._eventId++;\n    /**\n     * The time the event starts\n     * @type {Ticks}\n     */\n\n    this.time = Tone.Ticks(options.time);\n    /**\n     * The callback to invoke\n     * @type {Function}\n     */\n\n    this.callback = options.callback;\n    /**\n     * If the event should be removed after being created.\n     * @type {Boolean}\n     * @private\n     */\n\n    this._once = options.once;\n  };\n\n  Tone.extend(Tone.TransportEvent);\n  /**\n   * The defaults\n   * @static\n   * @type {Object}\n   */\n\n  Tone.TransportEvent.defaults = {\n    \"once\": false,\n    \"callback\": Tone.noOp\n  };\n  /**\n   * Current ID counter\n   * @private\n   * @static\n   * @type {Number}\n   */\n\n  Tone.TransportEvent._eventId = 0;\n  /**\n   * Invoke the event callback.\n   * @param  {Time} time  The AudioContext time in seconds of the event\n   */\n\n  Tone.TransportEvent.prototype.invoke = function (time) {\n    if (this.callback) {\n      this.callback(time);\n\n      if (this._once && this.Transport) {\n        this.Transport.clear(this.id);\n      }\n    }\n  };\n  /**\n   * Clean up\n   * @return {Tone.TransportEvent} this\n   */\n\n\n  Tone.TransportEvent.prototype.dispose = function () {\n    Tone.prototype.dispose.call(this);\n    this.Transport = null;\n    this.callback = null;\n    this.time = null;\n    return this;\n  };\n\n  return Tone.TransportEvent;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvVHJhbnNwb3J0RXZlbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvVHJhbnNwb3J0RXZlbnQuanM/MjkxNyJdLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoW1wiVG9uZS9jb3JlL1RvbmVcIiwgXCJUb25lL3R5cGUvVGlja3NcIl0sIGZ1bmN0aW9uKFRvbmUpe1xuXG5cdC8qKlxuXHQgKiAgQGNsYXNzIFRvbmUuVHJhbnNwb3J0RXZlbnQgaXMgYW4gaW50ZXJuYWwgY2xhc3MgdXNlZCBieSAoVG9uZS5UcmFuc3BvcnQpW1RyYW5zcG9ydF1cblx0ICogICAgICAgICB0byBzY2hlZHVsZSBldmVudHMuIERvIG5vIGludm9rZSB0aGlzIGNsYXNzIGRpcmVjdGx5LCBpdCBpc1xuXHQgKiAgICAgICAgIGhhbmRsZWQgZnJvbSB3aXRoaW4gVG9uZS5UcmFuc3BvcnQuXG5cdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0ICogIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqL1xuXHRUb25lLlRyYW5zcG9ydEV2ZW50ID0gZnVuY3Rpb24oVHJhbnNwb3J0LCBvcHRpb25zKXtcblxuXHRcdG9wdGlvbnMgPSBUb25lLmRlZmF1bHRBcmcob3B0aW9ucywgVG9uZS5UcmFuc3BvcnRFdmVudC5kZWZhdWx0cyk7XG5cdFx0VG9uZS5jYWxsKHRoaXMpO1xuXG5cdFx0LyoqXG5cdFx0ICogUmVmZXJlbmNlIHRvIHRoZSBUcmFuc3BvcnQgdGhhdCBjcmVhdGVkIGl0XG5cdFx0ICogQHR5cGUge1RvbmUuVHJhbnNwb3J0fVxuXHRcdCAqL1xuXHRcdHRoaXMuVHJhbnNwb3J0ID0gVHJhbnNwb3J0O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHVuaXF1ZSBpZCBvZiB0aGUgZXZlbnRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMuaWQgPSBUb25lLlRyYW5zcG9ydEV2ZW50Ll9ldmVudElkKys7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdGltZSB0aGUgZXZlbnQgc3RhcnRzXG5cdFx0ICogQHR5cGUge1RpY2tzfVxuXHRcdCAqL1xuXHRcdHRoaXMudGltZSA9IFRvbmUuVGlja3Mob3B0aW9ucy50aW1lKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjYWxsYmFjayB0byBpbnZva2Vcblx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0ICovXG5cdFx0dGhpcy5jYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG5cblx0XHQvKipcblx0XHQgKiBJZiB0aGUgZXZlbnQgc2hvdWxkIGJlIHJlbW92ZWQgYWZ0ZXIgYmVpbmcgY3JlYXRlZC5cblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX29uY2UgPSBvcHRpb25zLm9uY2U7XG5cdH07XG5cblx0VG9uZS5leHRlbmQoVG9uZS5UcmFuc3BvcnRFdmVudCk7XG5cblx0LyoqXG5cdCAqIFRoZSBkZWZhdWx0c1xuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqL1xuXHRUb25lLlRyYW5zcG9ydEV2ZW50LmRlZmF1bHRzID0ge1xuXHRcdFwib25jZVwiIDogZmFsc2UsXG5cdFx0XCJjYWxsYmFja1wiIDogVG9uZS5ub09wLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDdXJyZW50IElEIGNvdW50ZXJcblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKi9cblx0VG9uZS5UcmFuc3BvcnRFdmVudC5fZXZlbnRJZCA9IDA7XG5cblx0LyoqXG5cdCAqIEludm9rZSB0aGUgZXZlbnQgY2FsbGJhY2suXG5cdCAqIEBwYXJhbSAge1RpbWV9IHRpbWUgIFRoZSBBdWRpb0NvbnRleHQgdGltZSBpbiBzZWNvbmRzIG9mIHRoZSBldmVudFxuXHQgKi9cblx0VG9uZS5UcmFuc3BvcnRFdmVudC5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24odGltZSl7XG5cdFx0aWYgKHRoaXMuY2FsbGJhY2spe1xuXHRcdFx0dGhpcy5jYWxsYmFjayh0aW1lKTtcblx0XHRcdGlmICh0aGlzLl9vbmNlICYmIHRoaXMuVHJhbnNwb3J0KXtcblx0XHRcdFx0dGhpcy5UcmFuc3BvcnQuY2xlYXIodGhpcy5pZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiB1cFxuXHQgKiBAcmV0dXJuIHtUb25lLlRyYW5zcG9ydEV2ZW50fSB0aGlzXG5cdCAqL1xuXHRUb25lLlRyYW5zcG9ydEV2ZW50LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKXtcblx0XHRUb25lLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5UcmFuc3BvcnQgPSBudWxsO1xuXHRcdHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuXHRcdHRoaXMudGltZSA9IG51bGw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0cmV0dXJuIFRvbmUuVHJhbnNwb3J0RXZlbnQ7XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7Ozs7OztBQU9BO0FBRUE7QUFDQTtBQUVBOzs7OztBQUlBO0FBRUE7Ozs7O0FBSUE7QUFFQTs7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7Ozs7Ozs7QUFNQTtBQUVBOzs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/core/TransportEvent.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/core/TransportRepeatEvent.js":
/*!*************************************************************!*\
  !*** ./node_modules/tone/Tone/core/TransportRepeatEvent.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/core/TransportEvent */ \"./node_modules/tone/Tone/core/TransportEvent.js\"), __webpack_require__(/*! Tone/type/Ticks */ \"./node_modules/tone/Tone/type/Ticks.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  /**\n   *  @class Tone.TransportRepeatEvent is an internal class used by Tone.Transport\n   *         to schedule repeat events. This class should not be instantiated directly.\n   *  @extends {Tone.TransportEvent}\n   *  @param {Object} options\n   */\n  Tone.TransportRepeatEvent = function (Transport, options) {\n    Tone.TransportEvent.call(this, Transport, options);\n    options = Tone.defaultArg(options, Tone.TransportRepeatEvent.defaults);\n    /**\n     * When the event should stop repeating\n     * @type {Ticks}\n     * @private\n     */\n\n    this.duration = Tone.Ticks(options.duration);\n    /**\n     * The interval of the repeated event\n     * @type {Ticks}\n     * @private\n     */\n\n    this._interval = Tone.Ticks(options.interval);\n    /**\n     * The ID of the current timeline event\n     * @type {Number}\n     * @private\n     */\n\n    this._currentId = -1;\n    /**\n     * The ID of the next timeline event\n     * @type {Number}\n     * @private\n     */\n\n    this._nextId = -1;\n    /**\n      * The time of the next event\n      * @type {Ticks}\n      * @private\n      */\n\n    this._nextTick = this.time;\n    /**\n     * a reference to the bound start method\n     * @type {Function}\n     * @private\n     */\n\n    this._boundRestart = this._restart.bind(this);\n    this.Transport.on(\"start loopStart\", this._boundRestart);\n\n    this._restart();\n  };\n\n  Tone.extend(Tone.TransportRepeatEvent, Tone.TransportEvent);\n  /**\n   * The defaults\n   * @static\n   * @type {Object}\n   */\n\n  Tone.TransportRepeatEvent.defaults = {\n    \"duration\": Infinity,\n    \"interval\": 1\n  };\n  /**\n   * Invoke the callback. Returns the tick time which\n   * the next event should be scheduled at.\n   * @param  {Number} time  The AudioContext time in seconds of the event\n   */\n\n  Tone.TransportRepeatEvent.prototype.invoke = function (time) {\n    //create more events if necessary\n    this._createEvents(time); //call the super class\n\n\n    Tone.TransportEvent.prototype.invoke.call(this, time);\n  };\n  /**\n   * Push more events onto the timeline to keep up with the position of the timeline\n   * @private\n   */\n\n\n  Tone.TransportRepeatEvent.prototype._createEvents = function (time) {\n    // schedule the next event\n    var ticks = this.Transport.getTicksAtTime(time);\n\n    if (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {\n      this._nextTick += this._interval;\n      this._currentId = this._nextId;\n      this._nextId = this.Transport.scheduleOnce(this.invoke.bind(this), Tone.Ticks(this._nextTick));\n    }\n  };\n  /**\n   * Push more events onto the timeline to keep up with the position of the timeline\n   * @private\n   */\n\n\n  Tone.TransportRepeatEvent.prototype._restart = function (time) {\n    this.Transport.clear(this._currentId);\n    this.Transport.clear(this._nextId);\n    this._nextTick = this.time;\n    var ticks = this.Transport.getTicksAtTime(time);\n\n    if (ticks > this.time) {\n      this._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;\n    }\n\n    this._currentId = this.Transport.scheduleOnce(this.invoke.bind(this), Tone.Ticks(this._nextTick));\n    this._nextTick += this._interval;\n    this._nextId = this.Transport.scheduleOnce(this.invoke.bind(this), Tone.Ticks(this._nextTick));\n  };\n  /**\n   * Clean up\n   * @return {Tone.TransportRepeatEvent} this\n   */\n\n\n  Tone.TransportRepeatEvent.prototype.dispose = function () {\n    this.Transport.clear(this._currentId);\n    this.Transport.clear(this._nextId);\n    this.Transport.off(\"start loopStart\", this._boundRestart);\n    this._boundCreateEvents = null;\n    Tone.TransportEvent.prototype.dispose.call(this);\n    this.duration = null;\n    this._interval = null;\n    return this;\n  };\n\n  return Tone.TransportRepeatEvent;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvVHJhbnNwb3J0UmVwZWF0RXZlbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2NvcmUvVHJhbnNwb3J0UmVwZWF0RXZlbnQuanM/MWM0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoW1wiVG9uZS9jb3JlL1RvbmVcIiwgXCJUb25lL2NvcmUvVHJhbnNwb3J0RXZlbnRcIiwgXCJUb25lL3R5cGUvVGlja3NcIl0sIGZ1bmN0aW9uKFRvbmUpe1xuXG5cdC8qKlxuXHQgKiAgQGNsYXNzIFRvbmUuVHJhbnNwb3J0UmVwZWF0RXZlbnQgaXMgYW4gaW50ZXJuYWwgY2xhc3MgdXNlZCBieSBUb25lLlRyYW5zcG9ydFxuXHQgKiAgICAgICAgIHRvIHNjaGVkdWxlIHJlcGVhdCBldmVudHMuIFRoaXMgY2xhc3Mgc2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuXG5cdCAqICBAZXh0ZW5kcyB7VG9uZS5UcmFuc3BvcnRFdmVudH1cblx0ICogIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqL1xuXHRUb25lLlRyYW5zcG9ydFJlcGVhdEV2ZW50ID0gZnVuY3Rpb24oVHJhbnNwb3J0LCBvcHRpb25zKXtcblxuXHRcdFRvbmUuVHJhbnNwb3J0RXZlbnQuY2FsbCh0aGlzLCBUcmFuc3BvcnQsIG9wdGlvbnMpO1xuXHRcdG9wdGlvbnMgPSBUb25lLmRlZmF1bHRBcmcob3B0aW9ucywgVG9uZS5UcmFuc3BvcnRSZXBlYXRFdmVudC5kZWZhdWx0cyk7XG5cblx0XHQvKipcblx0XHQgKiBXaGVuIHRoZSBldmVudCBzaG91bGQgc3RvcCByZXBlYXRpbmdcblx0XHQgKiBAdHlwZSB7VGlja3N9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLmR1cmF0aW9uID0gVG9uZS5UaWNrcyhvcHRpb25zLmR1cmF0aW9uKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBpbnRlcnZhbCBvZiB0aGUgcmVwZWF0ZWQgZXZlbnRcblx0XHQgKiBAdHlwZSB7VGlja3N9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9pbnRlcnZhbCA9IFRvbmUuVGlja3Mob3B0aW9ucy5pbnRlcnZhbCk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgSUQgb2YgdGhlIGN1cnJlbnQgdGltZWxpbmUgZXZlbnRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fY3VycmVudElkID0gLTE7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgSUQgb2YgdGhlIG5leHQgdGltZWxpbmUgZXZlbnRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbmV4dElkID0gLTE7XG5cblx0XHQvKipcblx0XHQgICogVGhlIHRpbWUgb2YgdGhlIG5leHQgZXZlbnRcblx0XHQgICogQHR5cGUge1RpY2tzfVxuXHRcdCAgKiBAcHJpdmF0ZVxuXHRcdCAgKi9cblx0XHR0aGlzLl9uZXh0VGljayA9IHRoaXMudGltZTtcblxuXHRcdC8qKlxuXHRcdCAqIGEgcmVmZXJlbmNlIHRvIHRoZSBib3VuZCBzdGFydCBtZXRob2Rcblx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9ib3VuZFJlc3RhcnQgPSB0aGlzLl9yZXN0YXJ0LmJpbmQodGhpcyk7XG5cdFx0dGhpcy5UcmFuc3BvcnQub24oXCJzdGFydCBsb29wU3RhcnRcIiwgdGhpcy5fYm91bmRSZXN0YXJ0KTtcblx0XHR0aGlzLl9yZXN0YXJ0KCk7XG5cdH07XG5cblx0VG9uZS5leHRlbmQoVG9uZS5UcmFuc3BvcnRSZXBlYXRFdmVudCwgVG9uZS5UcmFuc3BvcnRFdmVudCk7XG5cblx0LyoqXG5cdCAqIFRoZSBkZWZhdWx0c1xuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqL1xuXHRUb25lLlRyYW5zcG9ydFJlcGVhdEV2ZW50LmRlZmF1bHRzID0ge1xuXHRcdFwiZHVyYXRpb25cIiA6IEluZmluaXR5LFxuXHRcdFwiaW50ZXJ2YWxcIiA6IDFcblx0fTtcblxuXHQvKipcblx0ICogSW52b2tlIHRoZSBjYWxsYmFjay4gUmV0dXJucyB0aGUgdGljayB0aW1lIHdoaWNoXG5cdCAqIHRoZSBuZXh0IGV2ZW50IHNob3VsZCBiZSBzY2hlZHVsZWQgYXQuXG5cdCAqIEBwYXJhbSAge051bWJlcn0gdGltZSAgVGhlIEF1ZGlvQ29udGV4dCB0aW1lIGluIHNlY29uZHMgb2YgdGhlIGV2ZW50XG5cdCAqL1xuXHRUb25lLlRyYW5zcG9ydFJlcGVhdEV2ZW50LnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbih0aW1lKXtcblx0XHQvL2NyZWF0ZSBtb3JlIGV2ZW50cyBpZiBuZWNlc3Nhcnlcblx0XHR0aGlzLl9jcmVhdGVFdmVudHModGltZSk7XG5cdFx0Ly9jYWxsIHRoZSBzdXBlciBjbGFzc1xuXHRcdFRvbmUuVHJhbnNwb3J0RXZlbnQucHJvdG90eXBlLmludm9rZS5jYWxsKHRoaXMsIHRpbWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQdXNoIG1vcmUgZXZlbnRzIG9udG8gdGhlIHRpbWVsaW5lIHRvIGtlZXAgdXAgd2l0aCB0aGUgcG9zaXRpb24gb2YgdGhlIHRpbWVsaW5lXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLlRyYW5zcG9ydFJlcGVhdEV2ZW50LnByb3RvdHlwZS5fY3JlYXRlRXZlbnRzID0gZnVuY3Rpb24odGltZSl7XG5cdFx0Ly8gc2NoZWR1bGUgdGhlIG5leHQgZXZlbnRcblx0XHR2YXIgdGlja3MgPSB0aGlzLlRyYW5zcG9ydC5nZXRUaWNrc0F0VGltZSh0aW1lKTtcblx0XHRpZiAodGlja3MgPj0gdGhpcy50aW1lICYmIHRpY2tzID49IHRoaXMuX25leHRUaWNrICYmXG5cdFx0dGhpcy5fbmV4dFRpY2sgKyB0aGlzLl9pbnRlcnZhbCA8IHRoaXMudGltZSArIHRoaXMuZHVyYXRpb24pe1xuXHRcdFx0dGhpcy5fbmV4dFRpY2sgKz0gdGhpcy5faW50ZXJ2YWw7XG5cdFx0XHR0aGlzLl9jdXJyZW50SWQgPSB0aGlzLl9uZXh0SWQ7XG5cdFx0XHR0aGlzLl9uZXh0SWQgPSB0aGlzLlRyYW5zcG9ydC5zY2hlZHVsZU9uY2UodGhpcy5pbnZva2UuYmluZCh0aGlzKSwgVG9uZS5UaWNrcyh0aGlzLl9uZXh0VGljaykpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUHVzaCBtb3JlIGV2ZW50cyBvbnRvIHRoZSB0aW1lbGluZSB0byBrZWVwIHVwIHdpdGggdGhlIHBvc2l0aW9uIG9mIHRoZSB0aW1lbGluZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0VG9uZS5UcmFuc3BvcnRSZXBlYXRFdmVudC5wcm90b3R5cGUuX3Jlc3RhcnQgPSBmdW5jdGlvbih0aW1lKXtcblx0XHR0aGlzLlRyYW5zcG9ydC5jbGVhcih0aGlzLl9jdXJyZW50SWQpO1xuXHRcdHRoaXMuVHJhbnNwb3J0LmNsZWFyKHRoaXMuX25leHRJZCk7XG5cdFx0dGhpcy5fbmV4dFRpY2sgPSB0aGlzLnRpbWU7XG5cdFx0dmFyIHRpY2tzID0gdGhpcy5UcmFuc3BvcnQuZ2V0VGlja3NBdFRpbWUodGltZSk7XG5cdFx0aWYgKHRpY2tzID4gdGhpcy50aW1lKXtcblx0XHRcdHRoaXMuX25leHRUaWNrID0gdGhpcy50aW1lICsgTWF0aC5jZWlsKCh0aWNrcyAtIHRoaXMudGltZSkgLyB0aGlzLl9pbnRlcnZhbCkgKiB0aGlzLl9pbnRlcnZhbDtcblx0XHR9XG5cdFx0dGhpcy5fY3VycmVudElkID0gdGhpcy5UcmFuc3BvcnQuc2NoZWR1bGVPbmNlKHRoaXMuaW52b2tlLmJpbmQodGhpcyksIFRvbmUuVGlja3ModGhpcy5fbmV4dFRpY2spKTtcblx0XHR0aGlzLl9uZXh0VGljayArPSB0aGlzLl9pbnRlcnZhbDtcblx0XHR0aGlzLl9uZXh0SWQgPSB0aGlzLlRyYW5zcG9ydC5zY2hlZHVsZU9uY2UodGhpcy5pbnZva2UuYmluZCh0aGlzKSwgVG9uZS5UaWNrcyh0aGlzLl9uZXh0VGljaykpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiB1cFxuXHQgKiBAcmV0dXJuIHtUb25lLlRyYW5zcG9ydFJlcGVhdEV2ZW50fSB0aGlzXG5cdCAqL1xuXHRUb25lLlRyYW5zcG9ydFJlcGVhdEV2ZW50LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKXtcblx0XHR0aGlzLlRyYW5zcG9ydC5jbGVhcih0aGlzLl9jdXJyZW50SWQpO1xuXHRcdHRoaXMuVHJhbnNwb3J0LmNsZWFyKHRoaXMuX25leHRJZCk7XG5cdFx0dGhpcy5UcmFuc3BvcnQub2ZmKFwic3RhcnQgbG9vcFN0YXJ0XCIsIHRoaXMuX2JvdW5kUmVzdGFydCk7XG5cdFx0dGhpcy5fYm91bmRDcmVhdGVFdmVudHMgPSBudWxsO1xuXHRcdFRvbmUuVHJhbnNwb3J0RXZlbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0XHR0aGlzLmR1cmF0aW9uID0gbnVsbDtcblx0XHR0aGlzLl9pbnRlcnZhbCA9IG51bGw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0cmV0dXJuIFRvbmUuVHJhbnNwb3J0UmVwZWF0RXZlbnQ7XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7Ozs7O0FBTUE7QUFFQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/core/TransportRepeatEvent.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/instrument/Instrument.js":
/*!*********************************************************!*\
  !*** ./node_modules/tone/Tone/instrument/Instrument.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/type/Type */ \"./node_modules/tone/Tone/type/Type.js\"), __webpack_require__(/*! Tone/core/Master */ \"./node_modules/tone/Tone/core/Master.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  \"use strict\";\n  /**\n   *  @class  Base-class for all instruments\n   *\n   *  @constructor\n   *  @extends {Tone.AudioNode}\n   */\n\n  Tone.Instrument = function (options) {\n    //get the defaults\n    options = Tone.defaultArg(options, Tone.Instrument.defaults);\n    Tone.AudioNode.call(this);\n    /**\n     *  The output and volume triming node\n     *  @type  {Tone.Volume}\n     *  @private\n     */\n\n    this._volume = this.output = new Tone.Volume(options.volume);\n    /**\n     * The volume of the output in decibels.\n     * @type {Decibels}\n     * @signal\n     * @example\n     * source.volume.value = -6;\n     */\n\n    this.volume = this._volume.volume;\n\n    this._readOnly(\"volume\");\n    /**\n     * Keep track of all events scheduled to the transport\n     * when the instrument is 'synced'\n     * @type {Array<Number>}\n     * @private\n     */\n\n\n    this._scheduledEvents = [];\n  };\n\n  Tone.extend(Tone.Instrument, Tone.AudioNode);\n  /**\n   *  the default attributes\n   *  @type {object}\n   */\n\n  Tone.Instrument.defaults = {\n    /** the volume of the output in decibels */\n    \"volume\": 0\n  };\n  /**\n   *  @abstract\n   *  @param {string|number} note the note to trigger\n   *  @param {Time} [time=now] the time to trigger the ntoe\n   *  @param {number} [velocity=1] the velocity to trigger the note\n   */\n\n  Tone.Instrument.prototype.triggerAttack = Tone.noOp;\n  /**\n   *  @abstract\n   *  @param {Time} [time=now] when to trigger the release\n   */\n\n  Tone.Instrument.prototype.triggerRelease = Tone.noOp;\n  /**\n   * Sync the instrument to the Transport. All subsequent calls of\n   * [triggerAttack](#triggerattack) and [triggerRelease](#triggerrelease)\n   * will be scheduled along the transport.\n   * @example\n   * instrument.sync()\n   * //schedule 3 notes when the transport first starts\n   * instrument.triggerAttackRelease('C4', '8n', 0)\n   * instrument.triggerAttackRelease('E4', '8n', '8n')\n   * instrument.triggerAttackRelease('G4', '8n', '4n')\n   * //start the transport to hear the notes\n   * Transport.start()\n   * @returns {Tone.Instrument} this\n   */\n\n  Tone.Instrument.prototype.sync = function () {\n    this._syncMethod(\"triggerAttack\", 1);\n\n    this._syncMethod(\"triggerRelease\", 0);\n\n    return this;\n  };\n  /**\n   * Wrap the given method so that it can be synchronized\n   * @param {String} method Which method to wrap and sync\n   * @param  {Number} timePosition What position the time argument appears in\n   * @private\n   */\n\n\n  Tone.Instrument.prototype._syncMethod = function (method, timePosition) {\n    var originalMethod = this[\"_original_\" + method] = this[method];\n\n    this[method] = function () {\n      var args = Array.prototype.slice.call(arguments);\n      var time = args[timePosition];\n      var id = Tone.Transport.schedule(function (t) {\n        args[timePosition] = t;\n        originalMethod.apply(this, args);\n      }.bind(this), time);\n\n      this._scheduledEvents.push(id);\n    }.bind(this);\n  };\n  /**\n   * Unsync the instrument from the Transport\n   * @returns {Tone.Instrument} this\n   */\n\n\n  Tone.Instrument.prototype.unsync = function () {\n    this._scheduledEvents.forEach(function (id) {\n      Tone.Transport.clear(id);\n    });\n\n    this._scheduledEvents = [];\n\n    if (this._original_triggerAttack) {\n      this.triggerAttack = this._original_triggerAttack;\n      this.triggerRelease = this._original_triggerRelease;\n    }\n\n    return this;\n  };\n  /**\n   *  Trigger the attack and then the release after the duration.\n   *  @param  {Frequency} note     The note to trigger.\n   *  @param  {Time} duration How long the note should be held for before\n   *                          triggering the release. This value must be greater than 0.\n   *  @param {Time} [time=now]  When the note should be triggered.\n   *  @param  {NormalRange} [velocity=1] The velocity the note should be triggered at.\n   *  @returns {Tone.Instrument} this\n   *  @example\n   * //trigger \"C4\" for the duration of an 8th note\n   * synth.triggerAttackRelease(\"C4\", \"8n\");\n   */\n\n\n  Tone.Instrument.prototype.triggerAttackRelease = function (note, duration, time, velocity) {\n    time = this.toSeconds(time);\n    duration = this.toSeconds(duration);\n    this.triggerAttack(note, time, velocity);\n    this.triggerRelease(time + duration);\n    return this;\n  };\n  /**\n   *  clean up\n   *  @returns {Tone.Instrument} this\n   */\n\n\n  Tone.Instrument.prototype.dispose = function () {\n    Tone.AudioNode.prototype.dispose.call(this);\n\n    this._volume.dispose();\n\n    this._volume = null;\n\n    this._writable([\"volume\"]);\n\n    this.volume = null;\n    this.unsync();\n    this._scheduledEvents = null;\n    return this;\n  };\n\n  return Tone.Instrument;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2luc3RydW1lbnQvSW5zdHJ1bWVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90b25lL1RvbmUvaW5zdHJ1bWVudC9JbnN0cnVtZW50LmpzPzU4ZTIiXSwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFtcIlRvbmUvY29yZS9Ub25lXCIsIFwiVG9uZS90eXBlL1R5cGVcIiwgXCJUb25lL2NvcmUvTWFzdGVyXCJdLCBmdW5jdGlvbihUb25lKXtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogIEBjbGFzcyAgQmFzZS1jbGFzcyBmb3IgYWxsIGluc3RydW1lbnRzXG5cdCAqXG5cdCAqICBAY29uc3RydWN0b3Jcblx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0ICovXG5cdFRvbmUuSW5zdHJ1bWVudCA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuXG5cdFx0Ly9nZXQgdGhlIGRlZmF1bHRzXG5cdFx0b3B0aW9ucyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLkluc3RydW1lbnQuZGVmYXVsdHMpO1xuXHRcdFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cblx0XHQvKipcblx0XHQgKiAgVGhlIG91dHB1dCBhbmQgdm9sdW1lIHRyaW1pbmcgbm9kZVxuXHRcdCAqICBAdHlwZSAge1RvbmUuVm9sdW1lfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3ZvbHVtZSA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuVm9sdW1lKG9wdGlvbnMudm9sdW1lKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB2b2x1bWUgb2YgdGhlIG91dHB1dCBpbiBkZWNpYmVscy5cblx0XHQgKiBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0ICogQHNpZ25hbFxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogc291cmNlLnZvbHVtZS52YWx1ZSA9IC02O1xuXHRcdCAqL1xuXHRcdHRoaXMudm9sdW1lID0gdGhpcy5fdm9sdW1lLnZvbHVtZTtcblx0XHR0aGlzLl9yZWFkT25seShcInZvbHVtZVwiKTtcblxuXHRcdC8qKlxuXHRcdCAqIEtlZXAgdHJhY2sgb2YgYWxsIGV2ZW50cyBzY2hlZHVsZWQgdG8gdGhlIHRyYW5zcG9ydFxuXHRcdCAqIHdoZW4gdGhlIGluc3RydW1lbnQgaXMgJ3N5bmNlZCdcblx0XHQgKiBAdHlwZSB7QXJyYXk8TnVtYmVyPn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3NjaGVkdWxlZEV2ZW50cyA9IFtdO1xuXHR9O1xuXG5cdFRvbmUuZXh0ZW5kKFRvbmUuSW5zdHJ1bWVudCwgVG9uZS5BdWRpb05vZGUpO1xuXG5cdC8qKlxuXHQgKiAgdGhlIGRlZmF1bHQgYXR0cmlidXRlc1xuXHQgKiAgQHR5cGUge29iamVjdH1cblx0ICovXG5cdFRvbmUuSW5zdHJ1bWVudC5kZWZhdWx0cyA9IHtcblx0XHQvKiogdGhlIHZvbHVtZSBvZiB0aGUgb3V0cHV0IGluIGRlY2liZWxzICovXG5cdFx0XCJ2b2x1bWVcIiA6IDBcblx0fTtcblxuXHQvKipcblx0ICogIEBhYnN0cmFjdFxuXHQgKiAgQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBub3RlIHRoZSBub3RlIHRvIHRyaWdnZXJcblx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0byB0cmlnZ2VyIHRoZSBudG9lXG5cdCAqICBAcGFyYW0ge251bWJlcn0gW3ZlbG9jaXR5PTFdIHRoZSB2ZWxvY2l0eSB0byB0cmlnZ2VyIHRoZSBub3RlXG5cdCAqL1xuXHRUb25lLkluc3RydW1lbnQucHJvdG90eXBlLnRyaWdnZXJBdHRhY2sgPSBUb25lLm5vT3A7XG5cblx0LyoqXG5cdCAqICBAYWJzdHJhY3Rcblx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB3aGVuIHRvIHRyaWdnZXIgdGhlIHJlbGVhc2Vcblx0ICovXG5cdFRvbmUuSW5zdHJ1bWVudC5wcm90b3R5cGUudHJpZ2dlclJlbGVhc2UgPSBUb25lLm5vT3A7XG5cblx0LyoqXG5cdCAqIFN5bmMgdGhlIGluc3RydW1lbnQgdG8gdGhlIFRyYW5zcG9ydC4gQWxsIHN1YnNlcXVlbnQgY2FsbHMgb2Zcblx0ICogW3RyaWdnZXJBdHRhY2tdKCN0cmlnZ2VyYXR0YWNrKSBhbmQgW3RyaWdnZXJSZWxlYXNlXSgjdHJpZ2dlcnJlbGVhc2UpXG5cdCAqIHdpbGwgYmUgc2NoZWR1bGVkIGFsb25nIHRoZSB0cmFuc3BvcnQuXG5cdCAqIEBleGFtcGxlXG5cdCAqIGluc3RydW1lbnQuc3luYygpXG5cdCAqIC8vc2NoZWR1bGUgMyBub3RlcyB3aGVuIHRoZSB0cmFuc3BvcnQgZmlyc3Qgc3RhcnRzXG5cdCAqIGluc3RydW1lbnQudHJpZ2dlckF0dGFja1JlbGVhc2UoJ0M0JywgJzhuJywgMClcblx0ICogaW5zdHJ1bWVudC50cmlnZ2VyQXR0YWNrUmVsZWFzZSgnRTQnLCAnOG4nLCAnOG4nKVxuXHQgKiBpbnN0cnVtZW50LnRyaWdnZXJBdHRhY2tSZWxlYXNlKCdHNCcsICc4bicsICc0bicpXG5cdCAqIC8vc3RhcnQgdGhlIHRyYW5zcG9ydCB0byBoZWFyIHRoZSBub3Rlc1xuXHQgKiBUcmFuc3BvcnQuc3RhcnQoKVxuXHQgKiBAcmV0dXJucyB7VG9uZS5JbnN0cnVtZW50fSB0aGlzXG5cdCAqL1xuXHRUb25lLkluc3RydW1lbnQucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbigpe1xuXHRcdHRoaXMuX3N5bmNNZXRob2QoXCJ0cmlnZ2VyQXR0YWNrXCIsIDEpO1xuXHRcdHRoaXMuX3N5bmNNZXRob2QoXCJ0cmlnZ2VyUmVsZWFzZVwiLCAwKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogV3JhcCB0aGUgZ2l2ZW4gbWV0aG9kIHNvIHRoYXQgaXQgY2FuIGJlIHN5bmNocm9uaXplZFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIFdoaWNoIG1ldGhvZCB0byB3cmFwIGFuZCBzeW5jXG5cdCAqIEBwYXJhbSAge051bWJlcn0gdGltZVBvc2l0aW9uIFdoYXQgcG9zaXRpb24gdGhlIHRpbWUgYXJndW1lbnQgYXBwZWFycyBpblxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0VG9uZS5JbnN0cnVtZW50LnByb3RvdHlwZS5fc3luY01ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZCwgdGltZVBvc2l0aW9uKXtcblx0XHR2YXIgb3JpZ2luYWxNZXRob2QgPSB0aGlzW1wiX29yaWdpbmFsX1wiK21ldGhvZF0gPSB0aGlzW21ldGhvZF07XG5cdFx0dGhpc1ttZXRob2RdID0gZnVuY3Rpb24oKXtcblx0XHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHRcdHZhciB0aW1lID0gYXJnc1t0aW1lUG9zaXRpb25dO1xuXHRcdFx0dmFyIGlkID0gVG9uZS5UcmFuc3BvcnQuc2NoZWR1bGUoZnVuY3Rpb24odCl7XG5cdFx0XHRcdGFyZ3NbdGltZVBvc2l0aW9uXSA9IHQ7XG5cdFx0XHRcdG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdFx0fS5iaW5kKHRoaXMpLCB0aW1lKTtcblx0XHRcdHRoaXMuX3NjaGVkdWxlZEV2ZW50cy5wdXNoKGlkKTtcblx0XHR9LmJpbmQodGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVuc3luYyB0aGUgaW5zdHJ1bWVudCBmcm9tIHRoZSBUcmFuc3BvcnRcblx0ICogQHJldHVybnMge1RvbmUuSW5zdHJ1bWVudH0gdGhpc1xuXHQgKi9cblx0VG9uZS5JbnN0cnVtZW50LnByb3RvdHlwZS51bnN5bmMgPSBmdW5jdGlvbigpe1xuXHRcdHRoaXMuX3NjaGVkdWxlZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGlkKXtcblx0XHRcdFRvbmUuVHJhbnNwb3J0LmNsZWFyKGlkKTtcblx0XHR9KTtcblx0XHR0aGlzLl9zY2hlZHVsZWRFdmVudHMgPSBbXTtcblx0XHRpZiAodGhpcy5fb3JpZ2luYWxfdHJpZ2dlckF0dGFjayl7XG5cdFx0XHR0aGlzLnRyaWdnZXJBdHRhY2sgPSB0aGlzLl9vcmlnaW5hbF90cmlnZ2VyQXR0YWNrO1xuXHRcdFx0dGhpcy50cmlnZ2VyUmVsZWFzZSA9IHRoaXMuX29yaWdpbmFsX3RyaWdnZXJSZWxlYXNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogIFRyaWdnZXIgdGhlIGF0dGFjayBhbmQgdGhlbiB0aGUgcmVsZWFzZSBhZnRlciB0aGUgZHVyYXRpb24uXG5cdCAqICBAcGFyYW0gIHtGcmVxdWVuY3l9IG5vdGUgICAgIFRoZSBub3RlIHRvIHRyaWdnZXIuXG5cdCAqICBAcGFyYW0gIHtUaW1lfSBkdXJhdGlvbiBIb3cgbG9uZyB0aGUgbm90ZSBzaG91bGQgYmUgaGVsZCBmb3IgYmVmb3JlXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyaW5nIHRoZSByZWxlYXNlLiBUaGlzIHZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAuXG5cdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gIFdoZW4gdGhlIG5vdGUgc2hvdWxkIGJlIHRyaWdnZXJlZC5cblx0ICogIEBwYXJhbSAge05vcm1hbFJhbmdlfSBbdmVsb2NpdHk9MV0gVGhlIHZlbG9jaXR5IHRoZSBub3RlIHNob3VsZCBiZSB0cmlnZ2VyZWQgYXQuXG5cdCAqICBAcmV0dXJucyB7VG9uZS5JbnN0cnVtZW50fSB0aGlzXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAvL3RyaWdnZXIgXCJDNFwiIGZvciB0aGUgZHVyYXRpb24gb2YgYW4gOHRoIG5vdGVcblx0ICogc3ludGgudHJpZ2dlckF0dGFja1JlbGVhc2UoXCJDNFwiLCBcIjhuXCIpO1xuXHQgKi9cblx0VG9uZS5JbnN0cnVtZW50LnByb3RvdHlwZS50cmlnZ2VyQXR0YWNrUmVsZWFzZSA9IGZ1bmN0aW9uKG5vdGUsIGR1cmF0aW9uLCB0aW1lLCB2ZWxvY2l0eSl7XG5cdFx0dGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHRcdGR1cmF0aW9uID0gdGhpcy50b1NlY29uZHMoZHVyYXRpb24pO1xuXHRcdHRoaXMudHJpZ2dlckF0dGFjayhub3RlLCB0aW1lLCB2ZWxvY2l0eSk7XG5cdFx0dGhpcy50cmlnZ2VyUmVsZWFzZSh0aW1lICsgZHVyYXRpb24pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgY2xlYW4gdXBcblx0ICogIEByZXR1cm5zIHtUb25lLkluc3RydW1lbnR9IHRoaXNcblx0ICovXG5cdFRvbmUuSW5zdHJ1bWVudC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCl7XG5cdFx0VG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0XHR0aGlzLl92b2x1bWUuZGlzcG9zZSgpO1xuXHRcdHRoaXMuX3ZvbHVtZSA9IG51bGw7XG5cdFx0dGhpcy5fd3JpdGFibGUoW1widm9sdW1lXCJdKTtcblx0XHR0aGlzLnZvbHVtZSA9IG51bGw7XG5cdFx0dGhpcy51bnN5bmMoKTtcblx0XHR0aGlzLl9zY2hlZHVsZWRFdmVudHMgPSBudWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdHJldHVybiBUb25lLkluc3RydW1lbnQ7XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTtBQUVBOzs7Ozs7O0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQUE7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7Ozs7Ozs7QUFNQTtBQUVBOzs7OztBQUlBO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/instrument/Instrument.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/instrument/Sampler.js":
/*!******************************************************!*\
  !*** ./node_modules/tone/Tone/instrument/Sampler.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/instrument/Instrument */ \"./node_modules/tone/Tone/instrument/Instrument.js\"), __webpack_require__(/*! Tone/core/Buffers */ \"./node_modules/tone/Tone/core/Buffers.js\"), __webpack_require__(/*! Tone/source/BufferSource */ \"./node_modules/tone/Tone/source/BufferSource.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  /**\n   * @class Automatically interpolates between a set of pitched samples. Pass in an object which maps the note's pitch or midi value to the url, then you can trigger the attack and release of that note like other instruments. By automatically repitching the samples, it is possible to play pitches which were not explicitly included which can save loading time.\n   *        For sample or buffer playback where repitching is not necessary, use [Tone.Player](https://tonejs.github.io/docs/Player).\n   * @param {Object} samples An object of samples mapping either Midi\n   *                         Note Numbers or Scientific Pitch Notation\n   *                         to the url of that sample.\n   * @param {Function=} onload The callback to invoke when all of the samples are loaded.\n   * @param {String=} baseUrl The root URL of all of the samples, which is prepended to all the URLs.\n   * @example\n   * var sampler = new Tone.Sampler({\n   * \t\"C3\" : \"path/to/C3.mp3\",\n   * \t\"D#3\" : \"path/to/Dsharp3.mp3\",\n   * \t\"F#3\" : \"path/to/Fsharp3.mp3\",\n   * \t\"A3\" : \"path/to/A3.mp3\",\n   * }, function(){\n   * \t//sampler will repitch the closest sample\n   * \tsampler.triggerAttack(\"D3\")\n   * })\n   * @extends {Tone.Instrument}\n   */\n  Tone.Sampler = function (urls) {\n    // shift arguments over one. Those are the remainder of the options\n    var args = Array.prototype.slice.call(arguments);\n    args.shift();\n    var options = Tone.defaults(args, [\"onload\", \"baseUrl\"], Tone.Sampler);\n    Tone.Instrument.call(this, options);\n    var urlMap = {};\n\n    for (var note in urls) {\n      if (Tone.isNote(note)) {\n        //convert the note name to MIDI\n        var mid = Tone.Frequency(note).toMidi();\n        urlMap[mid] = urls[note];\n      } else if (!isNaN(parseFloat(note))) {\n        //otherwise if it's numbers assume it's midi\n        urlMap[note] = urls[note];\n      } else {\n        throw new Error(\"Tone.Sampler: url keys must be the note's pitch\");\n      }\n    }\n    /**\n     * The stored and loaded buffers\n     * @type {Tone.Buffers}\n     * @private\n     */\n\n\n    this._buffers = new Tone.Buffers(urlMap, options.onload, options.baseUrl);\n    /**\n     * The object of all currently playing BufferSources\n     * @type {Object}\n     * @private\n     */\n\n    this._activeSources = {};\n    /**\n     * The envelope applied to the beginning of the sample.\n     * @type {Time}\n     */\n\n    this.attack = options.attack;\n    /**\n     * The envelope applied to the end of the envelope.\n     * @type {Time}\n     */\n\n    this.release = options.release;\n  };\n\n  Tone.extend(Tone.Sampler, Tone.Instrument);\n  /**\n   * The defaults\n   * @const\n   * @type {Object}\n   */\n\n  Tone.Sampler.defaults = {\n    attack: 0,\n    release: 0.1,\n    onload: Tone.noOp,\n    baseUrl: \"\"\n  };\n  /**\n   * Returns the difference in steps between the given midi note at the closets sample.\n   * @param  {Midi} midi\n   * @return {Interval}\n   * @private\n   */\n\n  Tone.Sampler.prototype._findClosest = function (midi) {\n    //searches within 8 octaves of the given midi note\n    var MAX_INTERVAL = 96;\n    var interval = 0;\n\n    while (interval < MAX_INTERVAL) {\n      // check above and below\n      if (this._buffers.has(midi + interval)) {\n        return -interval;\n      } else if (this._buffers.has(midi - interval)) {\n        return interval;\n      }\n\n      interval++;\n    }\n\n    return null;\n  };\n  /**\n   * @param  {Frequency} note     The note to play\n   * @param  {Time=} time     When to play the note\n   * @param  {NormalRange=} velocity The velocity to play the sample back.\n   * @return {Tone.Sampler}          this\n   */\n\n\n  Tone.Sampler.prototype.triggerAttack = function (note, time, velocity) {\n    var midi = Tone.Frequency(note).toMidi(); // find the closest note pitch\n\n    var difference = this._findClosest(midi);\n\n    if (difference !== null) {\n      var closestNote = midi - difference;\n\n      var buffer = this._buffers.get(closestNote); // play that note\n\n\n      var source = new Tone.BufferSource({\n        \"buffer\": buffer,\n        \"playbackRate\": Tone.intervalToFrequencyRatio(difference),\n        \"fadeIn\": this.attack,\n        \"fadeOut\": this.release,\n        \"curve\": \"exponential\"\n      }).connect(this.output);\n      source.start(time, 0, buffer.duration, velocity); // add it to the active sources\n\n      if (!Tone.isArray(this._activeSources[midi])) {\n        this._activeSources[midi] = [];\n      }\n\n      this._activeSources[midi].push({\n        note: midi,\n        source: source\n      });\n    }\n\n    return this;\n  };\n  /**\n   * @param  {Frequency} note     The note to release.\n   * @param  {Time=} time     \tWhen to release the note.\n   * @return {Tone.Sampler}\tthis\n   */\n\n\n  Tone.Sampler.prototype.triggerRelease = function (note, time) {\n    var midi = Tone.Frequency(note).toMidi(); // find the note\n\n    if (this._activeSources[midi] && this._activeSources[midi].length) {\n      var source = this._activeSources[midi].shift().source;\n\n      time = this.toSeconds(time);\n      source.stop(time + this.release, this.release);\n    }\n\n    return this;\n  };\n  /**\n   * Release all currently active notes.\n   * @param  {Time=} time     \tWhen to release the notes.\n   * @return {Tone.Sampler}\tthis\n   */\n\n\n  Tone.Sampler.prototype.releaseAll = function (time) {\n    time = this.toSeconds(time);\n\n    for (var note in this._activeSources) {\n      var sources = this._activeSources[note];\n\n      while (sources.length) {\n        var source = sources.shift().source;\n        source.stop(time + this.release, this.release);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Sync the instrument to the Transport. All subsequent calls of\n   * [triggerAttack](#triggerattack) and [triggerRelease](#triggerrelease)\n   * will be scheduled along the transport.\n   * @example\n   * synth.sync()\n   * //schedule 3 notes when the transport first starts\n   * synth.triggerAttackRelease('8n', 0)\n   * synth.triggerAttackRelease('8n', '8n')\n   * synth.triggerAttackRelease('8n', '4n')\n   * //start the transport to hear the notes\n   * Transport.start()\n   * @returns {Tone.Instrument} this\n   */\n\n\n  Tone.Sampler.prototype.sync = function () {\n    this._syncMethod(\"triggerAttack\", 1);\n\n    this._syncMethod(\"triggerRelease\", 1);\n\n    return this;\n  };\n  /**\n   * Invoke the attack phase, then after the duration, invoke the release.\n   * @param  {Frequency} note     The note to play\n   * @param  {Time} duration The time the note should be held\n   * @param  {Time=} time     When to start the attack\n   * @param  {NormalRange} [velocity=1] The velocity of the attack\n   * @return {Tone.Sampler}          this\n   */\n\n\n  Tone.Sampler.prototype.triggerAttackRelease = function (note, duration, time, velocity) {\n    time = this.toSeconds(time);\n    duration = this.toSeconds(duration);\n    this.triggerAttack(note, time, velocity);\n    this.triggerRelease(note, time + duration);\n    return this;\n  };\n  /**\n   *  Add a note to the sampler.\n   *  @param  {Note|Midi}   note      The buffer's pitch.\n   *  @param  {String|Tone.Buffer|Audiobuffer}  url  Either the url of the bufer,\n   *                                                 or a buffer which will be added\n   *                                                 with the given name.\n   *  @param  {Function=}  callback  The callback to invoke\n   *                                 when the url is loaded.\n   */\n\n\n  Tone.Sampler.prototype.add = function (note, url, callback) {\n    if (Tone.isNote(note)) {\n      //convert the note name to MIDI\n      var mid = Tone.Frequency(note).toMidi();\n\n      this._buffers.add(mid, url, callback);\n    } else if (!isNaN(parseFloat(note))) {\n      //otherwise if it's numbers assume it's midi\n      this._buffers.add(note, url, callback);\n    } else {\n      throw new Error(\"Tone.Sampler: note must be the note's pitch. Instead got \" + note);\n    }\n  };\n  /**\n   * If the buffers are loaded or not\n   * @memberOf Tone.Sampler#\n   * @type {Boolean}\n   * @name loaded\n   * @readOnly\n   */\n\n\n  Object.defineProperty(Tone.Sampler.prototype, \"loaded\", {\n    get: function () {\n      function get() {\n        return this._buffers.loaded;\n      }\n\n      return get;\n    }()\n  });\n  /**\n   * Clean up\n   * @return {Tone.Sampler} this\n   */\n\n  Tone.Sampler.prototype.dispose = function () {\n    Tone.Instrument.prototype.dispose.call(this);\n\n    this._buffers.dispose();\n\n    this._buffers = null;\n\n    for (var midi in this._activeSources) {\n      this._activeSources[midi].forEach(function (event) {\n        event.source.dispose();\n      });\n    }\n\n    this._activeSources = null;\n    return this;\n  };\n\n  return Tone.Sampler;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL2luc3RydW1lbnQvU2FtcGxlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90b25lL1RvbmUvaW5zdHJ1bWVudC9TYW1wbGVyLmpzP2IzYzkiXSwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFtcIlRvbmUvY29yZS9Ub25lXCIsIFwiVG9uZS9pbnN0cnVtZW50L0luc3RydW1lbnRcIiwgXCJUb25lL2NvcmUvQnVmZmVyc1wiLCBcIlRvbmUvc291cmNlL0J1ZmZlclNvdXJjZVwiXSwgZnVuY3Rpb24oVG9uZSl7XG5cblx0LyoqXG5cdCAqIEBjbGFzcyBBdXRvbWF0aWNhbGx5IGludGVycG9sYXRlcyBiZXR3ZWVuIGEgc2V0IG9mIHBpdGNoZWQgc2FtcGxlcy4gUGFzcyBpbiBhbiBvYmplY3Qgd2hpY2ggbWFwcyB0aGUgbm90ZSdzIHBpdGNoIG9yIG1pZGkgdmFsdWUgdG8gdGhlIHVybCwgdGhlbiB5b3UgY2FuIHRyaWdnZXIgdGhlIGF0dGFjayBhbmQgcmVsZWFzZSBvZiB0aGF0IG5vdGUgbGlrZSBvdGhlciBpbnN0cnVtZW50cy4gQnkgYXV0b21hdGljYWxseSByZXBpdGNoaW5nIHRoZSBzYW1wbGVzLCBpdCBpcyBwb3NzaWJsZSB0byBwbGF5IHBpdGNoZXMgd2hpY2ggd2VyZSBub3QgZXhwbGljaXRseSBpbmNsdWRlZCB3aGljaCBjYW4gc2F2ZSBsb2FkaW5nIHRpbWUuXG5cdCAqICAgICAgICBGb3Igc2FtcGxlIG9yIGJ1ZmZlciBwbGF5YmFjayB3aGVyZSByZXBpdGNoaW5nIGlzIG5vdCBuZWNlc3NhcnksIHVzZSBbVG9uZS5QbGF5ZXJdKGh0dHBzOi8vdG9uZWpzLmdpdGh1Yi5pby9kb2NzL1BsYXllcikuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzYW1wbGVzIEFuIG9iamVjdCBvZiBzYW1wbGVzIG1hcHBpbmcgZWl0aGVyIE1pZGlcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgTm90ZSBOdW1iZXJzIG9yIFNjaWVudGlmaWMgUGl0Y2ggTm90YXRpb25cblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgdG8gdGhlIHVybCBvZiB0aGF0IHNhbXBsZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbj19IG9ubG9hZCBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYWxsIG9mIHRoZSBzYW1wbGVzIGFyZSBsb2FkZWQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nPX0gYmFzZVVybCBUaGUgcm9vdCBVUkwgb2YgYWxsIG9mIHRoZSBzYW1wbGVzLCB3aGljaCBpcyBwcmVwZW5kZWQgdG8gYWxsIHRoZSBVUkxzLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiB2YXIgc2FtcGxlciA9IG5ldyBUb25lLlNhbXBsZXIoe1xuXHQgKiBcdFwiQzNcIiA6IFwicGF0aC90by9DMy5tcDNcIixcblx0ICogXHRcIkQjM1wiIDogXCJwYXRoL3RvL0RzaGFycDMubXAzXCIsXG5cdCAqIFx0XCJGIzNcIiA6IFwicGF0aC90by9Gc2hhcnAzLm1wM1wiLFxuXHQgKiBcdFwiQTNcIiA6IFwicGF0aC90by9BMy5tcDNcIixcblx0ICogfSwgZnVuY3Rpb24oKXtcblx0ICogXHQvL3NhbXBsZXIgd2lsbCByZXBpdGNoIHRoZSBjbG9zZXN0IHNhbXBsZVxuXHQgKiBcdHNhbXBsZXIudHJpZ2dlckF0dGFjayhcIkQzXCIpXG5cdCAqIH0pXG5cdCAqIEBleHRlbmRzIHtUb25lLkluc3RydW1lbnR9XG5cdCAqL1xuXHRUb25lLlNhbXBsZXIgPSBmdW5jdGlvbih1cmxzKXtcblxuXHRcdC8vIHNoaWZ0IGFyZ3VtZW50cyBvdmVyIG9uZS4gVGhvc2UgYXJlIHRoZSByZW1haW5kZXIgb2YgdGhlIG9wdGlvbnNcblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0YXJncy5zaGlmdCgpO1xuXHRcdHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmdzLCBbXCJvbmxvYWRcIiwgXCJiYXNlVXJsXCJdLCBUb25lLlNhbXBsZXIpO1xuXHRcdFRvbmUuSW5zdHJ1bWVudC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG5cdFx0dmFyIHVybE1hcCA9IHt9O1xuXHRcdGZvciAodmFyIG5vdGUgaW4gdXJscyl7XG5cdFx0XHRpZiAoVG9uZS5pc05vdGUobm90ZSkpe1xuXHRcdFx0XHQvL2NvbnZlcnQgdGhlIG5vdGUgbmFtZSB0byBNSURJXG5cdFx0XHRcdHZhciBtaWQgPSBUb25lLkZyZXF1ZW5jeShub3RlKS50b01pZGkoKTtcblx0XHRcdFx0dXJsTWFwW21pZF0gPSB1cmxzW25vdGVdO1xuXHRcdFx0fSBlbHNlIGlmICghaXNOYU4ocGFyc2VGbG9hdChub3RlKSkpe1xuXHRcdFx0XHQvL290aGVyd2lzZSBpZiBpdCdzIG51bWJlcnMgYXNzdW1lIGl0J3MgbWlkaVxuXHRcdFx0XHR1cmxNYXBbbm90ZV0gPSB1cmxzW25vdGVdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVG9uZS5TYW1wbGVyOiB1cmwga2V5cyBtdXN0IGJlIHRoZSBub3RlJ3MgcGl0Y2hcIik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHN0b3JlZCBhbmQgbG9hZGVkIGJ1ZmZlcnNcblx0XHQgKiBAdHlwZSB7VG9uZS5CdWZmZXJzfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fYnVmZmVycyA9IG5ldyBUb25lLkJ1ZmZlcnModXJsTWFwLCBvcHRpb25zLm9ubG9hZCwgb3B0aW9ucy5iYXNlVXJsKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBvYmplY3Qgb2YgYWxsIGN1cnJlbnRseSBwbGF5aW5nIEJ1ZmZlclNvdXJjZXNcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fYWN0aXZlU291cmNlcyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGVudmVsb3BlIGFwcGxpZWQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgc2FtcGxlLlxuXHRcdCAqIEB0eXBlIHtUaW1lfVxuXHRcdCAqL1xuXHRcdHRoaXMuYXR0YWNrID0gb3B0aW9ucy5hdHRhY2s7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZW52ZWxvcGUgYXBwbGllZCB0byB0aGUgZW5kIG9mIHRoZSBlbnZlbG9wZS5cblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKi9cblx0XHR0aGlzLnJlbGVhc2UgPSBvcHRpb25zLnJlbGVhc2U7XG5cdH07XG5cblx0VG9uZS5leHRlbmQoVG9uZS5TYW1wbGVyLCBUb25lLkluc3RydW1lbnQpO1xuXG5cdC8qKlxuXHQgKiBUaGUgZGVmYXVsdHNcblx0ICogQGNvbnN0XG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqL1xuXHRUb25lLlNhbXBsZXIuZGVmYXVsdHMgPSB7XG5cdFx0YXR0YWNrIDogMCxcblx0XHRyZWxlYXNlIDogMC4xLFxuXHRcdG9ubG9hZCA6IFRvbmUubm9PcCxcblx0XHRiYXNlVXJsIDogXCJcIlxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIGluIHN0ZXBzIGJldHdlZW4gdGhlIGdpdmVuIG1pZGkgbm90ZSBhdCB0aGUgY2xvc2V0cyBzYW1wbGUuXG5cdCAqIEBwYXJhbSAge01pZGl9IG1pZGlcblx0ICogQHJldHVybiB7SW50ZXJ2YWx9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLlNhbXBsZXIucHJvdG90eXBlLl9maW5kQ2xvc2VzdCA9IGZ1bmN0aW9uKG1pZGkpe1xuXHRcdC8vc2VhcmNoZXMgd2l0aGluIDggb2N0YXZlcyBvZiB0aGUgZ2l2ZW4gbWlkaSBub3RlXG5cdFx0dmFyIE1BWF9JTlRFUlZBTCA9IDk2OyBcblx0XHR2YXIgaW50ZXJ2YWwgPSAwO1xuXHRcdHdoaWxlIChpbnRlcnZhbCA8IE1BWF9JTlRFUlZBTCl7XG5cdFx0XHQvLyBjaGVjayBhYm92ZSBhbmQgYmVsb3dcblx0XHRcdGlmICh0aGlzLl9idWZmZXJzLmhhcyhtaWRpICsgaW50ZXJ2YWwpKXtcblx0XHRcdFx0cmV0dXJuIC1pbnRlcnZhbDtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fYnVmZmVycy5oYXMobWlkaSAtIGludGVydmFsKSl7XG5cdFx0XHRcdHJldHVybiBpbnRlcnZhbDtcblx0XHRcdH1cblx0XHRcdGludGVydmFsKys7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0gIHtGcmVxdWVuY3l9IG5vdGUgICAgIFRoZSBub3RlIHRvIHBsYXlcblx0ICogQHBhcmFtICB7VGltZT19IHRpbWUgICAgIFdoZW4gdG8gcGxheSB0aGUgbm90ZVxuXHQgKiBAcGFyYW0gIHtOb3JtYWxSYW5nZT19IHZlbG9jaXR5IFRoZSB2ZWxvY2l0eSB0byBwbGF5IHRoZSBzYW1wbGUgYmFjay5cblx0ICogQHJldHVybiB7VG9uZS5TYW1wbGVyfSAgICAgICAgICB0aGlzXG5cdCAqL1xuXHRUb25lLlNhbXBsZXIucHJvdG90eXBlLnRyaWdnZXJBdHRhY2sgPSBmdW5jdGlvbihub3RlLCB0aW1lLCB2ZWxvY2l0eSl7XG5cdFx0dmFyIG1pZGkgPSBUb25lLkZyZXF1ZW5jeShub3RlKS50b01pZGkoKTtcblx0XHQvLyBmaW5kIHRoZSBjbG9zZXN0IG5vdGUgcGl0Y2hcblx0XHR2YXIgZGlmZmVyZW5jZSA9IHRoaXMuX2ZpbmRDbG9zZXN0KG1pZGkpO1xuXHRcdGlmIChkaWZmZXJlbmNlICE9PSBudWxsKXtcblx0XHRcdHZhciBjbG9zZXN0Tm90ZSA9IG1pZGkgLSBkaWZmZXJlbmNlO1xuXHRcdFx0dmFyIGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcnMuZ2V0KGNsb3Nlc3ROb3RlKTtcblx0XHRcdC8vIHBsYXkgdGhhdCBub3RlXG5cdFx0XHR2YXIgc291cmNlID0gbmV3IFRvbmUuQnVmZmVyU291cmNlKHtcblx0XHRcdFx0XCJidWZmZXJcIiA6IGJ1ZmZlcixcblx0XHRcdFx0XCJwbGF5YmFja1JhdGVcIiA6IFRvbmUuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvKGRpZmZlcmVuY2UpLFxuXHRcdFx0XHRcImZhZGVJblwiIDogdGhpcy5hdHRhY2ssXG5cdFx0XHRcdFwiZmFkZU91dFwiIDogdGhpcy5yZWxlYXNlLFxuXHRcdFx0XHRcImN1cnZlXCIgOiBcImV4cG9uZW50aWFsXCIsXG5cdFx0XHR9KS5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0XHRcdHNvdXJjZS5zdGFydCh0aW1lLCAwLCBidWZmZXIuZHVyYXRpb24sIHZlbG9jaXR5KTtcblx0XHRcdC8vIGFkZCBpdCB0byB0aGUgYWN0aXZlIHNvdXJjZXNcblx0XHRcdGlmICghVG9uZS5pc0FycmF5KHRoaXMuX2FjdGl2ZVNvdXJjZXNbbWlkaV0pKXtcblx0XHRcdFx0dGhpcy5fYWN0aXZlU291cmNlc1ttaWRpXSA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fYWN0aXZlU291cmNlc1ttaWRpXS5wdXNoKHtcblx0XHRcdFx0bm90ZSA6IG1pZGksXG5cdFx0XHRcdHNvdXJjZSA6IHNvdXJjZVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0gIHtGcmVxdWVuY3l9IG5vdGUgICAgIFRoZSBub3RlIHRvIHJlbGVhc2UuXG5cdCAqIEBwYXJhbSAge1RpbWU9fSB0aW1lICAgICBcdFdoZW4gdG8gcmVsZWFzZSB0aGUgbm90ZS5cblx0ICogQHJldHVybiB7VG9uZS5TYW1wbGVyfVx0dGhpc1xuXHQgKi9cblx0VG9uZS5TYW1wbGVyLnByb3RvdHlwZS50cmlnZ2VyUmVsZWFzZSA9IGZ1bmN0aW9uKG5vdGUsIHRpbWUpe1xuXHRcdHZhciBtaWRpID0gVG9uZS5GcmVxdWVuY3kobm90ZSkudG9NaWRpKCk7XG5cdFx0Ly8gZmluZCB0aGUgbm90ZVxuXHRcdGlmICh0aGlzLl9hY3RpdmVTb3VyY2VzW21pZGldICYmIHRoaXMuX2FjdGl2ZVNvdXJjZXNbbWlkaV0ubGVuZ3RoKXtcblx0XHRcdHZhciBzb3VyY2UgPSB0aGlzLl9hY3RpdmVTb3VyY2VzW21pZGldLnNoaWZ0KCkuc291cmNlO1xuXHRcdFx0dGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHRcdFx0c291cmNlLnN0b3AodGltZSArIHRoaXMucmVsZWFzZSwgdGhpcy5yZWxlYXNlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbGVhc2UgYWxsIGN1cnJlbnRseSBhY3RpdmUgbm90ZXMuXG5cdCAqIEBwYXJhbSAge1RpbWU9fSB0aW1lICAgICBcdFdoZW4gdG8gcmVsZWFzZSB0aGUgbm90ZXMuXG5cdCAqIEByZXR1cm4ge1RvbmUuU2FtcGxlcn1cdHRoaXNcblx0ICovXG5cdFRvbmUuU2FtcGxlci5wcm90b3R5cGUucmVsZWFzZUFsbCA9IGZ1bmN0aW9uKHRpbWUpe1xuXHRcdHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0XHRmb3IgKHZhciBub3RlIGluIHRoaXMuX2FjdGl2ZVNvdXJjZXMpe1xuXHRcdFx0dmFyIHNvdXJjZXMgPSB0aGlzLl9hY3RpdmVTb3VyY2VzW25vdGVdO1xuXHRcdFx0d2hpbGUgKHNvdXJjZXMubGVuZ3RoKXtcblx0XHRcdFx0dmFyIHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKS5zb3VyY2U7XG5cdFx0XHRcdHNvdXJjZS5zdG9wKHRpbWUgKyB0aGlzLnJlbGVhc2UsIHRoaXMucmVsZWFzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTeW5jIHRoZSBpbnN0cnVtZW50IHRvIHRoZSBUcmFuc3BvcnQuIEFsbCBzdWJzZXF1ZW50IGNhbGxzIG9mXG5cdCAqIFt0cmlnZ2VyQXR0YWNrXSgjdHJpZ2dlcmF0dGFjaykgYW5kIFt0cmlnZ2VyUmVsZWFzZV0oI3RyaWdnZXJyZWxlYXNlKVxuXHQgKiB3aWxsIGJlIHNjaGVkdWxlZCBhbG9uZyB0aGUgdHJhbnNwb3J0LlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBzeW50aC5zeW5jKClcblx0ICogLy9zY2hlZHVsZSAzIG5vdGVzIHdoZW4gdGhlIHRyYW5zcG9ydCBmaXJzdCBzdGFydHNcblx0ICogc3ludGgudHJpZ2dlckF0dGFja1JlbGVhc2UoJzhuJywgMClcblx0ICogc3ludGgudHJpZ2dlckF0dGFja1JlbGVhc2UoJzhuJywgJzhuJylcblx0ICogc3ludGgudHJpZ2dlckF0dGFja1JlbGVhc2UoJzhuJywgJzRuJylcblx0ICogLy9zdGFydCB0aGUgdHJhbnNwb3J0IHRvIGhlYXIgdGhlIG5vdGVzXG5cdCAqIFRyYW5zcG9ydC5zdGFydCgpXG5cdCAqIEByZXR1cm5zIHtUb25lLkluc3RydW1lbnR9IHRoaXNcblx0ICovXG5cdFRvbmUuU2FtcGxlci5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uKCl7XG5cdFx0dGhpcy5fc3luY01ldGhvZChcInRyaWdnZXJBdHRhY2tcIiwgMSk7XG5cdFx0dGhpcy5fc3luY01ldGhvZChcInRyaWdnZXJSZWxlYXNlXCIsIDEpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnZva2UgdGhlIGF0dGFjayBwaGFzZSwgdGhlbiBhZnRlciB0aGUgZHVyYXRpb24sIGludm9rZSB0aGUgcmVsZWFzZS5cblx0ICogQHBhcmFtICB7RnJlcXVlbmN5fSBub3RlICAgICBUaGUgbm90ZSB0byBwbGF5XG5cdCAqIEBwYXJhbSAge1RpbWV9IGR1cmF0aW9uIFRoZSB0aW1lIHRoZSBub3RlIHNob3VsZCBiZSBoZWxkXG5cdCAqIEBwYXJhbSAge1RpbWU9fSB0aW1lICAgICBXaGVuIHRvIHN0YXJ0IHRoZSBhdHRhY2tcblx0ICogQHBhcmFtICB7Tm9ybWFsUmFuZ2V9IFt2ZWxvY2l0eT0xXSBUaGUgdmVsb2NpdHkgb2YgdGhlIGF0dGFja1xuXHQgKiBAcmV0dXJuIHtUb25lLlNhbXBsZXJ9ICAgICAgICAgIHRoaXNcblx0ICovXG5cdFRvbmUuU2FtcGxlci5wcm90b3R5cGUudHJpZ2dlckF0dGFja1JlbGVhc2UgPSBmdW5jdGlvbihub3RlLCBkdXJhdGlvbiwgdGltZSwgdmVsb2NpdHkpe1xuXHRcdHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0XHRkdXJhdGlvbiA9IHRoaXMudG9TZWNvbmRzKGR1cmF0aW9uKTtcblx0XHR0aGlzLnRyaWdnZXJBdHRhY2sobm90ZSwgdGltZSwgdmVsb2NpdHkpO1xuXHRcdHRoaXMudHJpZ2dlclJlbGVhc2Uobm90ZSwgdGltZSArIGR1cmF0aW9uKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogIEFkZCBhIG5vdGUgdG8gdGhlIHNhbXBsZXIuXG5cdCAqICBAcGFyYW0gIHtOb3RlfE1pZGl9ICAgbm90ZSAgICAgIFRoZSBidWZmZXIncyBwaXRjaC5cblx0ICogIEBwYXJhbSAge1N0cmluZ3xUb25lLkJ1ZmZlcnxBdWRpb2J1ZmZlcn0gIHVybCAgRWl0aGVyIHRoZSB1cmwgb2YgdGhlIGJ1ZmVyLFxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBhIGJ1ZmZlciB3aGljaCB3aWxsIGJlIGFkZGVkXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdGhlIGdpdmVuIG5hbWUuXG5cdCAqICBAcGFyYW0gIHtGdW5jdGlvbj19ICBjYWxsYmFjayAgVGhlIGNhbGxiYWNrIHRvIGludm9rZVxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW4gdGhlIHVybCBpcyBsb2FkZWQuXG5cdCAqL1xuXHRUb25lLlNhbXBsZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG5vdGUsIHVybCwgY2FsbGJhY2spe1xuXHRcdGlmIChUb25lLmlzTm90ZShub3RlKSl7XG5cdFx0XHQvL2NvbnZlcnQgdGhlIG5vdGUgbmFtZSB0byBNSURJXG5cdFx0XHR2YXIgbWlkID0gVG9uZS5GcmVxdWVuY3kobm90ZSkudG9NaWRpKCk7XG5cdFx0XHR0aGlzLl9idWZmZXJzLmFkZChtaWQsIHVybCwgY2FsbGJhY2spO1xuXHRcdH0gZWxzZSBpZiAoIWlzTmFOKHBhcnNlRmxvYXQobm90ZSkpKXtcblx0XHRcdC8vb3RoZXJ3aXNlIGlmIGl0J3MgbnVtYmVycyBhc3N1bWUgaXQncyBtaWRpXG5cdFx0XHR0aGlzLl9idWZmZXJzLmFkZChub3RlLCB1cmwsIGNhbGxiYWNrKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVG9uZS5TYW1wbGVyOiBub3RlIG11c3QgYmUgdGhlIG5vdGUncyBwaXRjaC4gSW5zdGVhZCBnb3QgXCIrbm90ZSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBJZiB0aGUgYnVmZmVycyBhcmUgbG9hZGVkIG9yIG5vdFxuXHQgKiBAbWVtYmVyT2YgVG9uZS5TYW1wbGVyI1xuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQG5hbWUgbG9hZGVkXG5cdCAqIEByZWFkT25seVxuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU2FtcGxlci5wcm90b3R5cGUsIFwibG9hZGVkXCIsIHtcblx0XHRnZXQgOiBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX2J1ZmZlcnMubG9hZGVkO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIENsZWFuIHVwXG5cdCAqIEByZXR1cm4ge1RvbmUuU2FtcGxlcn0gdGhpc1xuXHQgKi9cblx0VG9uZS5TYW1wbGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKXtcblx0XHRUb25lLkluc3RydW1lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0XHR0aGlzLl9idWZmZXJzLmRpc3Bvc2UoKTtcblx0XHR0aGlzLl9idWZmZXJzID0gbnVsbDtcblx0XHRmb3IgKHZhciBtaWRpIGluIHRoaXMuX2FjdGl2ZVNvdXJjZXMpe1xuXHRcdFx0dGhpcy5fYWN0aXZlU291cmNlc1ttaWRpXS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KXtcblx0XHRcdFx0ZXZlbnQuc291cmNlLmRpc3Bvc2UoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHR0aGlzLl9hY3RpdmVTb3VyY2VzID0gbnVsbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHRyZXR1cm4gVG9uZS5TYW1wbGVyO1xufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBRUE7Ozs7O0FBSUE7QUFFQTs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQURBO0FBTUE7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/instrument/Sampler.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/shim/AudioBuffer.js":
/*!****************************************************!*\
  !*** ./node_modules/tone/Tone/shim/AudioBuffer.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  /**\n   *  AudioBuffer.copyTo/FromChannel polyfill\n   *  @private\n   */\n  if (Tone.supported) {\n    if (!AudioBuffer.prototype.copyToChannel) {\n      AudioBuffer.prototype.copyToChannel = function (src, chanNum, start) {\n        var channel = this.getChannelData(chanNum);\n        start = start || 0;\n\n        for (var i = 0; i < channel.length; i++) {\n          channel[i + start] = src[i];\n        }\n      };\n\n      AudioBuffer.prototype.copyFromChannel = function (dest, chanNum, start) {\n        var channel = this.getChannelData(chanNum);\n        start = start || 0;\n\n        for (var i = 0; i < dest.length; i++) {\n          dest[i] = channel[i + start];\n        }\n      };\n    }\n  }\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3NoaW0vQXVkaW9CdWZmZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3NoaW0vQXVkaW9CdWZmZXIuanM/MzUzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoW1wiVG9uZS9jb3JlL1RvbmVcIl0sIGZ1bmN0aW9uKFRvbmUpe1xuXG5cdC8qKlxuXHQgKiAgQXVkaW9CdWZmZXIuY29weVRvL0Zyb21DaGFubmVsIHBvbHlmaWxsXG5cdCAqICBAcHJpdmF0ZVxuXHQgKi9cblx0aWYgKFRvbmUuc3VwcG9ydGVkKXtcblx0XHRpZiAoIUF1ZGlvQnVmZmVyLnByb3RvdHlwZS5jb3B5VG9DaGFubmVsKXtcblx0XHRcdEF1ZGlvQnVmZmVyLnByb3RvdHlwZS5jb3B5VG9DaGFubmVsID0gZnVuY3Rpb24oc3JjLCBjaGFuTnVtLCBzdGFydCl7XG5cdFx0XHRcdHZhciBjaGFubmVsID0gdGhpcy5nZXRDaGFubmVsRGF0YShjaGFuTnVtKTtcblx0XHRcdFx0c3RhcnQgPSBzdGFydCB8fCAwO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5uZWwubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRcdGNoYW5uZWxbaStzdGFydF0gPSBzcmNbaV07XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRBdWRpb0J1ZmZlci5wcm90b3R5cGUuY29weUZyb21DaGFubmVsID0gZnVuY3Rpb24oZGVzdCwgY2hhbk51bSwgc3RhcnQpe1xuXHRcdFx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuZ2V0Q2hhbm5lbERhdGEoY2hhbk51bSk7XG5cdFx0XHRcdHN0YXJ0ID0gc3RhcnQgfHwgMDtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkZXN0Lmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0XHRkZXN0W2ldID0gY2hhbm5lbFtpK3N0YXJ0XTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/shim/AudioBuffer.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/shim/AudioContext.js":
/*!*****************************************************!*\
  !*** ./node_modules/tone/Tone/shim/AudioContext.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/shim/OfflineAudioContext */ \"./node_modules/tone/Tone/shim/OfflineAudioContext.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  if (Tone.supported) {\n    if (!window.hasOwnProperty(\"AudioContext\") && window.hasOwnProperty(\"webkitAudioContext\")) {\n      window.AudioContext = window.webkitAudioContext;\n    } //not functionally equivalent, but only an API placeholder\n\n\n    if (!AudioContext.prototype.close) {\n      AudioContext.prototype.close = function () {\n        if (Tone.isFunction(this.suspend)) {\n          this.suspend();\n        }\n\n        return Promise.resolve();\n      };\n    } //not functionally equivalent\n\n\n    if (!AudioContext.prototype.resume) {\n      AudioContext.prototype.resume = function () {\n        return Promise.resolve();\n      };\n    } //createGain\n\n\n    if (!AudioContext.prototype.createGain && AudioContext.prototype.createGainNode) {\n      AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;\n    } //createDelay\n\n\n    if (!AudioContext.prototype.createDelay && AudioContext.prototype.createDelayNode) {\n      AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;\n    } //test decodeAudioData returns a promise\n    // https://github.com/mohayonao/web-audio-api-shim/blob/master/src/AudioContext.js\n    // MIT License (c) 2015 @mohayonao\n\n\n    var decodeAudioDataPromise = false;\n    var offlineContext = new OfflineAudioContext(1, 1, 44100);\n    var audioData = new Uint32Array([1179011410, 48, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 8, 0, 0, 0, 0]).buffer;\n\n    try {\n      var ret = offlineContext.decodeAudioData(audioData);\n\n      if (ret instanceof Promise) {\n        decodeAudioDataPromise = true;\n      }\n    } catch (e) {\n      decodeAudioDataPromise = false;\n    }\n\n    if (!decodeAudioDataPromise) {\n      AudioContext.prototype._native_decodeAudioData = AudioContext.prototype.decodeAudioData;\n\n      AudioContext.prototype.decodeAudioData = function (audioData) {\n        return new Promise(function (success, error) {\n          this._native_decodeAudioData(audioData, success, error);\n        }.bind(this));\n      };\n    }\n  }\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3NoaW0vQXVkaW9Db250ZXh0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RvbmUvVG9uZS9zaGltL0F1ZGlvQ29udGV4dC5qcz85MGVlIl0sInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbXCJUb25lL2NvcmUvVG9uZVwiLCBcIlRvbmUvc2hpbS9PZmZsaW5lQXVkaW9Db250ZXh0XCJdLCBmdW5jdGlvbihUb25lKXtcblxuXHRpZiAoVG9uZS5zdXBwb3J0ZWQpe1xuXHRcdGlmICghd2luZG93Lmhhc093blByb3BlcnR5KFwiQXVkaW9Db250ZXh0XCIpICYmIHdpbmRvdy5oYXNPd25Qcm9wZXJ0eShcIndlYmtpdEF1ZGlvQ29udGV4dFwiKSl7XG5cdFx0XHR3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dDtcblx0XHR9XG5cblx0XHQvL25vdCBmdW5jdGlvbmFsbHkgZXF1aXZhbGVudCwgYnV0IG9ubHkgYW4gQVBJIHBsYWNlaG9sZGVyXG5cdFx0aWYgKCFBdWRpb0NvbnRleHQucHJvdG90eXBlLmNsb3NlKXtcblx0XHRcdEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRpZiAoVG9uZS5pc0Z1bmN0aW9uKHRoaXMuc3VzcGVuZCkpe1xuXHRcdFx0XHRcdHRoaXMuc3VzcGVuZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly9ub3QgZnVuY3Rpb25hbGx5IGVxdWl2YWxlbnRcblx0XHRpZiAoIUF1ZGlvQ29udGV4dC5wcm90b3R5cGUucmVzdW1lKXtcblx0XHRcdEF1ZGlvQ29udGV4dC5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvL2NyZWF0ZUdhaW5cblx0XHRpZiAoIUF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlR2FpbiAmJiBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUdhaW5Ob2RlKXtcblx0XHRcdEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlR2FpbiA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlR2Fpbk5vZGU7XG5cdFx0fVxuXG5cdFx0Ly9jcmVhdGVEZWxheVxuXHRcdGlmICghQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEZWxheSAmJiBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZURlbGF5Tm9kZSl7XG5cdFx0XHRBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZURlbGF5ID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEZWxheU5vZGU7XG5cdFx0fVxuXG5cdFx0Ly90ZXN0IGRlY29kZUF1ZGlvRGF0YSByZXR1cm5zIGEgcHJvbWlzZVxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2hheW9uYW8vd2ViLWF1ZGlvLWFwaS1zaGltL2Jsb2IvbWFzdGVyL3NyYy9BdWRpb0NvbnRleHQuanNcblx0XHQvLyBNSVQgTGljZW5zZSAoYykgMjAxNSBAbW9oYXlvbmFvXG5cdFx0dmFyIGRlY29kZUF1ZGlvRGF0YVByb21pc2UgPSBmYWxzZTtcblx0XHR2YXIgb2ZmbGluZUNvbnRleHQgPSBuZXcgT2ZmbGluZUF1ZGlvQ29udGV4dCgxLCAxLCA0NDEwMCk7XG5cdFx0dmFyIGF1ZGlvRGF0YSA9IG5ldyBVaW50MzJBcnJheShbMTE3OTAxMTQxMCwgNDgsIDExNjMyODA3MjcsIDU0NDUwMTA5NCwgMTYsIDEzMTA3MywgNDQxMDAsIDE3NjQwMCwgMTA0ODU4MCwgMTYzNTAxNzA2MCwgOCwgMCwgMCwgMCwgMF0pLmJ1ZmZlcjtcblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG9mZmxpbmVDb250ZXh0LmRlY29kZUF1ZGlvRGF0YShhdWRpb0RhdGEpO1xuXHRcdFx0aWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2Upe1xuXHRcdFx0XHRkZWNvZGVBdWRpb0RhdGFQcm9taXNlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKXtcblx0XHRcdGRlY29kZUF1ZGlvRGF0YVByb21pc2UgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoIWRlY29kZUF1ZGlvRGF0YVByb21pc2Upe1xuXHRcdFx0QXVkaW9Db250ZXh0LnByb3RvdHlwZS5fbmF0aXZlX2RlY29kZUF1ZGlvRGF0YSA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuZGVjb2RlQXVkaW9EYXRhO1xuXHRcdFx0QXVkaW9Db250ZXh0LnByb3RvdHlwZS5kZWNvZGVBdWRpb0RhdGEgPSBmdW5jdGlvbihhdWRpb0RhdGEpe1xuXHRcdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oc3VjY2VzcywgZXJyb3Ipe1xuXHRcdFx0XHRcdHRoaXMuX25hdGl2ZV9kZWNvZGVBdWRpb0RhdGEoYXVkaW9EYXRhLCBzdWNjZXNzLCBlcnJvcik7XG5cdFx0XHRcdH0uYmluZCh0aGlzKSk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/shim/AudioContext.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/shim/BufferSourceNode.js":
/*!*********************************************************!*\
  !*** ./node_modules/tone/Tone/shim/BufferSourceNode.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/core/OfflineContext */ \"./node_modules/tone/Tone/core/OfflineContext.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  if (Tone.supported) {\n    var ua = navigator.userAgent.toLowerCase();\n    var isMobileSafari = ua.includes(\"safari\") && !ua.includes(\"chrome\") && ua.includes(\"mobile\");\n\n    if (isMobileSafari) {\n      //mobile safari has a bizarre bug with the offline context\n      //when a BufferSourceNode is started, it starts the offline context\n      //\n      //deferring all BufferSource starts till the last possible moment\n      //reduces the likelihood of this happening\n      Tone.OfflineContext.prototype.createBufferSource = function () {\n        var bufferSource = this._context.createBufferSource();\n\n        var _native_start = bufferSource.start;\n\n        bufferSource.start = function (time) {\n          this.setTimeout(function () {\n            _native_start.call(bufferSource, time);\n          }.bind(this), 0);\n        }.bind(this);\n\n        return bufferSource;\n      };\n    }\n  }\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3NoaW0vQnVmZmVyU291cmNlTm9kZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90b25lL1RvbmUvc2hpbS9CdWZmZXJTb3VyY2VOb2RlLmpzPzQzMjkiXSwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFtcIlRvbmUvY29yZS9Ub25lXCIsIFwiVG9uZS9jb3JlL09mZmxpbmVDb250ZXh0XCJdLCBmdW5jdGlvbihUb25lKXtcblxuXHRpZiAoVG9uZS5zdXBwb3J0ZWQpe1xuXG5cdFx0dmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuXHRcdHZhciBpc01vYmlsZVNhZmFyaSA9IHVhLmluY2x1ZGVzKFwic2FmYXJpXCIpICYmICF1YS5pbmNsdWRlcyhcImNocm9tZVwiKSAmJiB1YS5pbmNsdWRlcyhcIm1vYmlsZVwiKTtcblx0XHRpZiAoaXNNb2JpbGVTYWZhcmkpe1xuXHRcdFx0Ly9tb2JpbGUgc2FmYXJpIGhhcyBhIGJpemFycmUgYnVnIHdpdGggdGhlIG9mZmxpbmUgY29udGV4dFxuXHRcdFx0Ly93aGVuIGEgQnVmZmVyU291cmNlTm9kZSBpcyBzdGFydGVkLCBpdCBzdGFydHMgdGhlIG9mZmxpbmUgY29udGV4dFxuXHRcdFx0Ly9cblx0XHRcdC8vZGVmZXJyaW5nIGFsbCBCdWZmZXJTb3VyY2Ugc3RhcnRzIHRpbGwgdGhlIGxhc3QgcG9zc2libGUgbW9tZW50XG5cdFx0XHQvL3JlZHVjZXMgdGhlIGxpa2VsaWhvb2Qgb2YgdGhpcyBoYXBwZW5pbmdcblx0XHRcdFRvbmUuT2ZmbGluZUNvbnRleHQucHJvdG90eXBlLmNyZWF0ZUJ1ZmZlclNvdXJjZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHZhciBidWZmZXJTb3VyY2UgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuXHRcdFx0XHR2YXIgX25hdGl2ZV9zdGFydCA9IGJ1ZmZlclNvdXJjZS5zdGFydDtcblx0XHRcdFx0YnVmZmVyU291cmNlLnN0YXJ0ID0gZnVuY3Rpb24odGltZSl7XG5cdFx0XHRcdFx0dGhpcy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRfbmF0aXZlX3N0YXJ0LmNhbGwoYnVmZmVyU291cmNlLCB0aW1lKTtcblx0XHRcdFx0XHR9LmJpbmQodGhpcyksIDApO1xuXHRcdFx0XHR9LmJpbmQodGhpcyk7XG5cdFx0XHRcdHJldHVybiBidWZmZXJTb3VyY2U7XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/shim/BufferSourceNode.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/shim/ConstantSourceNode.js":
/*!***********************************************************!*\
  !*** ./node_modules/tone/Tone/shim/ConstantSourceNode.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/shim/AudioContext */ \"./node_modules/tone/Tone/shim/AudioContext.js\"), __webpack_require__(/*! Tone/shim/BufferSourceNode */ \"./node_modules/tone/Tone/shim/BufferSourceNode.js\"), __webpack_require__(/*! Tone/core/Context */ \"./node_modules/tone/Tone/core/Context.js\"), __webpack_require__(/*! Tone/core/Gain */ \"./node_modules/tone/Tone/core/Gain.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  if (Tone.supported && !AudioContext.prototype.createConstantSource) {\n    var ConstantSourceNode = function ConstantSourceNode(context) {\n      this.context = context;\n      var buffer = context.createBuffer(1, 128, context.sampleRate);\n      var arr = buffer.getChannelData(0);\n\n      for (var i = 0; i < arr.length; i++) {\n        arr[i] = 1;\n      }\n\n      this._bufferSource = context.createBufferSource();\n      this._bufferSource.channelCount = 1;\n      this._bufferSource.channelCountMode = \"explicit\";\n      this._bufferSource.buffer = buffer;\n      this._bufferSource.loop = true;\n      var gainNode = this._output = context.createGain();\n      this.offset = gainNode.gain;\n\n      this._bufferSource.connect(gainNode);\n    };\n\n    ConstantSourceNode.prototype.start = function (time) {\n      this._bufferSource.start(time);\n\n      return this;\n    };\n\n    ConstantSourceNode.prototype.stop = function (time) {\n      this._bufferSource.stop(time);\n\n      return this;\n    };\n\n    ConstantSourceNode.prototype.connect = function () {\n      this._output.connect.apply(this._output, arguments);\n\n      return this;\n    };\n\n    ConstantSourceNode.prototype.disconnect = function () {\n      this._output.disconnect.apply(this._output, arguments);\n\n      return this;\n    };\n\n    AudioContext.prototype.createConstantSource = function () {\n      return new ConstantSourceNode(this);\n    };\n\n    Tone.Context.prototype.createConstantSource = function () {\n      return new ConstantSourceNode(this);\n    };\n  }\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3NoaW0vQ29uc3RhbnRTb3VyY2VOb2RlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RvbmUvVG9uZS9zaGltL0NvbnN0YW50U291cmNlTm9kZS5qcz83YjFmIl0sInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbXCJUb25lL2NvcmUvVG9uZVwiLCBcIlRvbmUvc2hpbS9BdWRpb0NvbnRleHRcIiwgXCJUb25lL3NoaW0vQnVmZmVyU291cmNlTm9kZVwiLFxuXHRcIlRvbmUvY29yZS9Db250ZXh0XCIsIFwiVG9uZS9jb3JlL0dhaW5cIl0sIGZ1bmN0aW9uKFRvbmUpe1xuXG5cdGlmIChUb25lLnN1cHBvcnRlZCAmJiAhQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVDb25zdGFudFNvdXJjZSl7XG5cblx0XHR2YXIgQ29uc3RhbnRTb3VyY2VOb2RlID0gZnVuY3Rpb24oY29udGV4dCl7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuXG5cdFx0XHR2YXIgYnVmZmVyID0gY29udGV4dC5jcmVhdGVCdWZmZXIoMSwgMTI4LCBjb250ZXh0LnNhbXBsZVJhdGUpO1xuXHRcdFx0dmFyIGFyciA9IGJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0YXJyW2ldID0gMTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fYnVmZmVyU291cmNlID0gY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcblx0XHRcdHRoaXMuX2J1ZmZlclNvdXJjZS5jaGFubmVsQ291bnQgPSAxO1xuXHRcdFx0dGhpcy5fYnVmZmVyU291cmNlLmNoYW5uZWxDb3VudE1vZGUgPSBcImV4cGxpY2l0XCI7XG5cdFx0XHR0aGlzLl9idWZmZXJTb3VyY2UuYnVmZmVyID0gYnVmZmVyO1xuXHRcdFx0dGhpcy5fYnVmZmVyU291cmNlLmxvb3AgPSB0cnVlO1xuXG5cdFx0XHR2YXIgZ2Fpbk5vZGUgPSB0aGlzLl9vdXRwdXQgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcblx0XHRcdHRoaXMub2Zmc2V0ID0gZ2Fpbk5vZGUuZ2FpbjtcblxuXHRcdFx0dGhpcy5fYnVmZmVyU291cmNlLmNvbm5lY3QoZ2Fpbk5vZGUpO1xuXHRcdH07XG5cblx0XHRDb25zdGFudFNvdXJjZU5vZGUucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24odGltZSl7XG5cdFx0XHR0aGlzLl9idWZmZXJTb3VyY2Uuc3RhcnQodGltZSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0Q29uc3RhbnRTb3VyY2VOb2RlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24odGltZSl7XG5cdFx0XHR0aGlzLl9idWZmZXJTb3VyY2Uuc3RvcCh0aW1lKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRDb25zdGFudFNvdXJjZU5vZGUucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5fb3V0cHV0LmNvbm5lY3QuYXBwbHkodGhpcy5fb3V0cHV0LCBhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdENvbnN0YW50U291cmNlTm9kZS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHR0aGlzLl9vdXRwdXQuZGlzY29ubmVjdC5hcHBseSh0aGlzLl9vdXRwdXQsIGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0QXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVDb25zdGFudFNvdXJjZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gbmV3IENvbnN0YW50U291cmNlTm9kZSh0aGlzKTtcblx0XHR9O1xuXG5cdFx0VG9uZS5Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVDb25zdGFudFNvdXJjZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gbmV3IENvbnN0YW50U291cmNlTm9kZSh0aGlzKTtcblx0XHR9O1xuXHR9XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFHQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/shim/ConstantSourceNode.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/shim/OfflineAudioContext.js":
/*!************************************************************!*\
  !*** ./node_modules/tone/Tone/shim/OfflineAudioContext.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  if (Tone.supported) {\n    if (!window.hasOwnProperty(\"OfflineAudioContext\") && window.hasOwnProperty(\"webkitOfflineAudioContext\")) {\n      window.OfflineAudioContext = window.webkitOfflineAudioContext;\n    } //returns promise?\n\n\n    var context = new OfflineAudioContext(1, 1, 44100);\n    var ret = context.startRendering();\n\n    if (!(ret instanceof Promise)) {\n      OfflineAudioContext.prototype._native_startRendering = OfflineAudioContext.prototype.startRendering;\n\n      OfflineAudioContext.prototype.startRendering = function () {\n        return new Promise(function (done) {\n          this.oncomplete = function (e) {\n            done(e.renderedBuffer);\n          };\n\n          this._native_startRendering();\n        }.bind(this));\n      };\n    }\n  }\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3NoaW0vT2ZmbGluZUF1ZGlvQ29udGV4dC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90b25lL1RvbmUvc2hpbS9PZmZsaW5lQXVkaW9Db250ZXh0LmpzPzg2NWUiXSwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFtcIlRvbmUvY29yZS9Ub25lXCJdLCBmdW5jdGlvbihUb25lKXtcblx0aWYgKFRvbmUuc3VwcG9ydGVkKXtcblxuXHRcdGlmICghd2luZG93Lmhhc093blByb3BlcnR5KFwiT2ZmbGluZUF1ZGlvQ29udGV4dFwiKSAmJiB3aW5kb3cuaGFzT3duUHJvcGVydHkoXCJ3ZWJraXRPZmZsaW5lQXVkaW9Db250ZXh0XCIpKXtcblx0XHRcdHdpbmRvdy5PZmZsaW5lQXVkaW9Db250ZXh0ID0gd2luZG93LndlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQ7XG5cdFx0fVxuXG5cdFx0Ly9yZXR1cm5zIHByb21pc2U/XG5cdFx0dmFyIGNvbnRleHQgPSBuZXcgT2ZmbGluZUF1ZGlvQ29udGV4dCgxLCAxLCA0NDEwMCk7XG5cdFx0dmFyIHJldCA9IGNvbnRleHQuc3RhcnRSZW5kZXJpbmcoKTtcblx0XHRpZiAoIShyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSl7XG5cdFx0XHRPZmZsaW5lQXVkaW9Db250ZXh0LnByb3RvdHlwZS5fbmF0aXZlX3N0YXJ0UmVuZGVyaW5nID0gT2ZmbGluZUF1ZGlvQ29udGV4dC5wcm90b3R5cGUuc3RhcnRSZW5kZXJpbmc7XG5cdFx0XHRPZmZsaW5lQXVkaW9Db250ZXh0LnByb3RvdHlwZS5zdGFydFJlbmRlcmluZyA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihkb25lKXtcblx0XHRcdFx0XHR0aGlzLm9uY29tcGxldGUgPSBmdW5jdGlvbihlKXtcblx0XHRcdFx0XHRcdGRvbmUoZS5yZW5kZXJlZEJ1ZmZlcik7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR0aGlzLl9uYXRpdmVfc3RhcnRSZW5kZXJpbmcoKTtcblx0XHRcdFx0fS5iaW5kKHRoaXMpKTtcblx0XHRcdH07XG5cdFx0fVxuXHR9XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/shim/OfflineAudioContext.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/shim/WaveShaperNode.js":
/*!*******************************************************!*\
  !*** ./node_modules/tone/Tone/shim/WaveShaperNode.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/shim/AudioContext */ \"./node_modules/tone/Tone/shim/AudioContext.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  if (Tone.supported) {\n    //fixes safari only bug which is still present in 11\n    var ua = navigator.userAgent.toLowerCase();\n    var isSafari = ua.includes(\"safari\") && !ua.includes(\"chrome\");\n\n    if (isSafari) {\n      var WaveShaperNode = function WaveShaperNode(context) {\n        this._internalNode = this.input = this.output = context._native_createWaveShaper();\n        this._curve = null;\n\n        for (var prop in this._internalNode) {\n          this._defineProperty(this._internalNode, prop);\n        }\n      };\n\n      Object.defineProperty(WaveShaperNode.prototype, \"curve\", {\n        get: function () {\n          function get() {\n            return this._curve;\n          }\n\n          return get;\n        }(),\n        set: function () {\n          function set(curve) {\n            this._curve = curve;\n            var array = new Float32Array(curve.length + 1);\n            array.set(curve, 1);\n            array[0] = curve[0];\n            this._internalNode.curve = array;\n          }\n\n          return set;\n        }()\n      });\n\n      WaveShaperNode.prototype._defineProperty = function (context, prop) {\n        if (Tone.isUndef(this[prop])) {\n          Object.defineProperty(this, prop, {\n            get: function () {\n              function get() {\n                if (typeof context[prop] === \"function\") {\n                  return context[prop].bind(context);\n                } else {\n                  return context[prop];\n                }\n              }\n\n              return get;\n            }(),\n            set: function () {\n              function set(val) {\n                context[prop] = val;\n              }\n\n              return set;\n            }()\n          });\n        }\n      };\n\n      AudioContext.prototype._native_createWaveShaper = AudioContext.prototype.createWaveShaper;\n\n      AudioContext.prototype.createWaveShaper = function () {\n        return new WaveShaperNode(this);\n      };\n    }\n  }\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3NoaW0vV2F2ZVNoYXBlck5vZGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3NoaW0vV2F2ZVNoYXBlck5vZGUuanM/MDZmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoW1wiVG9uZS9jb3JlL1RvbmVcIiwgXCJUb25lL3NoaW0vQXVkaW9Db250ZXh0XCJdLCBmdW5jdGlvbihUb25lKXtcblxuXHRpZiAoVG9uZS5zdXBwb3J0ZWQpe1xuXG5cdFx0Ly9maXhlcyBzYWZhcmkgb25seSBidWcgd2hpY2ggaXMgc3RpbGwgcHJlc2VudCBpbiAxMVxuXHRcdHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcblx0XHR2YXIgaXNTYWZhcmkgPSB1YS5pbmNsdWRlcyhcInNhZmFyaVwiKSAmJiAhdWEuaW5jbHVkZXMoXCJjaHJvbWVcIik7XG5cdFx0aWYgKGlzU2FmYXJpKXtcblxuXHRcdFx0dmFyIFdhdmVTaGFwZXJOb2RlID0gZnVuY3Rpb24oY29udGV4dCl7XG5cblx0XHRcdFx0dGhpcy5faW50ZXJuYWxOb2RlID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gY29udGV4dC5fbmF0aXZlX2NyZWF0ZVdhdmVTaGFwZXIoKTtcblxuXHRcdFx0XHR0aGlzLl9jdXJ2ZSA9IG51bGw7XG5cblx0XHRcdFx0Zm9yICh2YXIgcHJvcCBpbiB0aGlzLl9pbnRlcm5hbE5vZGUpe1xuXHRcdFx0XHRcdHRoaXMuX2RlZmluZVByb3BlcnR5KHRoaXMuX2ludGVybmFsTm9kZSwgcHJvcCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXYXZlU2hhcGVyTm9kZS5wcm90b3R5cGUsIFwiY3VydmVcIiwge1xuXHRcdFx0XHRnZXQgOiBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9jdXJ2ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0IDogZnVuY3Rpb24oY3VydmUpe1xuXHRcdFx0XHRcdHRoaXMuX2N1cnZlID0gY3VydmU7XG5cdFx0XHRcdFx0dmFyIGFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShjdXJ2ZS5sZW5ndGgrMSk7XG5cdFx0XHRcdFx0YXJyYXkuc2V0KGN1cnZlLCAxKTtcblx0XHRcdFx0XHRhcnJheVswXSA9IGN1cnZlWzBdO1xuXHRcdFx0XHRcdHRoaXMuX2ludGVybmFsTm9kZS5jdXJ2ZSA9IGFycmF5O1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0V2F2ZVNoYXBlck5vZGUucHJvdG90eXBlLl9kZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uKGNvbnRleHQsIHByb3Ape1xuXHRcdFx0XHRpZiAoVG9uZS5pc1VuZGVmKHRoaXNbcHJvcF0pKXtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcCwge1xuXHRcdFx0XHRcdFx0Z2V0IDogZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBjb250ZXh0W3Byb3BdID09PSBcImZ1bmN0aW9uXCIpe1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBjb250ZXh0W3Byb3BdLmJpbmQoY29udGV4dCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGNvbnRleHRbcHJvcF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRzZXQgOiBmdW5jdGlvbih2YWwpe1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0W3Byb3BdID0gdmFsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRBdWRpb0NvbnRleHQucHJvdG90eXBlLl9uYXRpdmVfY3JlYXRlV2F2ZVNoYXBlciA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlV2F2ZVNoYXBlcjtcblx0XHRcdEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlV2F2ZVNoYXBlciA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHJldHVybiBuZXcgV2F2ZVNoYXBlck5vZGUodGhpcyk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFBQTtBQUpBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUFBO0FBT0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFSQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/shim/WaveShaperNode.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/signal/Signal.js":
/*!*************************************************!*\
  !*** ./node_modules/tone/Tone/signal/Signal.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/signal/WaveShaper */ \"./node_modules/tone/Tone/signal/WaveShaper.js\"), __webpack_require__(/*! Tone/type/Type */ \"./node_modules/tone/Tone/type/Type.js\"), __webpack_require__(/*! Tone/core/Param */ \"./node_modules/tone/Tone/core/Param.js\"), __webpack_require__(/*! Tone/shim/ConstantSourceNode */ \"./node_modules/tone/Tone/shim/ConstantSourceNode.js\"), __webpack_require__(/*! Tone/core/Gain */ \"./node_modules/tone/Tone/core/Gain.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  \"use strict\";\n  /**\n   *  @class  A signal is an audio-rate value. Tone.Signal is a core component of the library.\n   *          Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal\n   *          has all of the methods available to native Web Audio\n   *          [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)\n   *          as well as additional conveniences. Read more about working with signals\n   *          [here](https://github.com/Tonejs/Tone.js/wiki/Signals).\n   *\n   *  @constructor\n   *  @extends {Tone.Param}\n   *  @param {Number|AudioParam} [value] Initial value of the signal. If an AudioParam\n   *                                     is passed in, that parameter will be wrapped\n   *                                     and controlled by the Signal.\n   *  @param {string} [units=Number] unit The units the signal is in.\n   *  @example\n   * var signal = new Tone.Signal(10);\n   */\n\n  Tone.Signal = function () {\n    var options = Tone.defaults(arguments, [\"value\", \"units\"], Tone.Signal);\n    Tone.Param.call(this, options);\n    /**\n    * When a signal is connected to another signal or audio param,\n    * this signal becomes a proxy for it\n    * @type {Array}\n    * @private\n    */\n\n    this._proxies = [];\n    /**\n    * Indicates if the constant source was started or not\n    * @private\n    * @type {Boolean}\n    */\n\n    this._sourceStarted = false;\n    /**\n     * The constant source node which generates the signal\n     * @type {ConstantSourceNode}\n     * @private\n     */\n\n    this._constantSource = this.context.createConstantSource();\n    this._param = this._constantSource.offset;\n    this.value = options.value;\n    /**\n     * The node where the constant signal value is scaled.\n     * @type {GainNode}\n     * @private\n     */\n\n    this.output = this._constantSource;\n    /**\n     * The node where the value is set.\n     * @type {Tone.Param}\n     * @private\n     */\n\n    this.input = this._param = this.output.offset;\n  };\n\n  Tone.extend(Tone.Signal, Tone.Param);\n  /**\n   *  The default values\n   *  @type  {Object}\n   *  @static\n   *  @const\n   */\n\n  Tone.Signal.defaults = {\n    \"value\": 0,\n    \"units\": Tone.Type.Default,\n    \"convert\": true\n  };\n  /**\n   *  When signals connect to other signals or AudioParams,\n   *  they take over the output value of that signal or AudioParam.\n   *  For all other nodes, the behavior is the same as a default <code>connect</code>.\n   *\n   *  @override\n   *  @param {AudioParam|AudioNode|Tone.Signal|Tone} node\n   *  @param {number} [outputNumber=0] The output number to connect from.\n   *  @param {number} [inputNumber=0] The input number to connect to.\n   *  @returns {Tone.Signal} this\n   *  @method\n   */\n\n  Tone.Signal.prototype.connect = function (node) {\n    //this is an optimization where this node will forward automations\n    //to connected nodes without any signal if possible.\n    if (this._isParam(node) && !this._sourceStarted) {\n      this._proxies.push(node);\n\n      node.overridden = true;\n\n      this._applyAutomations(node);\n    } else {\n      Tone.SignalBase.prototype.connect.apply(this, arguments);\n\n      if (!this._sourceStarted) {\n        this._sourceStarted = true;\n\n        this._constantSource.start(0);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Takes a node as an argument and returns if it is a Param or AudioParam\n   * @param  {*} node The node to test\n   * @return {Boolean}\n   * @private\n   */\n\n\n  Tone.Signal.prototype._isParam = function (node) {\n    return Tone.Param && Tone.Param === node.constructor || node instanceof AudioParam;\n  };\n  /**\n   * Discard the optimization and connect all of the proxies\n   * @private\n   */\n\n\n  Tone.Signal.prototype._connectProxies = function () {\n    if (!this._sourceStarted) {\n      this._sourceStarted = true;\n\n      this._constantSource.start(0);\n    }\n\n    this._proxies.forEach(function (proxy) {\n      Tone.SignalBase.prototype.connect.call(this, proxy);\n\n      if (proxy._proxies) {\n        proxy._connectProxies();\n      }\n    }.bind(this));\n  };\n  /**\n   * Invoked when a node is connected to this\n   * @param  {AudioNode} from\n   * @private\n   */\n\n\n  Tone.Signal.prototype._onConnect = function (from) {\n    if (!this._isParam(from)) {\n      //connect all the proxies\n      this._connectProxies();\n    }\n  };\n  /**\n   * Apply all the current automations to the given parameter\n   * @param  {AudioParam} param\n   * @private\n   */\n\n\n  Tone.Signal.prototype._applyAutomations = function (param) {\n    var now = this.context.currentTime;\n    param.cancelScheduledValues(now);\n    var currentVal = this.getValueAtTime(now);\n    param.setValueAtTime(currentVal, now);\n\n    this._events.forEachFrom(now, function (event) {\n      param[event.type](event.value, event.time, event.constant);\n    });\n  };\n  /**\n   * Disconnect from the given node or all nodes if no param is given.\n   * @param  {AudioNode|AudioParam} node\n   * @return {Tone.Signal}      this\n   */\n\n\n  Tone.Signal.prototype.disconnect = function (node) {\n    if (this._proxies.includes(node)) {\n      var index = this._proxies.indexOf(node);\n\n      this._proxies.splice(index, 1);\n    } else if (!node) {\n      //no argument, disconnect everything\n      this._proxies = [];\n    }\n\n    return Tone.SignalBase.prototype.disconnect.apply(this, arguments);\n  };\n  /**\n   * Return the current signal value at the given time.\n   * @param  {Time} time When to get the signal value\n   * @return {Number}\n   */\n\n\n  Tone.Signal.prototype.getValueAtTime = function (time) {\n    if (this._param.getValueAtTime) {\n      return this._param.getValueAtTime(time);\n    } else {\n      return Tone.Param.prototype.getValueAtTime.call(this, time);\n    }\n  }; //wrap all of the automation methods\n\n\n  [\"setValueAtTime\", \"linearRampToValueAtTime\", \"exponentialRampToValueAtTime\", \"setTargetAtTime\"].forEach(function (method) {\n    var previousMethod = Tone.Signal.prototype[method];\n\n    Tone.Signal.prototype[method] = function () {\n      var args = arguments;\n      previousMethod.apply(this, arguments);\n      args[0] = this._fromUnits(args[0]);\n      args[1] = this.toSeconds(args[1]); //apply it to the proxies\n\n      this._proxies.forEach(function (signal) {\n        signal[method].apply(signal, args);\n      });\n    };\n  });\n  [\"cancelScheduledValues\", \"cancelAndHoldAtTime\"].forEach(function (method) {\n    var previousMethod = Tone.Signal.prototype[method];\n\n    Tone.Signal.prototype[method] = function () {\n      var args = arguments;\n      previousMethod.apply(this, arguments);\n      args[0] = this.toSeconds(args[0]); //apply it to the proxies\n\n      this._proxies.forEach(function (signal) {\n        signal[method].apply(signal, args);\n      });\n    };\n  });\n  /**\n   *  dispose and disconnect\n   *  @returns {Tone.Signal} this\n   */\n\n  Tone.Signal.prototype.dispose = function () {\n    Tone.Param.prototype.dispose.call(this);\n\n    this._constantSource.disconnect();\n\n    this._constantSource = null;\n    this._proxies = null;\n    return this;\n  };\n\n  return Tone.Signal;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3NpZ25hbC9TaWduYWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3NpZ25hbC9TaWduYWwuanM/OTFhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoW1wiVG9uZS9jb3JlL1RvbmVcIiwgXCJUb25lL3NpZ25hbC9XYXZlU2hhcGVyXCIsIFwiVG9uZS90eXBlL1R5cGVcIiwgXCJUb25lL2NvcmUvUGFyYW1cIixcblx0XCJUb25lL3NoaW0vQ29uc3RhbnRTb3VyY2VOb2RlXCIsIFwiVG9uZS9jb3JlL0dhaW5cIl0sIGZ1bmN0aW9uKFRvbmUpe1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiAgQGNsYXNzICBBIHNpZ25hbCBpcyBhbiBhdWRpby1yYXRlIHZhbHVlLiBUb25lLlNpZ25hbCBpcyBhIGNvcmUgY29tcG9uZW50IG9mIHRoZSBsaWJyYXJ5LlxuXHQgKiAgICAgICAgICBVbmxpa2UgYSBudW1iZXIsIFNpZ25hbHMgY2FuIGJlIHNjaGVkdWxlZCB3aXRoIHNhbXBsZS1sZXZlbCBhY2N1cmFjeS4gVG9uZS5TaWduYWxcblx0ICogICAgICAgICAgaGFzIGFsbCBvZiB0aGUgbWV0aG9kcyBhdmFpbGFibGUgdG8gbmF0aXZlIFdlYiBBdWRpb1xuXHQgKiAgICAgICAgICBbQXVkaW9QYXJhbV0oaHR0cDovL3dlYmF1ZGlvLmdpdGh1Yi5pby93ZWItYXVkaW8tYXBpLyN0aGUtYXVkaW9wYXJhbS1pbnRlcmZhY2UpXG5cdCAqICAgICAgICAgIGFzIHdlbGwgYXMgYWRkaXRpb25hbCBjb252ZW5pZW5jZXMuIFJlYWQgbW9yZSBhYm91dCB3b3JraW5nIHdpdGggc2lnbmFsc1xuXHQgKiAgICAgICAgICBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL1RvbmVqcy9Ub25lLmpzL3dpa2kvU2lnbmFscykuXG5cdCAqXG5cdCAqICBAY29uc3RydWN0b3Jcblx0ICogIEBleHRlbmRzIHtUb25lLlBhcmFtfVxuXHQgKiAgQHBhcmFtIHtOdW1iZXJ8QXVkaW9QYXJhbX0gW3ZhbHVlXSBJbml0aWFsIHZhbHVlIG9mIHRoZSBzaWduYWwuIElmIGFuIEF1ZGlvUGFyYW1cblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgcGFzc2VkIGluLCB0aGF0IHBhcmFtZXRlciB3aWxsIGJlIHdyYXBwZWRcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIGNvbnRyb2xsZWQgYnkgdGhlIFNpZ25hbC5cblx0ICogIEBwYXJhbSB7c3RyaW5nfSBbdW5pdHM9TnVtYmVyXSB1bml0IFRoZSB1bml0cyB0aGUgc2lnbmFsIGlzIGluLlxuXHQgKiAgQGV4YW1wbGVcblx0ICogdmFyIHNpZ25hbCA9IG5ldyBUb25lLlNpZ25hbCgxMCk7XG5cdCAqL1xuXHRUb25lLlNpZ25hbCA9IGZ1bmN0aW9uKCl7XG5cblx0XHR2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXCJ2YWx1ZVwiLCBcInVuaXRzXCJdLCBUb25lLlNpZ25hbCk7XG5cdFx0VG9uZS5QYXJhbS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG5cdFx0LyoqXG5cdFx0KiBXaGVuIGEgc2lnbmFsIGlzIGNvbm5lY3RlZCB0byBhbm90aGVyIHNpZ25hbCBvciBhdWRpbyBwYXJhbSxcblx0XHQqIHRoaXMgc2lnbmFsIGJlY29tZXMgYSBwcm94eSBmb3IgaXRcblx0XHQqIEB0eXBlIHtBcnJheX1cblx0XHQqIEBwcml2YXRlXG5cdFx0Ki9cblx0XHR0aGlzLl9wcm94aWVzID0gW107XG5cblx0XHQvKipcblx0XHQqIEluZGljYXRlcyBpZiB0aGUgY29uc3RhbnQgc291cmNlIHdhcyBzdGFydGVkIG9yIG5vdFxuXHRcdCogQHByaXZhdGVcblx0XHQqIEB0eXBlIHtCb29sZWFufVxuXHRcdCovXG5cdFx0dGhpcy5fc291cmNlU3RhcnRlZCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGNvbnN0YW50IHNvdXJjZSBub2RlIHdoaWNoIGdlbmVyYXRlcyB0aGUgc2lnbmFsXG5cdFx0ICogQHR5cGUge0NvbnN0YW50U291cmNlTm9kZX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2NvbnN0YW50U291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUNvbnN0YW50U291cmNlKCk7XG5cdFx0dGhpcy5fcGFyYW0gPSB0aGlzLl9jb25zdGFudFNvdXJjZS5vZmZzZXQ7XG5cdFx0dGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbm9kZSB3aGVyZSB0aGUgY29uc3RhbnQgc2lnbmFsIHZhbHVlIGlzIHNjYWxlZC5cblx0XHQgKiBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLm91dHB1dCA9IHRoaXMuX2NvbnN0YW50U291cmNlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG5vZGUgd2hlcmUgdGhlIHZhbHVlIGlzIHNldC5cblx0XHQgKiBAdHlwZSB7VG9uZS5QYXJhbX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuaW5wdXQgPSB0aGlzLl9wYXJhbSA9IHRoaXMub3V0cHV0Lm9mZnNldDtcblx0fTtcblxuXHRUb25lLmV4dGVuZChUb25lLlNpZ25hbCwgVG9uZS5QYXJhbSk7XG5cblx0LyoqXG5cdCAqICBUaGUgZGVmYXVsdCB2YWx1ZXNcblx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHQgKiAgQHN0YXRpY1xuXHQgKiAgQGNvbnN0XG5cdCAqL1xuXHRUb25lLlNpZ25hbC5kZWZhdWx0cyA9IHtcblx0XHRcInZhbHVlXCIgOiAwLFxuXHRcdFwidW5pdHNcIiA6IFRvbmUuVHlwZS5EZWZhdWx0LFxuXHRcdFwiY29udmVydFwiIDogdHJ1ZSxcblx0fTtcblxuXHQvKipcblx0ICogIFdoZW4gc2lnbmFscyBjb25uZWN0IHRvIG90aGVyIHNpZ25hbHMgb3IgQXVkaW9QYXJhbXMsXG5cdCAqICB0aGV5IHRha2Ugb3ZlciB0aGUgb3V0cHV0IHZhbHVlIG9mIHRoYXQgc2lnbmFsIG9yIEF1ZGlvUGFyYW0uXG5cdCAqICBGb3IgYWxsIG90aGVyIG5vZGVzLCB0aGUgYmVoYXZpb3IgaXMgdGhlIHNhbWUgYXMgYSBkZWZhdWx0IDxjb2RlPmNvbm5lY3Q8L2NvZGU+LlxuXHQgKlxuXHQgKiAgQG92ZXJyaWRlXG5cdCAqICBAcGFyYW0ge0F1ZGlvUGFyYW18QXVkaW9Ob2RlfFRvbmUuU2lnbmFsfFRvbmV9IG5vZGVcblx0ICogIEBwYXJhbSB7bnVtYmVyfSBbb3V0cHV0TnVtYmVyPTBdIFRoZSBvdXRwdXQgbnVtYmVyIHRvIGNvbm5lY3QgZnJvbS5cblx0ICogIEBwYXJhbSB7bnVtYmVyfSBbaW5wdXROdW1iZXI9MF0gVGhlIGlucHV0IG51bWJlciB0byBjb25uZWN0IHRvLlxuXHQgKiAgQHJldHVybnMge1RvbmUuU2lnbmFsfSB0aGlzXG5cdCAqICBAbWV0aG9kXG5cdCAqL1xuXHRUb25lLlNpZ25hbC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKG5vZGUpe1xuXHRcdC8vdGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gd2hlcmUgdGhpcyBub2RlIHdpbGwgZm9yd2FyZCBhdXRvbWF0aW9uc1xuXHRcdC8vdG8gY29ubmVjdGVkIG5vZGVzIHdpdGhvdXQgYW55IHNpZ25hbCBpZiBwb3NzaWJsZS5cblx0XHRpZiAodGhpcy5faXNQYXJhbShub2RlKSAmJiAhdGhpcy5fc291cmNlU3RhcnRlZCl7XG5cdFx0XHR0aGlzLl9wcm94aWVzLnB1c2gobm9kZSk7XG5cdFx0XHRub2RlLm92ZXJyaWRkZW4gPSB0cnVlO1xuXHRcdFx0dGhpcy5fYXBwbHlBdXRvbWF0aW9ucyhub2RlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VG9uZS5TaWduYWxCYXNlLnByb3RvdHlwZS5jb25uZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRpZiAoIXRoaXMuX3NvdXJjZVN0YXJ0ZWQpe1xuXHRcdFx0XHR0aGlzLl9zb3VyY2VTdGFydGVkID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fY29uc3RhbnRTb3VyY2Uuc3RhcnQoMCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUYWtlcyBhIG5vZGUgYXMgYW4gYXJndW1lbnQgYW5kIHJldHVybnMgaWYgaXQgaXMgYSBQYXJhbSBvciBBdWRpb1BhcmFtXG5cdCAqIEBwYXJhbSAgeyp9IG5vZGUgVGhlIG5vZGUgdG8gdGVzdFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0VG9uZS5TaWduYWwucHJvdG90eXBlLl9pc1BhcmFtID0gZnVuY3Rpb24obm9kZSl7XG5cdFx0cmV0dXJuIChUb25lLlBhcmFtICYmIFRvbmUuUGFyYW0gPT09IG5vZGUuY29uc3RydWN0b3IpIHx8XG5cdFx0XHRcdG5vZGUgaW5zdGFuY2VvZiBBdWRpb1BhcmFtO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNjYXJkIHRoZSBvcHRpbWl6YXRpb24gYW5kIGNvbm5lY3QgYWxsIG9mIHRoZSBwcm94aWVzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLlNpZ25hbC5wcm90b3R5cGUuX2Nvbm5lY3RQcm94aWVzID0gZnVuY3Rpb24oKXtcblx0XHRpZiAoIXRoaXMuX3NvdXJjZVN0YXJ0ZWQpe1xuXHRcdFx0dGhpcy5fc291cmNlU3RhcnRlZCA9IHRydWU7XG5cdFx0XHR0aGlzLl9jb25zdGFudFNvdXJjZS5zdGFydCgwKTtcblx0XHR9XG5cdFx0dGhpcy5fcHJveGllcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3h5KXtcblx0XHRcdFRvbmUuU2lnbmFsQmFzZS5wcm90b3R5cGUuY29ubmVjdC5jYWxsKHRoaXMsIHByb3h5KTtcblx0XHRcdGlmIChwcm94eS5fcHJveGllcyl7XG5cdFx0XHRcdHByb3h5Ll9jb25uZWN0UHJveGllcygpO1xuXHRcdFx0fVxuXHRcdH0uYmluZCh0aGlzKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEludm9rZWQgd2hlbiBhIG5vZGUgaXMgY29ubmVjdGVkIHRvIHRoaXNcblx0ICogQHBhcmFtICB7QXVkaW9Ob2RlfSBmcm9tXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLlNpZ25hbC5wcm90b3R5cGUuX29uQ29ubmVjdCA9IGZ1bmN0aW9uKGZyb20pe1xuXHRcdGlmICghdGhpcy5faXNQYXJhbShmcm9tKSl7XG5cdFx0XHQvL2Nvbm5lY3QgYWxsIHRoZSBwcm94aWVzXG5cdFx0XHR0aGlzLl9jb25uZWN0UHJveGllcygpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQXBwbHkgYWxsIHRoZSBjdXJyZW50IGF1dG9tYXRpb25zIHRvIHRoZSBnaXZlbiBwYXJhbWV0ZXJcblx0ICogQHBhcmFtICB7QXVkaW9QYXJhbX0gcGFyYW1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdFRvbmUuU2lnbmFsLnByb3RvdHlwZS5fYXBwbHlBdXRvbWF0aW9ucyA9IGZ1bmN0aW9uKHBhcmFtKXtcblx0XHR2YXIgbm93ID0gdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lO1xuXHRcdHBhcmFtLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhub3cpO1xuXHRcdHZhciBjdXJyZW50VmFsID0gdGhpcy5nZXRWYWx1ZUF0VGltZShub3cpO1xuXHRcdHBhcmFtLnNldFZhbHVlQXRUaW1lKGN1cnJlbnRWYWwsIG5vdyk7XG5cdFx0dGhpcy5fZXZlbnRzLmZvckVhY2hGcm9tKG5vdywgZnVuY3Rpb24oZXZlbnQpe1xuXHRcdFx0cGFyYW1bZXZlbnQudHlwZV0oZXZlbnQudmFsdWUsIGV2ZW50LnRpbWUsIGV2ZW50LmNvbnN0YW50KTtcblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogRGlzY29ubmVjdCBmcm9tIHRoZSBnaXZlbiBub2RlIG9yIGFsbCBub2RlcyBpZiBubyBwYXJhbSBpcyBnaXZlbi5cblx0ICogQHBhcmFtICB7QXVkaW9Ob2RlfEF1ZGlvUGFyYW19IG5vZGVcblx0ICogQHJldHVybiB7VG9uZS5TaWduYWx9ICAgICAgdGhpc1xuXHQgKi9cblx0VG9uZS5TaWduYWwucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbihub2RlKXtcblx0XHRpZiAodGhpcy5fcHJveGllcy5pbmNsdWRlcyhub2RlKSl7XG5cdFx0XHR2YXIgaW5kZXggPSB0aGlzLl9wcm94aWVzLmluZGV4T2Yobm9kZSk7XG5cdFx0XHR0aGlzLl9wcm94aWVzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fSBlbHNlIGlmICghbm9kZSl7XG5cdFx0XHQvL25vIGFyZ3VtZW50LCBkaXNjb25uZWN0IGV2ZXJ5dGhpbmdcblx0XHRcdHRoaXMuX3Byb3hpZXMgPSBbXTtcblx0XHR9XG5cdFx0cmV0dXJuIFRvbmUuU2lnbmFsQmFzZS5wcm90b3R5cGUuZGlzY29ubmVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIGN1cnJlbnQgc2lnbmFsIHZhbHVlIGF0IHRoZSBnaXZlbiB0aW1lLlxuXHQgKiBAcGFyYW0gIHtUaW1lfSB0aW1lIFdoZW4gdG8gZ2V0IHRoZSBzaWduYWwgdmFsdWVcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKi9cblx0VG9uZS5TaWduYWwucHJvdG90eXBlLmdldFZhbHVlQXRUaW1lID0gZnVuY3Rpb24odGltZSl7XG5cdFx0aWYgKHRoaXMuX3BhcmFtLmdldFZhbHVlQXRUaW1lKXtcblx0XHRcdHJldHVybiB0aGlzLl9wYXJhbS5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFRvbmUuUGFyYW0ucHJvdG90eXBlLmdldFZhbHVlQXRUaW1lLmNhbGwodGhpcywgdGltZSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vd3JhcCBhbGwgb2YgdGhlIGF1dG9tYXRpb24gbWV0aG9kc1xuXHRbXCJzZXRWYWx1ZUF0VGltZVwiLCBcImxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lXCIsIFwiZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZVwiLCBcInNldFRhcmdldEF0VGltZVwiXVxuXHRcdC5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCl7XG5cdFx0XHR2YXIgcHJldmlvdXNNZXRob2QgPSBUb25lLlNpZ25hbC5wcm90b3R5cGVbbWV0aG9kXTtcblx0XHRcdFRvbmUuU2lnbmFsLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cdFx0XHRcdHByZXZpb3VzTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdGFyZ3NbMF0gPSB0aGlzLl9mcm9tVW5pdHMoYXJnc1swXSk7XG5cdFx0XHRcdGFyZ3NbMV0gPSB0aGlzLnRvU2Vjb25kcyhhcmdzWzFdKTtcblx0XHRcdFx0Ly9hcHBseSBpdCB0byB0aGUgcHJveGllc1xuXHRcdFx0XHR0aGlzLl9wcm94aWVzLmZvckVhY2goZnVuY3Rpb24oc2lnbmFsKXtcblx0XHRcdFx0XHRzaWduYWxbbWV0aG9kXS5hcHBseShzaWduYWwsIGFyZ3MpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdFx0fSk7XG5cdFtcImNhbmNlbFNjaGVkdWxlZFZhbHVlc1wiLCBcImNhbmNlbEFuZEhvbGRBdFRpbWVcIl1cblx0XHQuZm9yRWFjaChmdW5jdGlvbihtZXRob2Qpe1xuXHRcdFx0dmFyIHByZXZpb3VzTWV0aG9kID0gVG9uZS5TaWduYWwucHJvdG90eXBlW21ldGhvZF07XG5cdFx0XHRUb25lLlNpZ25hbC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzO1xuXHRcdFx0XHRwcmV2aW91c01ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRhcmdzWzBdID0gdGhpcy50b1NlY29uZHMoYXJnc1swXSk7XG5cdFx0XHRcdC8vYXBwbHkgaXQgdG8gdGhlIHByb3hpZXNcblx0XHRcdFx0dGhpcy5fcHJveGllcy5mb3JFYWNoKGZ1bmN0aW9uKHNpZ25hbCl7XG5cdFx0XHRcdFx0c2lnbmFsW21ldGhvZF0uYXBwbHkoc2lnbmFsLCBhcmdzKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXHRcdH0pO1xuXG5cdC8qKlxuXHQgKiAgZGlzcG9zZSBhbmQgZGlzY29ubmVjdFxuXHQgKiAgQHJldHVybnMge1RvbmUuU2lnbmFsfSB0aGlzXG5cdCAqL1xuXHRUb25lLlNpZ25hbC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCl7XG5cdFx0VG9uZS5QYXJhbS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuX2NvbnN0YW50U291cmNlLmRpc2Nvbm5lY3QoKTtcblx0XHR0aGlzLl9jb25zdGFudFNvdXJjZSA9IG51bGw7XG5cdFx0dGhpcy5fcHJveGllcyA9IG51bGw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0cmV0dXJuIFRvbmUuU2lnbmFsO1xufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBR0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7O0FBTUE7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7Ozs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBRUE7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/signal/Signal.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/signal/SignalBase.js":
/*!*****************************************************!*\
  !*** ./node_modules/tone/Tone/signal/SignalBase.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/core/AudioNode */ \"./node_modules/tone/Tone/core/AudioNode.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  \"use strict\";\n  /**\n   *  @class  Base class for all Signals. Used Internally.\n   *\n   *  @constructor\n   *  @extends {Tone}\n   */\n\n  Tone.SignalBase = function () {\n    Tone.AudioNode.call(this);\n  };\n\n  Tone.extend(Tone.SignalBase, Tone.AudioNode);\n  /**\n   *  When signals connect to other signals or AudioParams,\n   *  they take over the output value of that signal or AudioParam.\n   *  For all other nodes, the behavior is the same as a default <code>connect</code>.\n   *\n   *  @override\n   *  @param {AudioParam|AudioNode|Tone.Signal|Tone} node\n   *  @param {number} [outputNumber=0] The output number to connect from.\n   *  @param {number} [inputNumber=0] The input number to connect to.\n   *  @returns {Tone.SignalBase} this\n   */\n\n  Tone.SignalBase.prototype.connect = function (node, outputNumber, inputNumber) {\n    //zero it out so that the signal can have full control\n    if (Tone.Signal && Tone.Signal === node.constructor || Tone.Param && Tone.Param === node.constructor) {\n      //cancel changes\n      node._param.cancelScheduledValues(0); //reset the value\n\n\n      node._param.value = 0; //mark the value as overridden\n\n      node.overridden = true;\n    } else if (node instanceof AudioParam) {\n      node.cancelScheduledValues(0);\n      node.value = 0;\n    }\n\n    Tone.AudioNode.prototype.connect.call(this, node, outputNumber, inputNumber);\n    return this;\n  };\n\n  return Tone.SignalBase;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3NpZ25hbC9TaWduYWxCYXNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RvbmUvVG9uZS9zaWduYWwvU2lnbmFsQmFzZS5qcz8yNjgzIl0sInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbXCJUb25lL2NvcmUvVG9uZVwiLCBcIlRvbmUvY29yZS9BdWRpb05vZGVcIl0sIGZ1bmN0aW9uKFRvbmUpe1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiAgQGNsYXNzICBCYXNlIGNsYXNzIGZvciBhbGwgU2lnbmFscy4gVXNlZCBJbnRlcm5hbGx5LlxuXHQgKlxuXHQgKiAgQGNvbnN0cnVjdG9yXG5cdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0ICovXG5cdFRvbmUuU2lnbmFsQmFzZSA9IGZ1bmN0aW9uKCl7XG5cdFx0VG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0fTtcblxuXHRUb25lLmV4dGVuZChUb25lLlNpZ25hbEJhc2UsIFRvbmUuQXVkaW9Ob2RlKTtcblxuXHQvKipcblx0ICogIFdoZW4gc2lnbmFscyBjb25uZWN0IHRvIG90aGVyIHNpZ25hbHMgb3IgQXVkaW9QYXJhbXMsXG5cdCAqICB0aGV5IHRha2Ugb3ZlciB0aGUgb3V0cHV0IHZhbHVlIG9mIHRoYXQgc2lnbmFsIG9yIEF1ZGlvUGFyYW0uXG5cdCAqICBGb3IgYWxsIG90aGVyIG5vZGVzLCB0aGUgYmVoYXZpb3IgaXMgdGhlIHNhbWUgYXMgYSBkZWZhdWx0IDxjb2RlPmNvbm5lY3Q8L2NvZGU+LlxuXHQgKlxuXHQgKiAgQG92ZXJyaWRlXG5cdCAqICBAcGFyYW0ge0F1ZGlvUGFyYW18QXVkaW9Ob2RlfFRvbmUuU2lnbmFsfFRvbmV9IG5vZGVcblx0ICogIEBwYXJhbSB7bnVtYmVyfSBbb3V0cHV0TnVtYmVyPTBdIFRoZSBvdXRwdXQgbnVtYmVyIHRvIGNvbm5lY3QgZnJvbS5cblx0ICogIEBwYXJhbSB7bnVtYmVyfSBbaW5wdXROdW1iZXI9MF0gVGhlIGlucHV0IG51bWJlciB0byBjb25uZWN0IHRvLlxuXHQgKiAgQHJldHVybnMge1RvbmUuU2lnbmFsQmFzZX0gdGhpc1xuXHQgKi9cblx0VG9uZS5TaWduYWxCYXNlLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24obm9kZSwgb3V0cHV0TnVtYmVyLCBpbnB1dE51bWJlcil7XG5cdFx0Ly96ZXJvIGl0IG91dCBzbyB0aGF0IHRoZSBzaWduYWwgY2FuIGhhdmUgZnVsbCBjb250cm9sXG5cdFx0aWYgKChUb25lLlNpZ25hbCAmJiBUb25lLlNpZ25hbCA9PT0gbm9kZS5jb25zdHJ1Y3RvcikgfHxcblx0XHRcdFx0KFRvbmUuUGFyYW0gJiYgVG9uZS5QYXJhbSA9PT0gbm9kZS5jb25zdHJ1Y3Rvcikpe1xuXHRcdFx0Ly9jYW5jZWwgY2hhbmdlc1xuXHRcdFx0bm9kZS5fcGFyYW0uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKDApO1xuXHRcdFx0Ly9yZXNldCB0aGUgdmFsdWVcblx0XHRcdG5vZGUuX3BhcmFtLnZhbHVlID0gMDtcblx0XHRcdC8vbWFyayB0aGUgdmFsdWUgYXMgb3ZlcnJpZGRlblxuXHRcdFx0bm9kZS5vdmVycmlkZGVuID0gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBdWRpb1BhcmFtKXtcblx0XHRcdG5vZGUuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKDApO1xuXHRcdFx0bm9kZS52YWx1ZSA9IDA7XG5cdFx0fVxuXHRcdFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5jb25uZWN0LmNhbGwodGhpcywgbm9kZSwgb3V0cHV0TnVtYmVyLCBpbnB1dE51bWJlcik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0cmV0dXJuIFRvbmUuU2lnbmFsQmFzZTtcbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUVBO0FBRUE7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/signal/SignalBase.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/signal/TickSignal.js":
/*!*****************************************************!*\
  !*** ./node_modules/tone/Tone/signal/TickSignal.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/signal/Signal */ \"./node_modules/tone/Tone/signal/Signal.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  /**\n   * @class Tone.TickSignal extends Tone.Signal, but adds the capability\n   *        to calculate the number of elapsed ticks. exponential and target curves\n   *        are approximated with multiple linear ramps.\n   *\n   *        Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos, for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)\n   *        describing integrating timing functions for tempo calculations.\n   *\n   * @param {Number} value The initial value of the signal\n   * @extends {Tone.Signal}\n   */\n  Tone.TickSignal = function (value) {\n    value = Tone.defaultArg(value, 1);\n    Tone.Signal.call(this, {\n      \"units\": Tone.Type.Ticks,\n      \"value\": value\n    }); //extend the memory\n\n    this._events.memory = Infinity; //clear the clock from the beginning\n\n    this.cancelScheduledValues(0); //set an initial event\n\n    this._events.add({\n      \"type\": Tone.Param.AutomationType.SetValue,\n      \"time\": 0,\n      \"value\": value\n    });\n  };\n\n  Tone.extend(Tone.TickSignal, Tone.Signal);\n  /**\n   * Wraps Tone.Signal methods so that they also\n   * record the ticks.\n   * @param  {Function} method\n   * @return {Function}\n   * @private\n   */\n\n  function _wrapScheduleMethods(method) {\n    return function (value, time) {\n      time = this.toSeconds(time);\n      method.apply(this, arguments);\n\n      var event = this._events.get(time);\n\n      var previousEvent = this._events.previousEvent(event);\n\n      var ticksUntilTime = this._getTicksUntilEvent(previousEvent, time);\n\n      event.ticks = Math.max(ticksUntilTime, 0);\n      return this;\n    };\n  }\n\n  Tone.TickSignal.prototype.setValueAtTime = _wrapScheduleMethods(Tone.Signal.prototype.setValueAtTime);\n  Tone.TickSignal.prototype.linearRampToValueAtTime = _wrapScheduleMethods(Tone.Signal.prototype.linearRampToValueAtTime);\n  /**\n   *  Start exponentially approaching the target value at the given time with\n   *  a rate having the given time constant.\n   *  @param {number} value\n   *  @param {Time} startTime\n   *  @param {number} timeConstant\n   *  @returns {Tone.TickSignal} this\n   */\n\n  Tone.TickSignal.prototype.setTargetAtTime = function (value, time, constant) {\n    //aproximate it with multiple linear ramps\n    time = this.toSeconds(time);\n    this.setRampPoint(time);\n    value = this._fromUnits(value); //start from previously scheduled value\n\n    var prevEvent = this._events.get(time);\n\n    var segments = Math.round(Math.max(1 / constant, 1));\n\n    for (var i = 0; i <= segments; i++) {\n      var segTime = constant * i + time;\n\n      var rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, value, constant, segTime);\n\n      this.linearRampToValueAtTime(this._toUnits(rampVal), segTime);\n    }\n\n    return this;\n  };\n  /**\n   *  Schedules an exponential continuous change in parameter value from\n   *  the previous scheduled parameter value to the given value.\n   *  @param  {number} value\n   *  @param  {Time} endTime\n   *  @returns {Tone.TickSignal} this\n   */\n\n\n  Tone.TickSignal.prototype.exponentialRampToValueAtTime = function (value, time) {\n    //aproximate it with multiple linear ramps\n    time = this.toSeconds(time);\n    value = this._fromUnits(value); //start from previously scheduled value\n\n    var prevEvent = this._events.get(time);\n\n    if (prevEvent === null) {\n      prevEvent = {\n        \"value\": this._initialValue,\n        \"time\": 0\n      };\n    } //approx 10 segments per second\n\n\n    var segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n    var segmentDur = (time - prevEvent.time) / segments;\n\n    for (var i = 0; i <= segments; i++) {\n      var segTime = segmentDur * i + prevEvent.time;\n\n      var rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, value, segTime);\n\n      this.linearRampToValueAtTime(this._toUnits(rampVal), segTime);\n    }\n\n    return this;\n  };\n  /**\n   * Returns the tick value at the time. Takes into account\n   * any automation curves scheduled on the signal.\n   * @private\n   * @param  {Time} time The time to get the tick count at\n   * @return {Ticks}      The number of ticks which have elapsed at the time\n   *                          given any automations.\n   */\n\n\n  Tone.TickSignal.prototype._getTicksUntilEvent = function (event, time) {\n    if (event === null) {\n      event = {\n        \"ticks\": 0,\n        \"time\": 0\n      };\n    } else if (Tone.isUndef(event.ticks)) {\n      var previousEvent = this._events.previousEvent(event);\n\n      event.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n    }\n\n    var val0 = this.getValueAtTime(event.time);\n    var val1 = this.getValueAtTime(time); //if it's right on the line, take the previous value\n\n    if (this._events.get(time).time === time && this._events.get(time).type === Tone.Param.AutomationType.SetValue) {\n      val1 = this.getValueAtTime(time - this.sampleTime);\n    }\n\n    return 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n  };\n  /**\n   * Returns the tick value at the time. Takes into account\n   * any automation curves scheduled on the signal.\n   * @param  {Time} time The time to get the tick count at\n   * @return {Ticks}      The number of ticks which have elapsed at the time\n   *                          given any automations.\n   */\n\n\n  Tone.TickSignal.prototype.getTicksAtTime = function (time) {\n    time = this.toSeconds(time);\n\n    var event = this._events.get(time);\n\n    return Math.max(this._getTicksUntilEvent(event, time), 0);\n  };\n  /**\n   * Return the elapsed time of the number of ticks from the given time\n   * @param {Ticks} ticks The number of ticks to calculate\n   * @param  {Time} time The time to get the next tick from\n   * @return {Seconds} The duration of the number of ticks from the given time in seconds\n   */\n\n\n  Tone.TickSignal.prototype.getDurationOfTicks = function (ticks, time) {\n    time = this.toSeconds(time);\n    var currentTick = this.getTicksAtTime(time);\n    return this.getTimeOfTick(currentTick + ticks) - time;\n  };\n  /**\n   * Given a tick, returns the time that tick occurs at.\n   * @param  {Ticks} tick\n   * @return {Time}      The time that the tick occurs.\n   */\n\n\n  Tone.TickSignal.prototype.getTimeOfTick = function (tick) {\n    var before = this._events.get(tick, \"ticks\");\n\n    var after = this._events.getAfter(tick, \"ticks\");\n\n    if (before && before.ticks === tick) {\n      return before.time;\n    } else if (before && after && after.type === Tone.Param.AutomationType.Linear && before.value !== after.value) {\n      var val0 = this.getValueAtTime(before.time);\n      var val1 = this.getValueAtTime(after.time);\n      var delta = (val1 - val0) / (after.time - before.time);\n      var k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n      var sol1 = (-val0 + k) / delta;\n      var sol2 = (-val0 - k) / delta;\n      return (sol1 > 0 ? sol1 : sol2) + before.time;\n    } else if (before) {\n      if (before.value === 0) {\n        return Infinity;\n      } else {\n        return before.time + (tick - before.ticks) / before.value;\n      }\n    } else {\n      return tick / this._initialValue;\n    }\n  };\n  /**\n   * Convert some number of ticks their the duration in seconds accounting\n   * for any automation curves starting at the given time.\n   * @param  {Ticks} ticks The number of ticks to convert to seconds.\n   * @param  {Time} [when=now]  When along the automation timeline to convert the ticks.\n   * @return {Tone.Time}       The duration in seconds of the ticks.\n   */\n\n\n  Tone.TickSignal.prototype.ticksToTime = function (ticks, when) {\n    when = this.toSeconds(when);\n    return new Tone.Time(this.getDurationOfTicks(ticks, when));\n  };\n  /**\n   * The inverse of [ticksToTime](#tickstotime). Convert a duration in\n   * seconds to the corresponding number of ticks accounting for any\n   * automation curves starting at the given time.\n   * @param  {Time} duration The time interval to convert to ticks.\n   * @param  {Time} [when=now]     When along the automation timeline to convert the ticks.\n   * @return {Tone.Ticks}          The duration in ticks.\n   */\n\n\n  Tone.TickSignal.prototype.timeToTicks = function (duration, when) {\n    when = this.toSeconds(when);\n    duration = this.toSeconds(duration);\n    var startTicks = this.getTicksAtTime(when);\n    var endTicks = this.getTicksAtTime(when + duration);\n    return new Tone.Ticks(endTicks - startTicks);\n  };\n\n  return Tone.TickSignal;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3NpZ25hbC9UaWNrU2lnbmFsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RvbmUvVG9uZS9zaWduYWwvVGlja1NpZ25hbC5qcz9jODJkIl0sInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbXCJUb25lL2NvcmUvVG9uZVwiLCBcIlRvbmUvc2lnbmFsL1NpZ25hbFwiXSwgZnVuY3Rpb24oVG9uZSl7XG5cblx0LyoqXG5cdCAqIEBjbGFzcyBUb25lLlRpY2tTaWduYWwgZXh0ZW5kcyBUb25lLlNpZ25hbCwgYnV0IGFkZHMgdGhlIGNhcGFiaWxpdHlcblx0ICogICAgICAgIHRvIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIGVsYXBzZWQgdGlja3MuIGV4cG9uZW50aWFsIGFuZCB0YXJnZXQgY3VydmVzXG5cdCAqICAgICAgICBhcmUgYXBwcm94aW1hdGVkIHdpdGggbXVsdGlwbGUgbGluZWFyIHJhbXBzLlxuXHQgKlxuXHQgKiAgICAgICAgVGhhbmsgeW91IEJydW5vIERpYXMsIEguIFNvZmlhIFBpbnRvLCBhbmQgRGF2aWQgTS4gTWF0b3MsIGZvciB5b3VyIFtXQUMgcGFwZXJdKGh0dHBzOi8vc21hcnRlY2guZ2F0ZWNoLmVkdS9iaXRzdHJlYW0vaGFuZGxlLzE4NTMvNTQ1ODgvV0FDMjAxNi00OS5wZGYpXG5cdCAqICAgICAgICBkZXNjcmliaW5nIGludGVncmF0aW5nIHRpbWluZyBmdW5jdGlvbnMgZm9yIHRlbXBvIGNhbGN1bGF0aW9ucy5cblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBzaWduYWxcblx0ICogQGV4dGVuZHMge1RvbmUuU2lnbmFsfVxuXHQgKi9cblx0VG9uZS5UaWNrU2lnbmFsID0gZnVuY3Rpb24odmFsdWUpe1xuXG5cdFx0dmFsdWUgPSBUb25lLmRlZmF1bHRBcmcodmFsdWUsIDEpO1xuXG5cdFx0VG9uZS5TaWduYWwuY2FsbCh0aGlzLCB7XG5cdFx0XHRcInVuaXRzXCIgOiBUb25lLlR5cGUuVGlja3MsXG5cdFx0XHRcInZhbHVlXCIgOiB2YWx1ZVxuXHRcdH0pO1xuXG5cdFx0Ly9leHRlbmQgdGhlIG1lbW9yeVxuXHRcdHRoaXMuX2V2ZW50cy5tZW1vcnkgPSBJbmZpbml0eTtcblxuXHRcdC8vY2xlYXIgdGhlIGNsb2NrIGZyb20gdGhlIGJlZ2lubmluZ1xuXHRcdHRoaXMuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKDApO1xuXHRcdC8vc2V0IGFuIGluaXRpYWwgZXZlbnRcblx0XHR0aGlzLl9ldmVudHMuYWRkKHtcblx0XHRcdFwidHlwZVwiIDogVG9uZS5QYXJhbS5BdXRvbWF0aW9uVHlwZS5TZXRWYWx1ZSxcblx0XHRcdFwidGltZVwiIDogMCxcblx0XHRcdFwidmFsdWVcIiA6IHZhbHVlXG5cdFx0fSk7XG5cdH07XG5cblx0VG9uZS5leHRlbmQoVG9uZS5UaWNrU2lnbmFsLCBUb25lLlNpZ25hbCk7XG5cdFxuXHQvKipcblx0ICogV3JhcHMgVG9uZS5TaWduYWwgbWV0aG9kcyBzbyB0aGF0IHRoZXkgYWxzb1xuXHQgKiByZWNvcmQgdGhlIHRpY2tzLlxuXHQgKiBAcGFyYW0gIHtGdW5jdGlvbn0gbWV0aG9kXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gX3dyYXBTY2hlZHVsZU1ldGhvZHMobWV0aG9kKXtcblx0XHRyZXR1cm4gZnVuY3Rpb24odmFsdWUsIHRpbWUpe1xuXHRcdFx0dGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHRcdFx0bWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR2YXIgZXZlbnQgPSB0aGlzLl9ldmVudHMuZ2V0KHRpbWUpO1xuXHRcdFx0dmFyIHByZXZpb3VzRXZlbnQgPSB0aGlzLl9ldmVudHMucHJldmlvdXNFdmVudChldmVudCk7XG5cdFx0XHR2YXIgdGlja3NVbnRpbFRpbWUgPSB0aGlzLl9nZXRUaWNrc1VudGlsRXZlbnQocHJldmlvdXNFdmVudCwgdGltZSk7XG5cdFx0XHRldmVudC50aWNrcyA9IE1hdGgubWF4KHRpY2tzVW50aWxUaW1lLCAwKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH1cblxuXHRUb25lLlRpY2tTaWduYWwucHJvdG90eXBlLnNldFZhbHVlQXRUaW1lID0gX3dyYXBTY2hlZHVsZU1ldGhvZHMoVG9uZS5TaWduYWwucHJvdG90eXBlLnNldFZhbHVlQXRUaW1lKTtcblx0VG9uZS5UaWNrU2lnbmFsLnByb3RvdHlwZS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSA9IF93cmFwU2NoZWR1bGVNZXRob2RzKFRvbmUuU2lnbmFsLnByb3RvdHlwZS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSk7XG5cblx0LyoqXG5cdCAqICBTdGFydCBleHBvbmVudGlhbGx5IGFwcHJvYWNoaW5nIHRoZSB0YXJnZXQgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWUgd2l0aFxuXHQgKiAgYSByYXRlIGhhdmluZyB0aGUgZ2l2ZW4gdGltZSBjb25zdGFudC5cblx0ICogIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuXHQgKiAgQHBhcmFtIHtUaW1lfSBzdGFydFRpbWVcblx0ICogIEBwYXJhbSB7bnVtYmVyfSB0aW1lQ29uc3RhbnRcblx0ICogIEByZXR1cm5zIHtUb25lLlRpY2tTaWduYWx9IHRoaXNcblx0ICovXG5cdFRvbmUuVGlja1NpZ25hbC5wcm90b3R5cGUuc2V0VGFyZ2V0QXRUaW1lID0gZnVuY3Rpb24odmFsdWUsIHRpbWUsIGNvbnN0YW50KXtcblx0XHQvL2Fwcm94aW1hdGUgaXQgd2l0aCBtdWx0aXBsZSBsaW5lYXIgcmFtcHNcblx0XHR0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdFx0dGhpcy5zZXRSYW1wUG9pbnQodGltZSk7XG5cdFx0dmFsdWUgPSB0aGlzLl9mcm9tVW5pdHModmFsdWUpO1xuXG5cdFx0Ly9zdGFydCBmcm9tIHByZXZpb3VzbHkgc2NoZWR1bGVkIHZhbHVlXG5cdFx0dmFyIHByZXZFdmVudCA9IHRoaXMuX2V2ZW50cy5nZXQodGltZSk7XG5cdFx0dmFyIHNlZ21lbnRzID0gTWF0aC5yb3VuZChNYXRoLm1heCgxIC8gY29uc3RhbnQsIDEpKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSBzZWdtZW50czsgaSsrKXtcblx0XHRcdHZhciBzZWdUaW1lID0gY29uc3RhbnQgKiBpICsgdGltZTtcblx0XHRcdHZhciByYW1wVmFsID0gdGhpcy5fZXhwb25lbnRpYWxBcHByb2FjaChwcmV2RXZlbnQudGltZSwgcHJldkV2ZW50LnZhbHVlLCB2YWx1ZSwgY29uc3RhbnQsIHNlZ1RpbWUpO1xuXHRcdFx0dGhpcy5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh0aGlzLl90b1VuaXRzKHJhbXBWYWwpLCBzZWdUaW1lKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqICBTY2hlZHVsZXMgYW4gZXhwb25lbnRpYWwgY29udGludW91cyBjaGFuZ2UgaW4gcGFyYW1ldGVyIHZhbHVlIGZyb21cblx0ICogIHRoZSBwcmV2aW91cyBzY2hlZHVsZWQgcGFyYW1ldGVyIHZhbHVlIHRvIHRoZSBnaXZlbiB2YWx1ZS5cblx0ICogIEBwYXJhbSAge251bWJlcn0gdmFsdWVcblx0ICogIEBwYXJhbSAge1RpbWV9IGVuZFRpbWVcblx0ICogIEByZXR1cm5zIHtUb25lLlRpY2tTaWduYWx9IHRoaXNcblx0ICovXG5cdFRvbmUuVGlja1NpZ25hbC5wcm90b3R5cGUuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSA9IGZ1bmN0aW9uKHZhbHVlLCB0aW1lKXtcblx0XHQvL2Fwcm94aW1hdGUgaXQgd2l0aCBtdWx0aXBsZSBsaW5lYXIgcmFtcHNcblx0XHR0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdFx0dmFsdWUgPSB0aGlzLl9mcm9tVW5pdHModmFsdWUpO1xuXG5cdFx0Ly9zdGFydCBmcm9tIHByZXZpb3VzbHkgc2NoZWR1bGVkIHZhbHVlXG5cdFx0dmFyIHByZXZFdmVudCA9IHRoaXMuX2V2ZW50cy5nZXQodGltZSk7XG5cdFx0aWYgKHByZXZFdmVudCA9PT0gbnVsbCl7XG5cdFx0XHRwcmV2RXZlbnQgPSB7XG5cdFx0XHRcdFwidmFsdWVcIiA6IHRoaXMuX2luaXRpYWxWYWx1ZSxcblx0XHRcdFx0XCJ0aW1lXCIgOiAwXG5cdFx0XHR9O1xuXHRcdH1cblx0XHQvL2FwcHJveCAxMCBzZWdtZW50cyBwZXIgc2Vjb25kXG5cdFx0dmFyIHNlZ21lbnRzID0gTWF0aC5yb3VuZChNYXRoLm1heCgodGltZSAtIHByZXZFdmVudC50aW1lKSoxMCwgMSkpO1xuXHRcdHZhciBzZWdtZW50RHVyID0gKCh0aW1lIC0gcHJldkV2ZW50LnRpbWUpL3NlZ21lbnRzKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSBzZWdtZW50czsgaSsrKXtcblx0XHRcdHZhciBzZWdUaW1lID0gc2VnbWVudER1ciAqIGkgKyBwcmV2RXZlbnQudGltZTtcblx0XHRcdHZhciByYW1wVmFsID0gdGhpcy5fZXhwb25lbnRpYWxJbnRlcnBvbGF0ZShwcmV2RXZlbnQudGltZSwgcHJldkV2ZW50LnZhbHVlLCB0aW1lLCB2YWx1ZSwgc2VnVGltZSk7XG5cdFx0XHR0aGlzLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuX3RvVW5pdHMocmFtcFZhbCksIHNlZ1RpbWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdGljayB2YWx1ZSBhdCB0aGUgdGltZS4gVGFrZXMgaW50byBhY2NvdW50XG5cdCAqIGFueSBhdXRvbWF0aW9uIGN1cnZlcyBzY2hlZHVsZWQgb24gdGhlIHNpZ25hbC5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtICB7VGltZX0gdGltZSBUaGUgdGltZSB0byBnZXQgdGhlIHRpY2sgY291bnQgYXRcblx0ICogQHJldHVybiB7VGlja3N9ICAgICAgVGhlIG51bWJlciBvZiB0aWNrcyB3aGljaCBoYXZlIGVsYXBzZWQgYXQgdGhlIHRpbWVcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIGdpdmVuIGFueSBhdXRvbWF0aW9ucy5cblx0ICovXG5cdFRvbmUuVGlja1NpZ25hbC5wcm90b3R5cGUuX2dldFRpY2tzVW50aWxFdmVudCA9IGZ1bmN0aW9uKGV2ZW50LCB0aW1lKXtcblx0XHRpZiAoZXZlbnQgPT09IG51bGwpe1xuXHRcdFx0ZXZlbnQgPSB7XG5cdFx0XHRcdFwidGlja3NcIiA6IDAsXG5cdFx0XHRcdFwidGltZVwiIDogMFxuXHRcdFx0fTtcblx0XHR9IGVsc2UgaWYgKFRvbmUuaXNVbmRlZihldmVudC50aWNrcykpe1xuXHRcdFx0dmFyIHByZXZpb3VzRXZlbnQgPSB0aGlzLl9ldmVudHMucHJldmlvdXNFdmVudChldmVudCk7XG5cdFx0XHRldmVudC50aWNrcyA9IHRoaXMuX2dldFRpY2tzVW50aWxFdmVudChwcmV2aW91c0V2ZW50LCBldmVudC50aW1lKTtcblx0XHR9XG5cdFx0dmFyIHZhbDAgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGV2ZW50LnRpbWUpO1xuXHRcdHZhciB2YWwxID0gdGhpcy5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcblx0XHQvL2lmIGl0J3MgcmlnaHQgb24gdGhlIGxpbmUsIHRha2UgdGhlIHByZXZpb3VzIHZhbHVlXG5cdFx0aWYgKHRoaXMuX2V2ZW50cy5nZXQodGltZSkudGltZSA9PT0gdGltZSAmJiB0aGlzLl9ldmVudHMuZ2V0KHRpbWUpLnR5cGUgPT09IFRvbmUuUGFyYW0uQXV0b21hdGlvblR5cGUuU2V0VmFsdWUpe1xuXHRcdFx0dmFsMSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUodGltZSAtIHRoaXMuc2FtcGxlVGltZSk7XG5cdFx0fVxuXHRcdHJldHVybiAwLjUgKiAodGltZSAtIGV2ZW50LnRpbWUpICogKHZhbDAgKyB2YWwxKSArIGV2ZW50LnRpY2tzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0aWNrIHZhbHVlIGF0IHRoZSB0aW1lLiBUYWtlcyBpbnRvIGFjY291bnRcblx0ICogYW55IGF1dG9tYXRpb24gY3VydmVzIHNjaGVkdWxlZCBvbiB0aGUgc2lnbmFsLlxuXHQgKiBAcGFyYW0gIHtUaW1lfSB0aW1lIFRoZSB0aW1lIHRvIGdldCB0aGUgdGljayBjb3VudCBhdFxuXHQgKiBAcmV0dXJuIHtUaWNrc30gICAgICBUaGUgbnVtYmVyIG9mIHRpY2tzIHdoaWNoIGhhdmUgZWxhcHNlZCBhdCB0aGUgdGltZVxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2l2ZW4gYW55IGF1dG9tYXRpb25zLlxuXHQgKi9cblx0VG9uZS5UaWNrU2lnbmFsLnByb3RvdHlwZS5nZXRUaWNrc0F0VGltZSA9IGZ1bmN0aW9uKHRpbWUpe1xuXHRcdHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0XHR2YXIgZXZlbnQgPSB0aGlzLl9ldmVudHMuZ2V0KHRpbWUpO1xuXHRcdHJldHVybiBNYXRoLm1heCh0aGlzLl9nZXRUaWNrc1VudGlsRXZlbnQoZXZlbnQsIHRpbWUpLCAwKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBlbGFwc2VkIHRpbWUgb2YgdGhlIG51bWJlciBvZiB0aWNrcyBmcm9tIHRoZSBnaXZlbiB0aW1lXG5cdCAqIEBwYXJhbSB7VGlja3N9IHRpY2tzIFRoZSBudW1iZXIgb2YgdGlja3MgdG8gY2FsY3VsYXRlXG5cdCAqIEBwYXJhbSAge1RpbWV9IHRpbWUgVGhlIHRpbWUgdG8gZ2V0IHRoZSBuZXh0IHRpY2sgZnJvbVxuXHQgKiBAcmV0dXJuIHtTZWNvbmRzfSBUaGUgZHVyYXRpb24gb2YgdGhlIG51bWJlciBvZiB0aWNrcyBmcm9tIHRoZSBnaXZlbiB0aW1lIGluIHNlY29uZHNcblx0ICovXG5cdFRvbmUuVGlja1NpZ25hbC5wcm90b3R5cGUuZ2V0RHVyYXRpb25PZlRpY2tzID0gZnVuY3Rpb24odGlja3MsIHRpbWUpe1xuXHRcdHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0XHR2YXIgY3VycmVudFRpY2sgPSB0aGlzLmdldFRpY2tzQXRUaW1lKHRpbWUpO1xuXHRcdHJldHVybiB0aGlzLmdldFRpbWVPZlRpY2soY3VycmVudFRpY2sgKyB0aWNrcykgLSB0aW1lO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHaXZlbiBhIHRpY2ssIHJldHVybnMgdGhlIHRpbWUgdGhhdCB0aWNrIG9jY3VycyBhdC5cblx0ICogQHBhcmFtICB7VGlja3N9IHRpY2tcblx0ICogQHJldHVybiB7VGltZX0gICAgICBUaGUgdGltZSB0aGF0IHRoZSB0aWNrIG9jY3Vycy5cblx0ICovXG5cdFRvbmUuVGlja1NpZ25hbC5wcm90b3R5cGUuZ2V0VGltZU9mVGljayA9IGZ1bmN0aW9uKHRpY2spe1xuXHRcdHZhciBiZWZvcmUgPSB0aGlzLl9ldmVudHMuZ2V0KHRpY2ssIFwidGlja3NcIik7XG5cdFx0dmFyIGFmdGVyID0gdGhpcy5fZXZlbnRzLmdldEFmdGVyKHRpY2ssIFwidGlja3NcIik7XG5cdFx0aWYgKGJlZm9yZSAmJiBiZWZvcmUudGlja3MgPT09IHRpY2spe1xuXHRcdFx0cmV0dXJuIGJlZm9yZS50aW1lO1xuXHRcdH0gZWxzZSBpZiAoYmVmb3JlICYmIGFmdGVyICYmXG5cdFx0XHRhZnRlci50eXBlID09PSBUb25lLlBhcmFtLkF1dG9tYXRpb25UeXBlLkxpbmVhciAmJlxuXHRcdFx0YmVmb3JlLnZhbHVlICE9PSBhZnRlci52YWx1ZSl7XG5cdFx0XHR2YXIgdmFsMCA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoYmVmb3JlLnRpbWUpO1xuXHRcdFx0dmFyIHZhbDEgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGFmdGVyLnRpbWUpO1xuXHRcdFx0dmFyIGRlbHRhID0gKHZhbDEgLSB2YWwwKSAvIChhZnRlci50aW1lIC0gYmVmb3JlLnRpbWUpO1xuXHRcdFx0dmFyIGsgPSBNYXRoLnNxcnQoTWF0aC5wb3codmFsMCwgMikgLSAyICogZGVsdGEgKiAoYmVmb3JlLnRpY2tzIC0gdGljaykpO1xuXHRcdFx0dmFyIHNvbDEgPSAoLXZhbDAgKyBrKSAvIGRlbHRhO1xuXHRcdFx0dmFyIHNvbDIgPSAoLXZhbDAgLSBrKSAvIGRlbHRhO1xuXHRcdFx0cmV0dXJuIChzb2wxID4gMCA/IHNvbDEgOiBzb2wyKSArIGJlZm9yZS50aW1lO1xuXHRcdH0gZWxzZSBpZiAoYmVmb3JlKXtcblx0XHRcdGlmIChiZWZvcmUudmFsdWUgPT09IDApe1xuXHRcdFx0XHRyZXR1cm4gSW5maW5pdHk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gYmVmb3JlLnRpbWUgKyAodGljayAtIGJlZm9yZS50aWNrcykgLyBiZWZvcmUudmFsdWU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aWNrIC8gdGhpcy5faW5pdGlhbFZhbHVlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ29udmVydCBzb21lIG51bWJlciBvZiB0aWNrcyB0aGVpciB0aGUgZHVyYXRpb24gaW4gc2Vjb25kcyBhY2NvdW50aW5nXG5cdCAqIGZvciBhbnkgYXV0b21hdGlvbiBjdXJ2ZXMgc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHRpbWUuXG5cdCAqIEBwYXJhbSAge1RpY2tzfSB0aWNrcyBUaGUgbnVtYmVyIG9mIHRpY2tzIHRvIGNvbnZlcnQgdG8gc2Vjb25kcy5cblx0ICogQHBhcmFtICB7VGltZX0gW3doZW49bm93XSAgV2hlbiBhbG9uZyB0aGUgYXV0b21hdGlvbiB0aW1lbGluZSB0byBjb252ZXJ0IHRoZSB0aWNrcy5cblx0ICogQHJldHVybiB7VG9uZS5UaW1lfSAgICAgICBUaGUgZHVyYXRpb24gaW4gc2Vjb25kcyBvZiB0aGUgdGlja3MuXG5cdCAqL1xuXHRUb25lLlRpY2tTaWduYWwucHJvdG90eXBlLnRpY2tzVG9UaW1lID0gZnVuY3Rpb24odGlja3MsIHdoZW4pe1xuXHRcdHdoZW4gPSB0aGlzLnRvU2Vjb25kcyh3aGVuKTtcblx0XHRyZXR1cm4gbmV3IFRvbmUuVGltZSh0aGlzLmdldER1cmF0aW9uT2ZUaWNrcyh0aWNrcywgd2hlbikpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgaW52ZXJzZSBvZiBbdGlja3NUb1RpbWVdKCN0aWNrc3RvdGltZSkuIENvbnZlcnQgYSBkdXJhdGlvbiBpblxuXHQgKiBzZWNvbmRzIHRvIHRoZSBjb3JyZXNwb25kaW5nIG51bWJlciBvZiB0aWNrcyBhY2NvdW50aW5nIGZvciBhbnlcblx0ICogYXV0b21hdGlvbiBjdXJ2ZXMgc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHRpbWUuXG5cdCAqIEBwYXJhbSAge1RpbWV9IGR1cmF0aW9uIFRoZSB0aW1lIGludGVydmFsIHRvIGNvbnZlcnQgdG8gdGlja3MuXG5cdCAqIEBwYXJhbSAge1RpbWV9IFt3aGVuPW5vd10gICAgIFdoZW4gYWxvbmcgdGhlIGF1dG9tYXRpb24gdGltZWxpbmUgdG8gY29udmVydCB0aGUgdGlja3MuXG5cdCAqIEByZXR1cm4ge1RvbmUuVGlja3N9ICAgICAgICAgIFRoZSBkdXJhdGlvbiBpbiB0aWNrcy5cblx0ICovXG5cdFRvbmUuVGlja1NpZ25hbC5wcm90b3R5cGUudGltZVRvVGlja3MgPSBmdW5jdGlvbihkdXJhdGlvbiwgd2hlbil7XG5cdFx0d2hlbiA9IHRoaXMudG9TZWNvbmRzKHdoZW4pO1xuXHRcdGR1cmF0aW9uID0gdGhpcy50b1NlY29uZHMoZHVyYXRpb24pO1xuXHRcdHZhciBzdGFydFRpY2tzID0gdGhpcy5nZXRUaWNrc0F0VGltZSh3aGVuKTtcblx0XHR2YXIgZW5kVGlja3MgPSB0aGlzLmdldFRpY2tzQXRUaW1lKHdoZW4gKyBkdXJhdGlvbik7XG5cdFx0cmV0dXJuIG5ldyBUb25lLlRpY2tzKGVuZFRpY2tzIC0gc3RhcnRUaWNrcyk7XG5cdH07XG5cblx0cmV0dXJuIFRvbmUuVGlja1NpZ25hbDtcbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUVBOzs7Ozs7Ozs7OztBQVdBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/signal/TickSignal.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/signal/WaveShaper.js":
/*!*****************************************************!*\
  !*** ./node_modules/tone/Tone/signal/WaveShaper.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/signal/SignalBase */ \"./node_modules/tone/Tone/signal/SignalBase.js\"), __webpack_require__(/*! Tone/shim/WaveShaperNode */ \"./node_modules/tone/Tone/shim/WaveShaperNode.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  \"use strict\";\n  /**\n   *  @class Wraps the native Web Audio API\n   *         [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n   *\n   *  @extends {Tone.SignalBase}\n   *  @constructor\n   *  @param {function|Array|Number} mapping The function used to define the values.\n   *                                    The mapping function should take two arguments:\n   *                                    the first is the value at the current position\n   *                                    and the second is the array position.\n   *                                    If the argument is an array, that array will be\n   *                                    set as the wave shaping function. The input\n   *                                    signal is an AudioRange [-1, 1] value and the output\n   *                                    signal can take on any numerical values.\n   *\n   *  @param {Number} [bufferLen=1024] The length of the WaveShaperNode buffer.\n   *  @example\n   * var timesTwo = new Tone.WaveShaper(function(val){\n   * \treturn val * 2;\n   * }, 2048);\n   *  @example\n   * //a waveshaper can also be constructed with an array of values\n   * var invert = new Tone.WaveShaper([1, -1]);\n   */\n\n  Tone.WaveShaper = function (mapping, bufferLen) {\n    Tone.SignalBase.call(this);\n    /**\n     *  the waveshaper\n     *  @type {WaveShaperNode}\n     *  @private\n     */\n\n    this._shaper = this.input = this.output = this.context.createWaveShaper();\n    /**\n     *  the waveshapers curve\n     *  @type {Float32Array}\n     *  @private\n     */\n\n    this._curve = null;\n\n    if (Array.isArray(mapping)) {\n      this.curve = mapping;\n    } else if (isFinite(mapping) || Tone.isUndef(mapping)) {\n      this._curve = new Float32Array(Tone.defaultArg(mapping, 1024));\n    } else if (Tone.isFunction(mapping)) {\n      this._curve = new Float32Array(Tone.defaultArg(bufferLen, 1024));\n      this.setMap(mapping);\n    }\n  };\n\n  Tone.extend(Tone.WaveShaper, Tone.SignalBase);\n  /**\n   *  Uses a mapping function to set the value of the curve.\n   *  @param {function} mapping The function used to define the values.\n   *                            The mapping function take two arguments:\n   *                            the first is the value at the current position\n   *                            which goes from -1 to 1 over the number of elements\n   *                            in the curve array. The second argument is the array position.\n   *  @returns {Tone.WaveShaper} this\n   *  @example\n   * //map the input signal from [-1, 1] to [0, 10]\n   * shaper.setMap(function(val, index){\n   * \treturn (val + 1) * 5;\n   * })\n   */\n\n  Tone.WaveShaper.prototype.setMap = function (mapping) {\n    var array = new Array(this._curve.length);\n\n    for (var i = 0, len = this._curve.length; i < len; i++) {\n      var normalized = i / (len - 1) * 2 - 1;\n      array[i] = mapping(normalized, i);\n    }\n\n    this.curve = array;\n    return this;\n  };\n  /**\n   * The array to set as the waveshaper curve. For linear curves\n   * array length does not make much difference, but for complex curves\n   * longer arrays will provide smoother interpolation.\n   * @memberOf Tone.WaveShaper#\n   * @type {Array}\n   * @name curve\n   */\n\n\n  Object.defineProperty(Tone.WaveShaper.prototype, \"curve\", {\n    get: function () {\n      function get() {\n        return this._shaper.curve;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(mapping) {\n        this._curve = new Float32Array(mapping);\n        this._shaper.curve = this._curve;\n      }\n\n      return set;\n    }()\n  });\n  /**\n   * Specifies what type of oversampling (if any) should be used when\n   * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n   * @memberOf Tone.WaveShaper#\n   * @type {string}\n   * @name oversample\n   */\n\n  Object.defineProperty(Tone.WaveShaper.prototype, \"oversample\", {\n    get: function () {\n      function get() {\n        return this._shaper.oversample;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(oversampling) {\n        if ([\"none\", \"2x\", \"4x\"].includes(oversampling)) {\n          this._shaper.oversample = oversampling;\n        } else {\n          throw new RangeError(\"Tone.WaveShaper: oversampling must be either 'none', '2x', or '4x'\");\n        }\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  Clean up.\n   *  @returns {Tone.WaveShaper} this\n   */\n\n  Tone.WaveShaper.prototype.dispose = function () {\n    Tone.SignalBase.prototype.dispose.call(this);\n\n    this._shaper.disconnect();\n\n    this._shaper = null;\n    this._curve = null;\n    return this;\n  };\n\n  return Tone.WaveShaper;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3NpZ25hbC9XYXZlU2hhcGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RvbmUvVG9uZS9zaWduYWwvV2F2ZVNoYXBlci5qcz82MTI1Il0sInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbXCJUb25lL2NvcmUvVG9uZVwiLCBcIlRvbmUvc2lnbmFsL1NpZ25hbEJhc2VcIiwgXCJUb25lL3NoaW0vV2F2ZVNoYXBlck5vZGVcIl0sIGZ1bmN0aW9uKFRvbmUpe1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiAgQGNsYXNzIFdyYXBzIHRoZSBuYXRpdmUgV2ViIEF1ZGlvIEFQSVxuXHQgKiAgICAgICAgIFtXYXZlU2hhcGVyTm9kZV0oaHR0cDovL3dlYmF1ZGlvLmdpdGh1Yi5pby93ZWItYXVkaW8tYXBpLyN0aGUtd2F2ZXNoYXBlcm5vZGUtaW50ZXJmYWNlKS5cblx0ICpcblx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdCAqICBAY29uc3RydWN0b3Jcblx0ICogIEBwYXJhbSB7ZnVuY3Rpb258QXJyYXl8TnVtYmVyfSBtYXBwaW5nIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGRlZmluZSB0aGUgdmFsdWVzLlxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBtYXBwaW5nIGZ1bmN0aW9uIHNob3VsZCB0YWtlIHR3byBhcmd1bWVudHM6XG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGZpcnN0IGlzIHRoZSB2YWx1ZSBhdCB0aGUgY3VycmVudCBwb3NpdGlvblxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCB0aGUgc2Vjb25kIGlzIHRoZSBhcnJheSBwb3NpdGlvbi5cblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXksIHRoYXQgYXJyYXkgd2lsbCBiZVxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldCBhcyB0aGUgd2F2ZSBzaGFwaW5nIGZ1bmN0aW9uLiBUaGUgaW5wdXRcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWwgaXMgYW4gQXVkaW9SYW5nZSBbLTEsIDFdIHZhbHVlIGFuZCB0aGUgb3V0cHV0XG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsIGNhbiB0YWtlIG9uIGFueSBudW1lcmljYWwgdmFsdWVzLlxuXHQgKlxuXHQgKiAgQHBhcmFtIHtOdW1iZXJ9IFtidWZmZXJMZW49MTAyNF0gVGhlIGxlbmd0aCBvZiB0aGUgV2F2ZVNoYXBlck5vZGUgYnVmZmVyLlxuXHQgKiAgQGV4YW1wbGVcblx0ICogdmFyIHRpbWVzVHdvID0gbmV3IFRvbmUuV2F2ZVNoYXBlcihmdW5jdGlvbih2YWwpe1xuXHQgKiBcdHJldHVybiB2YWwgKiAyO1xuXHQgKiB9LCAyMDQ4KTtcblx0ICogIEBleGFtcGxlXG5cdCAqIC8vYSB3YXZlc2hhcGVyIGNhbiBhbHNvIGJlIGNvbnN0cnVjdGVkIHdpdGggYW4gYXJyYXkgb2YgdmFsdWVzXG5cdCAqIHZhciBpbnZlcnQgPSBuZXcgVG9uZS5XYXZlU2hhcGVyKFsxLCAtMV0pO1xuXHQgKi9cblx0VG9uZS5XYXZlU2hhcGVyID0gZnVuY3Rpb24obWFwcGluZywgYnVmZmVyTGVuKXtcblxuXHRcdFRvbmUuU2lnbmFsQmFzZS5jYWxsKHRoaXMpO1xuXG5cdFx0LyoqXG5cdFx0ICogIHRoZSB3YXZlc2hhcGVyXG5cdFx0ICogIEB0eXBlIHtXYXZlU2hhcGVyTm9kZX1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9zaGFwZXIgPSB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSB0aGlzLmNvbnRleHQuY3JlYXRlV2F2ZVNoYXBlcigpO1xuXG5cdFx0LyoqXG5cdFx0ICogIHRoZSB3YXZlc2hhcGVycyBjdXJ2ZVxuXHRcdCAqICBAdHlwZSB7RmxvYXQzMkFycmF5fVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2N1cnZlID0gbnVsbDtcblxuXHRcdGlmIChBcnJheS5pc0FycmF5KG1hcHBpbmcpKXtcblx0XHRcdHRoaXMuY3VydmUgPSBtYXBwaW5nO1xuXHRcdH0gZWxzZSBpZiAoaXNGaW5pdGUobWFwcGluZykgfHwgVG9uZS5pc1VuZGVmKG1hcHBpbmcpKXtcblx0XHRcdHRoaXMuX2N1cnZlID0gbmV3IEZsb2F0MzJBcnJheShUb25lLmRlZmF1bHRBcmcobWFwcGluZywgMTAyNCkpO1xuXHRcdH0gZWxzZSBpZiAoVG9uZS5pc0Z1bmN0aW9uKG1hcHBpbmcpKXtcblx0XHRcdHRoaXMuX2N1cnZlID0gbmV3IEZsb2F0MzJBcnJheShUb25lLmRlZmF1bHRBcmcoYnVmZmVyTGVuLCAxMDI0KSk7XG5cdFx0XHR0aGlzLnNldE1hcChtYXBwaW5nKTtcblx0XHR9XG5cdH07XG5cblx0VG9uZS5leHRlbmQoVG9uZS5XYXZlU2hhcGVyLCBUb25lLlNpZ25hbEJhc2UpO1xuXG5cdC8qKlxuXHQgKiAgVXNlcyBhIG1hcHBpbmcgZnVuY3Rpb24gdG8gc2V0IHRoZSB2YWx1ZSBvZiB0aGUgY3VydmUuXG5cdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBtYXBwaW5nIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGRlZmluZSB0aGUgdmFsdWVzLlxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgbWFwcGluZyBmdW5jdGlvbiB0YWtlIHR3byBhcmd1bWVudHM6XG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBmaXJzdCBpcyB0aGUgdmFsdWUgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb25cblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpY2ggZ29lcyBmcm9tIC0xIHRvIDEgb3ZlciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRoZSBjdXJ2ZSBhcnJheS4gVGhlIHNlY29uZCBhcmd1bWVudCBpcyB0aGUgYXJyYXkgcG9zaXRpb24uXG5cdCAqICBAcmV0dXJucyB7VG9uZS5XYXZlU2hhcGVyfSB0aGlzXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAvL21hcCB0aGUgaW5wdXQgc2lnbmFsIGZyb20gWy0xLCAxXSB0byBbMCwgMTBdXG5cdCAqIHNoYXBlci5zZXRNYXAoZnVuY3Rpb24odmFsLCBpbmRleCl7XG5cdCAqIFx0cmV0dXJuICh2YWwgKyAxKSAqIDU7XG5cdCAqIH0pXG5cdCAqL1xuXHRUb25lLldhdmVTaGFwZXIucHJvdG90eXBlLnNldE1hcCA9IGZ1bmN0aW9uKG1hcHBpbmcpe1xuXHRcdHZhciBhcnJheSA9IG5ldyBBcnJheSh0aGlzLl9jdXJ2ZS5sZW5ndGgpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9jdXJ2ZS5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG5cdFx0XHR2YXIgbm9ybWFsaXplZCA9IChpIC8gKGxlbiAtIDEpKSAqIDIgLSAxO1xuXHRcdFx0YXJyYXlbaV0gPSBtYXBwaW5nKG5vcm1hbGl6ZWQsIGkpO1xuXHRcdH1cblx0XHR0aGlzLmN1cnZlID0gYXJyYXk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBhcnJheSB0byBzZXQgYXMgdGhlIHdhdmVzaGFwZXIgY3VydmUuIEZvciBsaW5lYXIgY3VydmVzXG5cdCAqIGFycmF5IGxlbmd0aCBkb2VzIG5vdCBtYWtlIG11Y2ggZGlmZmVyZW5jZSwgYnV0IGZvciBjb21wbGV4IGN1cnZlc1xuXHQgKiBsb25nZXIgYXJyYXlzIHdpbGwgcHJvdmlkZSBzbW9vdGhlciBpbnRlcnBvbGF0aW9uLlxuXHQgKiBAbWVtYmVyT2YgVG9uZS5XYXZlU2hhcGVyI1xuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqIEBuYW1lIGN1cnZlXG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5XYXZlU2hhcGVyLnByb3RvdHlwZSwgXCJjdXJ2ZVwiLCB7XG5cdFx0Z2V0IDogZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiB0aGlzLl9zaGFwZXIuY3VydmU7XG5cdFx0fSxcblx0XHRzZXQgOiBmdW5jdGlvbihtYXBwaW5nKXtcblx0XHRcdHRoaXMuX2N1cnZlID0gbmV3IEZsb2F0MzJBcnJheShtYXBwaW5nKTtcblx0XHRcdHRoaXMuX3NoYXBlci5jdXJ2ZSA9IHRoaXMuX2N1cnZlO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIFNwZWNpZmllcyB3aGF0IHR5cGUgb2Ygb3ZlcnNhbXBsaW5nIChpZiBhbnkpIHNob3VsZCBiZSB1c2VkIHdoZW5cblx0ICogYXBwbHlpbmcgdGhlIHNoYXBpbmcgY3VydmUuIENhbiBlaXRoZXIgYmUgXCJub25lXCIsIFwiMnhcIiBvciBcIjR4XCIuXG5cdCAqIEBtZW1iZXJPZiBUb25lLldhdmVTaGFwZXIjXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqIEBuYW1lIG92ZXJzYW1wbGVcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLldhdmVTaGFwZXIucHJvdG90eXBlLCBcIm92ZXJzYW1wbGVcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc2hhcGVyLm92ZXJzYW1wbGU7XG5cdFx0fSxcblx0XHRzZXQgOiBmdW5jdGlvbihvdmVyc2FtcGxpbmcpe1xuXHRcdFx0aWYgKFtcIm5vbmVcIiwgXCIyeFwiLCBcIjR4XCJdLmluY2x1ZGVzKG92ZXJzYW1wbGluZykpe1xuXHRcdFx0XHR0aGlzLl9zaGFwZXIub3ZlcnNhbXBsZSA9IG92ZXJzYW1wbGluZztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiVG9uZS5XYXZlU2hhcGVyOiBvdmVyc2FtcGxpbmcgbXVzdCBiZSBlaXRoZXIgJ25vbmUnLCAnMngnLCBvciAnNHgnXCIpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqICBDbGVhbiB1cC5cblx0ICogIEByZXR1cm5zIHtUb25lLldhdmVTaGFwZXJ9IHRoaXNcblx0ICovXG5cdFRvbmUuV2F2ZVNoYXBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCl7XG5cdFx0VG9uZS5TaWduYWxCYXNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5fc2hhcGVyLmRpc2Nvbm5lY3QoKTtcblx0XHR0aGlzLl9zaGFwZXIgPSBudWxsO1xuXHRcdHRoaXMuX2N1cnZlID0gbnVsbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHRyZXR1cm4gVG9uZS5XYXZlU2hhcGVyO1xufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBRUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTtBQUVBO0FBRUE7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUFBO0FBSkE7QUFVQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFBQTtBQUpBO0FBYUE7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/signal/WaveShaper.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/source/BufferSource.js":
/*!*******************************************************!*\
  !*** ./node_modules/tone/Tone/source/BufferSource.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/core/Buffer */ \"./node_modules/tone/Tone/core/Buffer.js\"), __webpack_require__(/*! Tone/source/Source */ \"./node_modules/tone/Tone/source/Source.js\"), __webpack_require__(/*! Tone/core/Gain */ \"./node_modules/tone/Tone/core/Gain.js\"), __webpack_require__(/*! Tone/core/AudioNode */ \"./node_modules/tone/Tone/core/AudioNode.js\"), __webpack_require__(/*! Tone/shim/BufferSourceNode */ \"./node_modules/tone/Tone/shim/BufferSourceNode.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  /**\n   *  @class Wrapper around the native BufferSourceNode.\n   *  @extends {Tone.AudioNode}\n   *  @param  {AudioBuffer|Tone.Buffer}  buffer   The buffer to play\n   *  @param  {Function}  onload  The callback to invoke when the\n   *                               buffer is done playing.\n   */\n  Tone.BufferSource = function () {\n    var options = Tone.defaults(arguments, [\"buffer\", \"onload\"], Tone.BufferSource);\n    Tone.AudioNode.call(this, options);\n    /**\n     *  The callback to invoke after the\n     *  buffer source is done playing.\n     *  @type  {Function}\n     */\n\n    this.onended = options.onended;\n    /**\n     *  The time that the buffer was started.\n     *  @type  {Number}\n     *  @private\n     */\n\n    this._startTime = -1;\n    /**\n     *  An additional flag if the actual BufferSourceNode\n     *  has been started. b/c stopping an unstarted buffer\n     *  will throw it into an invalid state\n     *  @type  {Boolean}\n     *  @private\n     */\n\n    this._sourceStarted = false;\n    /**\n     *  Flag if the source has already been stopped\n     *  @type  {Boolean}\n     *  @private\n     */\n\n    this._sourceStopped = false;\n    /**\n     *  The time that the buffer is scheduled to stop.\n     *  @type  {Number}\n     *  @private\n     */\n\n    this._stopTime = -1;\n    /**\n     *  The gain node which envelopes the BufferSource\n     *  @type  {Tone.Gain}\n     *  @private\n     */\n\n    this._gainNode = this.output = new Tone.Gain();\n    /**\n     *  The buffer source\n     *  @type  {AudioBufferSourceNode}\n     *  @private\n     */\n\n    this._source = this.context.createBufferSource();\n\n    this._source.connect(this._gainNode);\n\n    this._source.onended = this._onended.bind(this);\n    /**\n     * The private buffer instance\n     * @type {Tone.Buffer}\n     * @private\n     */\n\n    this._buffer = new Tone.Buffer(options.buffer, options.onload);\n    /**\n     *  The playbackRate of the buffer\n     *  @type {Positive}\n     *  @signal\n     */\n\n    this.playbackRate = new Tone.Param(this._source.playbackRate, Tone.Type.Positive);\n    /**\n     *  The fadeIn time of the amplitude envelope.\n     *  @type {Time}\n     */\n\n    this.fadeIn = options.fadeIn;\n    /**\n     *  The fadeOut time of the amplitude envelope.\n     *  @type {Time}\n     */\n\n    this.fadeOut = options.fadeOut;\n    /**\n     * The curve applied to the fades, either \"linear\" or \"exponential\"\n     * @type {String}\n     */\n\n    this.curve = options.curve;\n    /**\n     *  The value that the buffer ramps to\n     *  @type {Gain}\n     *  @private\n     */\n\n    this._gain = 1;\n    /**\n     * The onended timeout\n     * @type {Number}\n     * @private\n     */\n\n    this._onendedTimeout = -1; //set some values initially\n\n    this.loop = options.loop;\n    this.loopStart = options.loopStart;\n    this.loopEnd = options.loopEnd;\n    this.playbackRate.value = options.playbackRate;\n  };\n\n  Tone.extend(Tone.BufferSource, Tone.AudioNode);\n  /**\n   *  The defaults\n   *  @const\n   *  @type  {Object}\n   */\n\n  Tone.BufferSource.defaults = {\n    \"onended\": Tone.noOp,\n    \"onload\": Tone.noOp,\n    \"loop\": false,\n    \"loopStart\": 0,\n    \"loopEnd\": 0,\n    \"fadeIn\": 0,\n    \"fadeOut\": 0,\n    \"curve\": \"linear\",\n    \"playbackRate\": 1\n  };\n  /**\n   *  Returns the playback state of the source, either \"started\" or \"stopped\".\n   *  @type {Tone.State}\n   *  @readOnly\n   *  @memberOf Tone.BufferSource#\n   *  @name state\n   */\n\n  Object.defineProperty(Tone.BufferSource.prototype, \"state\", {\n    get: function () {\n      function get() {\n        return this.getStateAtTime(this.now());\n      }\n\n      return get;\n    }()\n  });\n  /**\n   *  Get the playback state at the given time\n   *  @param  {Time}  time  The time to test the state at\n   *  @return  {Tone.State}  The playback state. \n   */\n\n  Tone.BufferSource.prototype.getStateAtTime = function (time) {\n    time = this.toSeconds(time);\n\n    if (this._startTime !== -1 && time >= this._startTime && !this._sourceStopped) {\n      return Tone.State.Started;\n    } else {\n      return Tone.State.Stopped;\n    }\n  };\n  /**\n   *  Start the buffer\n   *  @param  {Time} [startTime=now] When the player should start.\n   *  @param  {Time} [offset=0] The offset from the beginning of the sample\n   *                                 to start at.\n   *  @param  {Time=} duration How long the sample should play. If no duration\n   *                                is given, it will default to the full length\n   *                                of the sample (minus any offset)\n   *  @param  {Gain}  [gain=1]  The gain to play the buffer back at.\n   *  @param  {Time=}  fadeInTime  The optional fadeIn ramp time.\n   *  @return  {Tone.BufferSource}  this\n   */\n\n\n  Tone.BufferSource.prototype.start = function (time, offset, duration, gain, fadeInTime) {\n    if (this._startTime !== -1) {\n      throw new Error(\"Tone.BufferSource can only be started once.\");\n    }\n\n    if (!this.buffer.loaded) {\n      throw new Error(\"Tone.BufferSource: buffer is either not set or not loaded.\");\n    }\n\n    time = this.toSeconds(time); //if it's a loop the default offset is the loopstart point\n\n    if (this.loop) {\n      offset = Tone.defaultArg(offset, this.loopStart);\n    } else {\n      //otherwise the default offset is 0\n      offset = Tone.defaultArg(offset, 0);\n    }\n\n    offset = this.toSeconds(offset);\n    gain = Tone.defaultArg(gain, 1);\n    this._gain = gain;\n    fadeInTime = this.toSeconds(Tone.defaultArg(fadeInTime, this.fadeIn));\n    this.fadeIn = fadeInTime;\n\n    if (fadeInTime > 0) {\n      this._gainNode.gain.setValueAtTime(0, time);\n\n      if (this.curve === \"linear\") {\n        this._gainNode.gain.linearRampToValueAtTime(this._gain, time + fadeInTime);\n      } else {\n        this._gainNode.gain.exponentialApproachValueAtTime(this._gain, time, fadeInTime);\n      }\n    } else {\n      this._gainNode.gain.setValueAtTime(gain, time);\n    }\n\n    this._startTime = time;\n    var computedDur = this.toSeconds(Tone.defaultArg(duration, this.buffer.duration - offset % this.buffer.duration));\n    computedDur = Math.max(computedDur, 0);\n\n    if (Tone.isDefined(duration)) {\n      //clip the duration when not looping\n      if (!this.loop) {\n        computedDur = Math.min(computedDur, this.buffer.duration - offset % this.buffer.duration);\n      }\n\n      this.stop(time + computedDur, this.fadeOut);\n    } //start the buffer source\n\n\n    if (this.loop) {\n      //modify the offset if it's greater than the loop time\n      var loopEnd = this.loopEnd || this.buffer.duration;\n      var loopStart = this.loopStart;\n      var loopDuration = loopEnd - loopStart; //move the offset back\n\n      if (offset >= loopEnd) {\n        offset = (offset - loopStart) % loopDuration + loopStart;\n      }\n    }\n\n    this._source.buffer = this.buffer.get();\n    this._source.loopEnd = this.loopEnd || this.buffer.duration;\n\n    if (offset < this.buffer.duration) {\n      this._sourceStarted = true;\n\n      this._source.start(time, offset);\n    }\n\n    return this;\n  };\n  /**\n   *  Stop the buffer. Optionally add a ramp time to fade the\n   *  buffer out.\n   *  @param  {Time=}  time         The time the buffer should stop.\n   *  @param  {Time=}  fadeOutTime  How long the gain should fade out for\n   *  @return  {Tone.BufferSource}  this\n   */\n\n\n  Tone.BufferSource.prototype.stop = function (time, fadeOutTime) {\n    if (!this.buffer.loaded) {\n      throw new Error(\"Tone.BufferSource: buffer is either not set or not loaded.\");\n    }\n\n    if (this._sourceStopped) {\n      return;\n    }\n\n    time = this.toSeconds(time); //if the event has already been scheduled, clear it\n\n    if (this._stopTime !== -1) {\n      this.cancelStop();\n    } //stop if it's schedule before the start time\n\n\n    if (time <= this._startTime) {\n      this._gainNode.gain.cancelScheduledValues(time);\n\n      this._gainNode.gain.value = 0;\n      return this;\n    }\n\n    time = Math.max(this._startTime + this.fadeIn + this.sampleTime, time); //cancel the previous curve\n\n    this._gainNode.gain.cancelScheduledValues(time);\n\n    this._stopTime = time; //the fadeOut time\n\n    fadeOutTime = this.toSeconds(Tone.defaultArg(fadeOutTime, this.fadeOut));\n    var heldDuration = time - this._startTime - this.fadeIn - this.sampleTime;\n\n    if (!this.loop) {\n      //make sure the fade does not go beyond the length of the buffer\n      heldDuration = Math.min(heldDuration, this.buffer.duration);\n    }\n\n    fadeOutTime = Math.min(heldDuration, fadeOutTime);\n    var startFade = time - fadeOutTime;\n\n    if (fadeOutTime > this.sampleTime) {\n      this._gainNode.gain.setValueAtTime(this._gain, startFade);\n\n      if (this.curve === \"linear\") {\n        this._gainNode.gain.linearRampToValueAtTime(0, time);\n      } else {\n        this._gainNode.gain.exponentialApproachValueAtTime(0, startFade, fadeOutTime);\n      }\n    } else {\n      this._gainNode.gain.setValueAtTime(0, time);\n    }\n\n    Tone.context.clearTimeout(this._onendedTimeout);\n    this._onendedTimeout = Tone.context.setTimeout(this._onended.bind(this), this._stopTime - this.now());\n    return this;\n  };\n  /**\n   *  Cancel a scheduled stop event\n   *  @return  {Tone.BufferSource}  this\n   */\n\n\n  Tone.BufferSource.prototype.cancelStop = function () {\n    if (this._startTime !== -1 && !this._sourceStopped) {\n      //cancel the stop envelope\n      var fadeInTime = this.toSeconds(this.fadeIn);\n\n      this._gainNode.gain.cancelScheduledValues(this._startTime + fadeInTime + this.sampleTime);\n\n      this._gainNode.gain.setValueAtTime(1, Math.max(this.now(), this._startTime + fadeInTime + this.sampleTime));\n\n      this.context.clearTimeout(this._onendedTimeout);\n      this._stopTime = -1;\n    }\n\n    return this;\n  };\n  /**\n   *  Internal callback when the buffer is ended.\n   *  Invokes `onended` and disposes the node.\n   *  @private\n   */\n\n\n  Tone.BufferSource.prototype._onended = function () {\n    if (!this._sourceStopped) {\n      this._sourceStopped = true; //allow additional time for the exponential curve to fully decay\n\n      var additionalTail = this.curve === \"exponential\" ? this.fadeOut * 2 : 0;\n\n      if (this._sourceStarted && this._stopTime !== -1) {\n        this._source.stop(this._stopTime + additionalTail);\n      }\n\n      this.onended(this);\n    }\n  };\n  /**\n   * If loop is true, the loop will start at this position.\n   * @memberOf Tone.BufferSource#\n   * @type {Time}\n   * @name loopStart\n   */\n\n\n  Object.defineProperty(Tone.BufferSource.prototype, \"loopStart\", {\n    get: function () {\n      function get() {\n        return this._source.loopStart;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(loopStart) {\n        this._source.loopStart = this.toSeconds(loopStart);\n      }\n\n      return set;\n    }()\n  });\n  /**\n   * If loop is true, the loop will end at this position.\n   * @memberOf Tone.BufferSource#\n   * @type {Time}\n   * @name loopEnd\n   */\n\n  Object.defineProperty(Tone.BufferSource.prototype, \"loopEnd\", {\n    get: function () {\n      function get() {\n        return this._source.loopEnd;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(loopEnd) {\n        this._source.loopEnd = this.toSeconds(loopEnd);\n      }\n\n      return set;\n    }()\n  });\n  /**\n   * The audio buffer belonging to the player.\n   * @memberOf Tone.BufferSource#\n   * @type {Tone.Buffer}\n   * @name buffer\n   */\n\n  Object.defineProperty(Tone.BufferSource.prototype, \"buffer\", {\n    get: function () {\n      function get() {\n        return this._buffer;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(buffer) {\n        this._buffer.set(buffer);\n      }\n\n      return set;\n    }()\n  });\n  /**\n   * If the buffer should loop once it's over.\n   * @memberOf Tone.BufferSource#\n   * @type {Boolean}\n   * @name loop\n   */\n\n  Object.defineProperty(Tone.BufferSource.prototype, \"loop\", {\n    get: function () {\n      function get() {\n        return this._source.loop;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(loop) {\n        this._source.loop = loop;\n        this.cancelStop();\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  Clean up.\n   *  @return  {Tone.BufferSource}  this\n   */\n\n  Tone.BufferSource.prototype.dispose = function () {\n    Tone.AudioNode.prototype.dispose.call(this);\n    this.onended = null;\n    this._source.onended = null;\n\n    this._source.disconnect();\n\n    this._source = null;\n\n    this._gainNode.dispose();\n\n    this._gainNode = null;\n\n    this._buffer.dispose();\n\n    this._buffer = null;\n    this._startTime = -1;\n    this.playbackRate = null;\n    Tone.context.clearTimeout(this._onendedTimeout);\n    return this;\n  };\n\n  return Tone.BufferSource;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3NvdXJjZS9CdWZmZXJTb3VyY2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3NvdXJjZS9CdWZmZXJTb3VyY2UuanM/ZDk3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoW1wiVG9uZS9jb3JlL1RvbmVcIiwgXCJUb25lL2NvcmUvQnVmZmVyXCIsIFwiVG9uZS9zb3VyY2UvU291cmNlXCIsIFwiVG9uZS9jb3JlL0dhaW5cIixcblx0XCJUb25lL2NvcmUvQXVkaW9Ob2RlXCIsIFwiVG9uZS9zaGltL0J1ZmZlclNvdXJjZU5vZGVcIl0sIGZ1bmN0aW9uKFRvbmUpe1xuXG5cdC8qKlxuXHQgKiAgQGNsYXNzIFdyYXBwZXIgYXJvdW5kIHRoZSBuYXRpdmUgQnVmZmVyU291cmNlTm9kZS5cblx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0ICogIEBwYXJhbSAge0F1ZGlvQnVmZmVyfFRvbmUuQnVmZmVyfSAgYnVmZmVyICAgVGhlIGJ1ZmZlciB0byBwbGF5XG5cdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIG9ubG9hZCAgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIHRoZVxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgaXMgZG9uZSBwbGF5aW5nLlxuXHQgKi9cblx0VG9uZS5CdWZmZXJTb3VyY2UgPSBmdW5jdGlvbigpe1xuXG5cdFx0dmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1wiYnVmZmVyXCIsIFwib25sb2FkXCJdLCBUb25lLkJ1ZmZlclNvdXJjZSk7XG5cdFx0VG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuXHRcdC8qKlxuXHRcdCAqICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGFmdGVyIHRoZVxuXHRcdCAqICBidWZmZXIgc291cmNlIGlzIGRvbmUgcGxheWluZy5cblx0XHQgKiAgQHR5cGUgIHtGdW5jdGlvbn1cblx0XHQgKi9cblx0XHR0aGlzLm9uZW5kZWQgPSBvcHRpb25zLm9uZW5kZWQ7XG5cblx0XHQvKipcblx0XHQgKiAgVGhlIHRpbWUgdGhhdCB0aGUgYnVmZmVyIHdhcyBzdGFydGVkLlxuXHRcdCAqICBAdHlwZSAge051bWJlcn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9zdGFydFRpbWUgPSAtMTtcblxuXHRcdC8qKlxuXHRcdCAqICBBbiBhZGRpdGlvbmFsIGZsYWcgaWYgdGhlIGFjdHVhbCBCdWZmZXJTb3VyY2VOb2RlXG5cdFx0ICogIGhhcyBiZWVuIHN0YXJ0ZWQuIGIvYyBzdG9wcGluZyBhbiB1bnN0YXJ0ZWQgYnVmZmVyXG5cdFx0ICogIHdpbGwgdGhyb3cgaXQgaW50byBhbiBpbnZhbGlkIHN0YXRlXG5cdFx0ICogIEB0eXBlICB7Qm9vbGVhbn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9zb3VyY2VTdGFydGVkID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiAgRmxhZyBpZiB0aGUgc291cmNlIGhhcyBhbHJlYWR5IGJlZW4gc3RvcHBlZFxuXHRcdCAqICBAdHlwZSAge0Jvb2xlYW59XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fc291cmNlU3RvcHBlZCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogIFRoZSB0aW1lIHRoYXQgdGhlIGJ1ZmZlciBpcyBzY2hlZHVsZWQgdG8gc3RvcC5cblx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fc3RvcFRpbWUgPSAtMTtcblxuXHRcdC8qKlxuXHRcdCAqICBUaGUgZ2FpbiBub2RlIHdoaWNoIGVudmVsb3BlcyB0aGUgQnVmZmVyU291cmNlXG5cdFx0ICogIEB0eXBlICB7VG9uZS5HYWlufVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2dhaW5Ob2RlID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5HYWluKCk7XG5cblx0XHQvKipcblx0XHQgKiAgVGhlIGJ1ZmZlciBzb3VyY2Vcblx0XHQgKiAgQHR5cGUgIHtBdWRpb0J1ZmZlclNvdXJjZU5vZGV9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuXHRcdHRoaXMuX3NvdXJjZS5jb25uZWN0KHRoaXMuX2dhaW5Ob2RlKTtcblx0XHR0aGlzLl9zb3VyY2Uub25lbmRlZCA9IHRoaXMuX29uZW5kZWQuYmluZCh0aGlzKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBwcml2YXRlIGJ1ZmZlciBpbnN0YW5jZVxuXHRcdCAqIEB0eXBlIHtUb25lLkJ1ZmZlcn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2J1ZmZlciA9IG5ldyBUb25lLkJ1ZmZlcihvcHRpb25zLmJ1ZmZlciwgb3B0aW9ucy5vbmxvYWQpO1xuXG5cdFx0LyoqXG5cdFx0ICogIFRoZSBwbGF5YmFja1JhdGUgb2YgdGhlIGJ1ZmZlclxuXHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0ICogIEBzaWduYWxcblx0XHQgKi9cblx0XHR0aGlzLnBsYXliYWNrUmF0ZSA9IG5ldyBUb25lLlBhcmFtKHRoaXMuX3NvdXJjZS5wbGF5YmFja1JhdGUsIFRvbmUuVHlwZS5Qb3NpdGl2ZSk7XG5cblx0XHQvKipcblx0XHQgKiAgVGhlIGZhZGVJbiB0aW1lIG9mIHRoZSBhbXBsaXR1ZGUgZW52ZWxvcGUuXG5cdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdCAqL1xuXHRcdHRoaXMuZmFkZUluID0gb3B0aW9ucy5mYWRlSW47XG5cblx0XHQvKipcblx0XHQgKiAgVGhlIGZhZGVPdXQgdGltZSBvZiB0aGUgYW1wbGl0dWRlIGVudmVsb3BlLlxuXHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHQgKi9cblx0XHR0aGlzLmZhZGVPdXQgPSBvcHRpb25zLmZhZGVPdXQ7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgY3VydmUgYXBwbGllZCB0byB0aGUgZmFkZXMsIGVpdGhlciBcImxpbmVhclwiIG9yIFwiZXhwb25lbnRpYWxcIlxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0dGhpcy5jdXJ2ZSA9IG9wdGlvbnMuY3VydmU7XG5cblx0XHQvKipcblx0XHQgKiAgVGhlIHZhbHVlIHRoYXQgdGhlIGJ1ZmZlciByYW1wcyB0b1xuXHRcdCAqICBAdHlwZSB7R2Fpbn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9nYWluID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBvbmVuZGVkIHRpbWVvdXRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fb25lbmRlZFRpbWVvdXQgPSAtMTtcblxuXHRcdC8vc2V0IHNvbWUgdmFsdWVzIGluaXRpYWxseVxuXHRcdHRoaXMubG9vcCA9IG9wdGlvbnMubG9vcDtcblx0XHR0aGlzLmxvb3BTdGFydCA9IG9wdGlvbnMubG9vcFN0YXJ0O1xuXHRcdHRoaXMubG9vcEVuZCA9IG9wdGlvbnMubG9vcEVuZDtcblx0XHR0aGlzLnBsYXliYWNrUmF0ZS52YWx1ZSA9IG9wdGlvbnMucGxheWJhY2tSYXRlO1xuXHR9O1xuXG5cdFRvbmUuZXh0ZW5kKFRvbmUuQnVmZmVyU291cmNlLCBUb25lLkF1ZGlvTm9kZSk7XG5cblx0LyoqXG5cdCAqICBUaGUgZGVmYXVsdHNcblx0ICogIEBjb25zdFxuXHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdCAqL1xuXHRUb25lLkJ1ZmZlclNvdXJjZS5kZWZhdWx0cyA9IHtcblx0XHRcIm9uZW5kZWRcIiA6IFRvbmUubm9PcCxcblx0XHRcIm9ubG9hZFwiIDogVG9uZS5ub09wLFxuXHRcdFwibG9vcFwiIDogZmFsc2UsXG5cdFx0XCJsb29wU3RhcnRcIiA6IDAsXG5cdFx0XCJsb29wRW5kXCIgOiAwLFxuXHRcdFwiZmFkZUluXCIgOiAwLFxuXHRcdFwiZmFkZU91dFwiIDogMCxcblx0XHRcImN1cnZlXCIgOiBcImxpbmVhclwiLFxuXHRcdFwicGxheWJhY2tSYXRlXCIgOiAxXG5cdH07XG5cblx0LyoqXG5cdCAqICBSZXR1cm5zIHRoZSBwbGF5YmFjayBzdGF0ZSBvZiB0aGUgc291cmNlLCBlaXRoZXIgXCJzdGFydGVkXCIgb3IgXCJzdG9wcGVkXCIuXG5cdCAqICBAdHlwZSB7VG9uZS5TdGF0ZX1cblx0ICogIEByZWFkT25seVxuXHQgKiAgQG1lbWJlck9mIFRvbmUuQnVmZmVyU291cmNlI1xuXHQgKiAgQG5hbWUgc3RhdGVcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlclNvdXJjZS5wcm90b3R5cGUsIFwic3RhdGVcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRTdGF0ZUF0VGltZSh0aGlzLm5vdygpKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiAgR2V0IHRoZSBwbGF5YmFjayBzdGF0ZSBhdCB0aGUgZ2l2ZW4gdGltZVxuXHQgKiAgQHBhcmFtICB7VGltZX0gIHRpbWUgIFRoZSB0aW1lIHRvIHRlc3QgdGhlIHN0YXRlIGF0XG5cdCAqICBAcmV0dXJuICB7VG9uZS5TdGF0ZX0gIFRoZSBwbGF5YmFjayBzdGF0ZS4gXG5cdCAqL1xuXHRUb25lLkJ1ZmZlclNvdXJjZS5wcm90b3R5cGUuZ2V0U3RhdGVBdFRpbWUgPSBmdW5jdGlvbih0aW1lKXtcblx0XHR0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdFx0aWYgKHRoaXMuX3N0YXJ0VGltZSAhPT0gLTEgJiYgdGltZSA+PSB0aGlzLl9zdGFydFRpbWUgJiYgIXRoaXMuX3NvdXJjZVN0b3BwZWQpe1xuXHRcdFx0cmV0dXJuIFRvbmUuU3RhdGUuU3RhcnRlZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFRvbmUuU3RhdGUuU3RvcHBlZDtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqICBTdGFydCB0aGUgYnVmZmVyXG5cdCAqICBAcGFyYW0gIHtUaW1lfSBbc3RhcnRUaW1lPW5vd10gV2hlbiB0aGUgcGxheWVyIHNob3VsZCBzdGFydC5cblx0ICogIEBwYXJhbSAge1RpbWV9IFtvZmZzZXQ9MF0gVGhlIG9mZnNldCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNhbXBsZVxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHN0YXJ0IGF0LlxuXHQgKiAgQHBhcmFtICB7VGltZT19IGR1cmF0aW9uIEhvdyBsb25nIHRoZSBzYW1wbGUgc2hvdWxkIHBsYXkuIElmIG5vIGR1cmF0aW9uXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBnaXZlbiwgaXQgd2lsbCBkZWZhdWx0IHRvIHRoZSBmdWxsIGxlbmd0aFxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIHNhbXBsZSAobWludXMgYW55IG9mZnNldClcblx0ICogIEBwYXJhbSAge0dhaW59ICBbZ2Fpbj0xXSAgVGhlIGdhaW4gdG8gcGxheSB0aGUgYnVmZmVyIGJhY2sgYXQuXG5cdCAqICBAcGFyYW0gIHtUaW1lPX0gIGZhZGVJblRpbWUgIFRoZSBvcHRpb25hbCBmYWRlSW4gcmFtcCB0aW1lLlxuXHQgKiAgQHJldHVybiAge1RvbmUuQnVmZmVyU291cmNlfSAgdGhpc1xuXHQgKi9cblx0VG9uZS5CdWZmZXJTb3VyY2UucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24odGltZSwgb2Zmc2V0LCBkdXJhdGlvbiwgZ2FpbiwgZmFkZUluVGltZSl7XG5cdFx0aWYgKHRoaXMuX3N0YXJ0VGltZSAhPT0gLTEpe1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVG9uZS5CdWZmZXJTb3VyY2UgY2FuIG9ubHkgYmUgc3RhcnRlZCBvbmNlLlwiKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuYnVmZmVyLmxvYWRlZCl7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUb25lLkJ1ZmZlclNvdXJjZTogYnVmZmVyIGlzIGVpdGhlciBub3Qgc2V0IG9yIG5vdCBsb2FkZWQuXCIpO1xuXHRcdH1cblxuXHRcdHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0XHQvL2lmIGl0J3MgYSBsb29wIHRoZSBkZWZhdWx0IG9mZnNldCBpcyB0aGUgbG9vcHN0YXJ0IHBvaW50XG5cdFx0aWYgKHRoaXMubG9vcCl7XG5cdFx0XHRvZmZzZXQgPSBUb25lLmRlZmF1bHRBcmcob2Zmc2V0LCB0aGlzLmxvb3BTdGFydCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vb3RoZXJ3aXNlIHRoZSBkZWZhdWx0IG9mZnNldCBpcyAwXG5cdFx0XHRvZmZzZXQgPSBUb25lLmRlZmF1bHRBcmcob2Zmc2V0LCAwKTtcblx0XHR9XG5cdFx0b2Zmc2V0ID0gdGhpcy50b1NlY29uZHMob2Zmc2V0KTtcblxuXHRcdGdhaW4gPSBUb25lLmRlZmF1bHRBcmcoZ2FpbiwgMSk7XG5cdFx0dGhpcy5fZ2FpbiA9IGdhaW47XG5cblx0XHRmYWRlSW5UaW1lID0gdGhpcy50b1NlY29uZHMoVG9uZS5kZWZhdWx0QXJnKGZhZGVJblRpbWUsIHRoaXMuZmFkZUluKSk7XG5cdFx0dGhpcy5mYWRlSW4gPSBmYWRlSW5UaW1lO1xuXG5cdFx0aWYgKGZhZGVJblRpbWUgPiAwKXtcblx0XHRcdHRoaXMuX2dhaW5Ob2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgdGltZSk7XG5cdFx0XHRpZiAodGhpcy5jdXJ2ZSA9PT0gXCJsaW5lYXJcIil7XG5cdFx0XHRcdHRoaXMuX2dhaW5Ob2RlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5fZ2FpbiwgdGltZSArIGZhZGVJblRpbWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fZ2Fpbk5vZGUuZ2Fpbi5leHBvbmVudGlhbEFwcHJvYWNoVmFsdWVBdFRpbWUodGhpcy5fZ2FpbiwgdGltZSwgZmFkZUluVGltZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2dhaW5Ob2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUoZ2FpbiwgdGltZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gdGltZTtcblxuXHRcdHZhciBjb21wdXRlZER1ciA9IHRoaXMudG9TZWNvbmRzKFRvbmUuZGVmYXVsdEFyZyhkdXJhdGlvbiwgdGhpcy5idWZmZXIuZHVyYXRpb24gLSAob2Zmc2V0ICUgdGhpcy5idWZmZXIuZHVyYXRpb24pKSk7XG5cdFx0Y29tcHV0ZWREdXIgPSBNYXRoLm1heChjb21wdXRlZER1ciwgMCk7XG5cblx0XHRpZiAoVG9uZS5pc0RlZmluZWQoZHVyYXRpb24pKXtcblx0XHRcdC8vY2xpcCB0aGUgZHVyYXRpb24gd2hlbiBub3QgbG9vcGluZ1xuXHRcdFx0aWYgKCF0aGlzLmxvb3Ape1xuXHRcdFx0XHRjb21wdXRlZER1ciA9IE1hdGgubWluKGNvbXB1dGVkRHVyLCB0aGlzLmJ1ZmZlci5kdXJhdGlvbiAtIChvZmZzZXQgJSB0aGlzLmJ1ZmZlci5kdXJhdGlvbikpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zdG9wKHRpbWUgKyBjb21wdXRlZER1ciwgdGhpcy5mYWRlT3V0KTtcblx0XHR9XG5cblx0XHQvL3N0YXJ0IHRoZSBidWZmZXIgc291cmNlXG5cdFx0aWYgKHRoaXMubG9vcCl7XG5cdFx0XHQvL21vZGlmeSB0aGUgb2Zmc2V0IGlmIGl0J3MgZ3JlYXRlciB0aGFuIHRoZSBsb29wIHRpbWVcblx0XHRcdHZhciBsb29wRW5kID0gdGhpcy5sb29wRW5kIHx8IHRoaXMuYnVmZmVyLmR1cmF0aW9uO1xuXHRcdFx0dmFyIGxvb3BTdGFydCA9IHRoaXMubG9vcFN0YXJ0O1xuXHRcdFx0dmFyIGxvb3BEdXJhdGlvbiA9IGxvb3BFbmQgLSBsb29wU3RhcnQ7XG5cdFx0XHQvL21vdmUgdGhlIG9mZnNldCBiYWNrXG5cdFx0XHRpZiAob2Zmc2V0ID49IGxvb3BFbmQpe1xuXHRcdFx0XHRvZmZzZXQgPSAoKG9mZnNldCAtIGxvb3BTdGFydCkgJSBsb29wRHVyYXRpb24pICsgbG9vcFN0YXJ0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9zb3VyY2UuYnVmZmVyID0gdGhpcy5idWZmZXIuZ2V0KCk7XG5cdFx0dGhpcy5fc291cmNlLmxvb3BFbmQgPSB0aGlzLmxvb3BFbmQgfHwgdGhpcy5idWZmZXIuZHVyYXRpb247XG5cdFx0aWYgKG9mZnNldCA8IHRoaXMuYnVmZmVyLmR1cmF0aW9uKXtcblx0XHRcdHRoaXMuX3NvdXJjZVN0YXJ0ZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy5fc291cmNlLnN0YXJ0KHRpbWUsIG9mZnNldCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqICBTdG9wIHRoZSBidWZmZXIuIE9wdGlvbmFsbHkgYWRkIGEgcmFtcCB0aW1lIHRvIGZhZGUgdGhlXG5cdCAqICBidWZmZXIgb3V0LlxuXHQgKiAgQHBhcmFtICB7VGltZT19ICB0aW1lICAgICAgICAgVGhlIHRpbWUgdGhlIGJ1ZmZlciBzaG91bGQgc3RvcC5cblx0ICogIEBwYXJhbSAge1RpbWU9fSAgZmFkZU91dFRpbWUgIEhvdyBsb25nIHRoZSBnYWluIHNob3VsZCBmYWRlIG91dCBmb3Jcblx0ICogIEByZXR1cm4gIHtUb25lLkJ1ZmZlclNvdXJjZX0gIHRoaXNcblx0ICovXG5cdFRvbmUuQnVmZmVyU291cmNlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24odGltZSwgZmFkZU91dFRpbWUpe1xuXHRcdGlmICghdGhpcy5idWZmZXIubG9hZGVkKXtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlRvbmUuQnVmZmVyU291cmNlOiBidWZmZXIgaXMgZWl0aGVyIG5vdCBzZXQgb3Igbm90IGxvYWRlZC5cIik7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3NvdXJjZVN0b3BwZWQpe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblxuXHRcdC8vaWYgdGhlIGV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gc2NoZWR1bGVkLCBjbGVhciBpdFxuXHRcdGlmICh0aGlzLl9zdG9wVGltZSAhPT0gLTEpe1xuXHRcdFx0dGhpcy5jYW5jZWxTdG9wKCk7XG5cdFx0fVxuXHRcdC8vc3RvcCBpZiBpdCdzIHNjaGVkdWxlIGJlZm9yZSB0aGUgc3RhcnQgdGltZVxuXHRcdGlmICh0aW1lIDw9IHRoaXMuX3N0YXJ0VGltZSl7XG5cdFx0XHR0aGlzLl9nYWluTm9kZS5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aW1lKTtcblx0XHRcdHRoaXMuX2dhaW5Ob2RlLmdhaW4udmFsdWUgPSAwO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dGltZSA9IE1hdGgubWF4KHRoaXMuX3N0YXJ0VGltZSArIHRoaXMuZmFkZUluICsgdGhpcy5zYW1wbGVUaW1lLCB0aW1lKTtcblx0XHQvL2NhbmNlbCB0aGUgcHJldmlvdXMgY3VydmVcblx0XHR0aGlzLl9nYWluTm9kZS5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aW1lKTtcblx0XHR0aGlzLl9zdG9wVGltZSA9IHRpbWU7XG5cblx0XHQvL3RoZSBmYWRlT3V0IHRpbWVcblx0XHRmYWRlT3V0VGltZSA9IHRoaXMudG9TZWNvbmRzKFRvbmUuZGVmYXVsdEFyZyhmYWRlT3V0VGltZSwgdGhpcy5mYWRlT3V0KSk7XG5cblx0XHR2YXIgaGVsZER1cmF0aW9uID0gdGltZSAtIHRoaXMuX3N0YXJ0VGltZSAtIHRoaXMuZmFkZUluIC0gdGhpcy5zYW1wbGVUaW1lO1xuXHRcdGlmICghdGhpcy5sb29wKXtcblx0XHRcdC8vbWFrZSBzdXJlIHRoZSBmYWRlIGRvZXMgbm90IGdvIGJleW9uZCB0aGUgbGVuZ3RoIG9mIHRoZSBidWZmZXJcblx0XHRcdGhlbGREdXJhdGlvbiA9IE1hdGgubWluKGhlbGREdXJhdGlvbiwgdGhpcy5idWZmZXIuZHVyYXRpb24pO1xuXHRcdH1cblx0XHRmYWRlT3V0VGltZSA9IE1hdGgubWluKGhlbGREdXJhdGlvbiwgZmFkZU91dFRpbWUpO1xuXHRcdHZhciBzdGFydEZhZGUgPSB0aW1lIC0gZmFkZU91dFRpbWU7XG5cdFx0aWYgKGZhZGVPdXRUaW1lID4gdGhpcy5zYW1wbGVUaW1lKXtcblx0XHRcdHRoaXMuX2dhaW5Ob2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUodGhpcy5fZ2Fpbiwgc3RhcnRGYWRlKTtcblx0XHRcdGlmICh0aGlzLmN1cnZlID09PSBcImxpbmVhclwiKXtcblx0XHRcdFx0dGhpcy5fZ2Fpbk5vZGUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLCB0aW1lKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2dhaW5Ob2RlLmdhaW4uZXhwb25lbnRpYWxBcHByb2FjaFZhbHVlQXRUaW1lKDAsIHN0YXJ0RmFkZSwgZmFkZU91dFRpbWUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9nYWluTm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKDAsIHRpbWUpO1xuXHRcdH1cblxuXHRcdFRvbmUuY29udGV4dC5jbGVhclRpbWVvdXQodGhpcy5fb25lbmRlZFRpbWVvdXQpO1xuXHRcdHRoaXMuX29uZW5kZWRUaW1lb3V0ID0gVG9uZS5jb250ZXh0LnNldFRpbWVvdXQodGhpcy5fb25lbmRlZC5iaW5kKHRoaXMpLCB0aGlzLl9zdG9wVGltZSAtIHRoaXMubm93KCkpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqICBDYW5jZWwgYSBzY2hlZHVsZWQgc3RvcCBldmVudFxuXHQgKiAgQHJldHVybiAge1RvbmUuQnVmZmVyU291cmNlfSAgdGhpc1xuXHQgKi9cblx0VG9uZS5CdWZmZXJTb3VyY2UucHJvdG90eXBlLmNhbmNlbFN0b3AgPSBmdW5jdGlvbigpe1xuXHRcdGlmICh0aGlzLl9zdGFydFRpbWUgIT09IC0xICYmICF0aGlzLl9zb3VyY2VTdG9wcGVkKXtcblx0XHRcdC8vY2FuY2VsIHRoZSBzdG9wIGVudmVsb3BlXG5cdFx0XHR2YXIgZmFkZUluVGltZSA9IHRoaXMudG9TZWNvbmRzKHRoaXMuZmFkZUluKTtcblx0XHRcdHRoaXMuX2dhaW5Ob2RlLmdhaW4uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRoaXMuX3N0YXJ0VGltZSArIGZhZGVJblRpbWUgKyB0aGlzLnNhbXBsZVRpbWUpO1xuXHRcdFx0dGhpcy5fZ2Fpbk5vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgxLCBNYXRoLm1heCh0aGlzLm5vdygpLCB0aGlzLl9zdGFydFRpbWUgKyBmYWRlSW5UaW1lKyB0aGlzLnNhbXBsZVRpbWUpKTtcblx0XHRcdHRoaXMuY29udGV4dC5jbGVhclRpbWVvdXQodGhpcy5fb25lbmRlZFRpbWVvdXQpO1xuXHRcdFx0dGhpcy5fc3RvcFRpbWUgPSAtMTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqICBJbnRlcm5hbCBjYWxsYmFjayB3aGVuIHRoZSBidWZmZXIgaXMgZW5kZWQuXG5cdCAqICBJbnZva2VzIGBvbmVuZGVkYCBhbmQgZGlzcG9zZXMgdGhlIG5vZGUuXG5cdCAqICBAcHJpdmF0ZVxuXHQgKi9cblx0VG9uZS5CdWZmZXJTb3VyY2UucHJvdG90eXBlLl9vbmVuZGVkID0gZnVuY3Rpb24oKXtcblx0XHRpZiAoIXRoaXMuX3NvdXJjZVN0b3BwZWQpe1xuXHRcdFx0dGhpcy5fc291cmNlU3RvcHBlZCA9IHRydWU7XG5cdFx0XHQvL2FsbG93IGFkZGl0aW9uYWwgdGltZSBmb3IgdGhlIGV4cG9uZW50aWFsIGN1cnZlIHRvIGZ1bGx5IGRlY2F5XG5cdFx0XHR2YXIgYWRkaXRpb25hbFRhaWwgPSB0aGlzLmN1cnZlID09PSBcImV4cG9uZW50aWFsXCIgPyB0aGlzLmZhZGVPdXQgKiAyIDogMDtcblx0XHRcdGlmICh0aGlzLl9zb3VyY2VTdGFydGVkICYmIHRoaXMuX3N0b3BUaW1lICE9PSAtMSl7XG5cdFx0XHRcdHRoaXMuX3NvdXJjZS5zdG9wKHRoaXMuX3N0b3BUaW1lICsgYWRkaXRpb25hbFRhaWwpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5vbmVuZGVkKHRoaXMpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogSWYgbG9vcCBpcyB0cnVlLCB0aGUgbG9vcCB3aWxsIHN0YXJ0IGF0IHRoaXMgcG9zaXRpb24uXG5cdCAqIEBtZW1iZXJPZiBUb25lLkJ1ZmZlclNvdXJjZSNcblx0ICogQHR5cGUge1RpbWV9XG5cdCAqIEBuYW1lIGxvb3BTdGFydFxuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQnVmZmVyU291cmNlLnByb3RvdHlwZSwgXCJsb29wU3RhcnRcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc291cmNlLmxvb3BTdGFydDtcblx0XHR9LFxuXHRcdHNldCA6IGZ1bmN0aW9uKGxvb3BTdGFydCl7XG5cdFx0XHR0aGlzLl9zb3VyY2UubG9vcFN0YXJ0ID0gdGhpcy50b1NlY29uZHMobG9vcFN0YXJ0KTtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBJZiBsb29wIGlzIHRydWUsIHRoZSBsb29wIHdpbGwgZW5kIGF0IHRoaXMgcG9zaXRpb24uXG5cdCAqIEBtZW1iZXJPZiBUb25lLkJ1ZmZlclNvdXJjZSNcblx0ICogQHR5cGUge1RpbWV9XG5cdCAqIEBuYW1lIGxvb3BFbmRcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlclNvdXJjZS5wcm90b3R5cGUsIFwibG9vcEVuZFwiLCB7XG5cdFx0Z2V0IDogZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiB0aGlzLl9zb3VyY2UubG9vcEVuZDtcblx0XHR9LFxuXHRcdHNldCA6IGZ1bmN0aW9uKGxvb3BFbmQpe1xuXHRcdFx0dGhpcy5fc291cmNlLmxvb3BFbmQgPSB0aGlzLnRvU2Vjb25kcyhsb29wRW5kKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBUaGUgYXVkaW8gYnVmZmVyIGJlbG9uZ2luZyB0byB0aGUgcGxheWVyLlxuXHQgKiBAbWVtYmVyT2YgVG9uZS5CdWZmZXJTb3VyY2UjXG5cdCAqIEB0eXBlIHtUb25lLkJ1ZmZlcn1cblx0ICogQG5hbWUgYnVmZmVyXG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5CdWZmZXJTb3VyY2UucHJvdG90eXBlLCBcImJ1ZmZlclwiLCB7XG5cdFx0Z2V0IDogZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiB0aGlzLl9idWZmZXI7XG5cdFx0fSxcblx0XHRzZXQgOiBmdW5jdGlvbihidWZmZXIpe1xuXHRcdFx0dGhpcy5fYnVmZmVyLnNldChidWZmZXIpO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIElmIHRoZSBidWZmZXIgc2hvdWxkIGxvb3Agb25jZSBpdCdzIG92ZXIuXG5cdCAqIEBtZW1iZXJPZiBUb25lLkJ1ZmZlclNvdXJjZSNcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBuYW1lIGxvb3Bcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlclNvdXJjZS5wcm90b3R5cGUsIFwibG9vcFwiLCB7XG5cdFx0Z2V0IDogZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiB0aGlzLl9zb3VyY2UubG9vcDtcblx0XHR9LFxuXHRcdHNldCA6IGZ1bmN0aW9uKGxvb3Ape1xuXHRcdFx0dGhpcy5fc291cmNlLmxvb3AgPSBsb29wO1xuXHRcdFx0dGhpcy5jYW5jZWxTdG9wKCk7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogIENsZWFuIHVwLlxuXHQgKiAgQHJldHVybiAge1RvbmUuQnVmZmVyU291cmNlfSAgdGhpc1xuXHQgKi9cblx0VG9uZS5CdWZmZXJTb3VyY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpe1xuXHRcdFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5vbmVuZGVkID0gbnVsbDtcblx0XHR0aGlzLl9zb3VyY2Uub25lbmRlZCA9IG51bGw7XG5cdFx0dGhpcy5fc291cmNlLmRpc2Nvbm5lY3QoKTtcblx0XHR0aGlzLl9zb3VyY2UgPSBudWxsO1xuXHRcdHRoaXMuX2dhaW5Ob2RlLmRpc3Bvc2UoKTtcblx0XHR0aGlzLl9nYWluTm9kZSA9IG51bGw7XG5cdFx0dGhpcy5fYnVmZmVyLmRpc3Bvc2UoKTtcblx0XHR0aGlzLl9idWZmZXIgPSBudWxsO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IC0xO1xuXHRcdHRoaXMucGxheWJhY2tSYXRlID0gbnVsbDtcblx0XHRUb25lLmNvbnRleHQuY2xlYXJUaW1lb3V0KHRoaXMuX29uZW5kZWRUaW1lb3V0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHRyZXR1cm4gVG9uZS5CdWZmZXJTb3VyY2U7XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFHQTs7Ozs7OztBQU9BO0FBRUE7QUFDQTtBQUVBOzs7Ozs7QUFLQTtBQUVBOzs7Ozs7QUFLQTtBQUVBOzs7Ozs7OztBQU9BO0FBRUE7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBRUE7Ozs7O0FBSUE7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFZQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBREE7QUFNQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUpBO0FBU0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFKQTtBQVNBOzs7Ozs7O0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBSkE7QUFTQTs7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUFBO0FBSkE7QUFVQTs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/source/BufferSource.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/source/Source.js":
/*!*************************************************!*\
  !*** ./node_modules/tone/Tone/source/Source.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/core/Transport */ \"./node_modules/tone/Tone/core/Transport.js\"), __webpack_require__(/*! Tone/component/Volume */ \"./node_modules/tone/Tone/component/Volume.js\"), __webpack_require__(/*! Tone/core/Master */ \"./node_modules/tone/Tone/core/Master.js\"), __webpack_require__(/*! Tone/type/Type */ \"./node_modules/tone/Tone/type/Type.js\"), __webpack_require__(/*! Tone/core/TimelineState */ \"./node_modules/tone/Tone/core/TimelineState.js\"), __webpack_require__(/*! Tone/signal/Signal */ \"./node_modules/tone/Tone/signal/Signal.js\"), __webpack_require__(/*! Tone/core/AudioNode */ \"./node_modules/tone/Tone/core/AudioNode.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  \"use strict\";\n  /**\n   *  @class  Base class for sources. Sources have start/stop methods\n   *          and the ability to be synced to the\n   *          start/stop of Tone.Transport.\n   *\n   *  @constructor\n   *  @extends {Tone.AudioNode}\n   *  @example\n   * //Multiple state change events can be chained together,\n   * //but must be set in the correct order and with ascending times\n   *\n   * // OK\n   * state.start().stop(\"+0.2\");\n   * // AND\n   * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n   *\n   * // BAD\n   * state.stop(\"+0.2\").start();\n   * // OR\n   * state.start(\"+0.3\").stop(\"+0.2\");\n   *\n   */\n\n  Tone.Source = function (options) {\n    options = Tone.defaultArg(options, Tone.Source.defaults);\n    Tone.AudioNode.call(this);\n    /**\n     *  The output volume node\n     *  @type  {Tone.Volume}\n     *  @private\n     */\n\n    this._volume = this.output = new Tone.Volume(options.volume);\n    /**\n     * The volume of the output in decibels.\n     * @type {Decibels}\n     * @signal\n     * @example\n     * source.volume.value = -6;\n     */\n\n    this.volume = this._volume.volume;\n\n    this._readOnly(\"volume\");\n    /**\n     * \tKeep track of the scheduled state.\n     *  @type {Tone.TimelineState}\n     *  @private\n     */\n\n\n    this._state = new Tone.TimelineState(Tone.State.Stopped);\n    this._state.memory = 100;\n    /**\n     *  The synced `start` callback function from the transport\n     *  @type {Function}\n     *  @private\n     */\n\n    this._synced = false;\n    /**\n     *  Keep track of all of the scheduled event ids\n     *  @type  {Array}\n     *  @private\n     */\n\n    this._scheduled = []; //make the output explicitly stereo\n\n    this._volume.output.output.channelCount = 2;\n    this._volume.output.output.channelCountMode = \"explicit\"; //mute initially\n\n    this.mute = options.mute;\n  };\n\n  Tone.extend(Tone.Source, Tone.AudioNode);\n  /**\n   *  The default parameters\n   *  @static\n   *  @const\n   *  @type {Object}\n   */\n\n  Tone.Source.defaults = {\n    \"volume\": 0,\n    \"mute\": false\n  };\n  /**\n   *  Returns the playback state of the source, either \"started\" or \"stopped\".\n   *  @type {Tone.State}\n   *  @readOnly\n   *  @memberOf Tone.Source#\n   *  @name state\n   */\n\n  Object.defineProperty(Tone.Source.prototype, \"state\", {\n    get: function () {\n      function get() {\n        if (this._synced) {\n          if (Tone.Transport.state === Tone.State.Started) {\n            return this._state.getValueAtTime(Tone.Transport.seconds);\n          } else {\n            return Tone.State.Stopped;\n          }\n        } else {\n          return this._state.getValueAtTime(this.now());\n        }\n      }\n\n      return get;\n    }()\n  });\n  /**\n   * Mute the output.\n   * @memberOf Tone.Source#\n   * @type {boolean}\n   * @name mute\n   * @example\n   * //mute the output\n   * source.mute = true;\n   */\n\n  Object.defineProperty(Tone.Source.prototype, \"mute\", {\n    get: function () {\n      function get() {\n        return this._volume.mute;\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(mute) {\n        this._volume.mute = mute;\n      }\n\n      return set;\n    }()\n  }); //overwrite these functions\n\n  Tone.Source.prototype._start = Tone.noOp;\n  Tone.Source.prototype.restart = Tone.noOp;\n  Tone.Source.prototype._stop = Tone.noOp;\n  /**\n   *  Start the source at the specified time. If no time is given,\n   *  start the source now.\n   *  @param  {Time} [time=now] When the source should be started.\n   *  @returns {Tone.Source} this\n   *  @example\n   * source.start(\"+0.5\"); //starts the source 0.5 seconds from now\n   */\n\n  Tone.Source.prototype.start = function (time, offset, duration) {\n    if (Tone.isUndef(time) && this._synced) {\n      time = Tone.Transport.seconds;\n    } else {\n      time = this.toSeconds(time);\n    } //if it's started, stop it and restart it\n\n\n    if (this._state.getValueAtTime(time) === Tone.State.Started) {\n      this._state.cancel(time);\n\n      this._state.setStateAtTime(Tone.State.Started, time);\n\n      this.restart(time, offset, duration);\n    } else {\n      this._state.setStateAtTime(Tone.State.Started, time);\n\n      if (this._synced) {\n        // add the offset time to the event\n        var event = this._state.get(time);\n\n        event.offset = Tone.defaultArg(offset, 0);\n        event.duration = duration;\n        var sched = Tone.Transport.schedule(function (t) {\n          this._start(t, offset, duration);\n        }.bind(this), time);\n\n        this._scheduled.push(sched); //if it's already started\n\n\n        if (Tone.Transport.state === Tone.State.Started) {\n          this._syncedStart(this.now(), Tone.Transport.seconds);\n        }\n      } else {\n        this._start.apply(this, arguments);\n      }\n    }\n\n    return this;\n  };\n  /**\n   *  Stop the source at the specified time. If no time is given,\n   *  stop the source now.\n   *  @param  {Time} [time=now] When the source should be stopped.\n   *  @returns {Tone.Source} this\n   *  @example\n   * source.stop(); // stops the source immediately\n   */\n\n\n  Tone.Source.prototype.stop = function (time) {\n    if (Tone.isUndef(time) && this._synced) {\n      time = Tone.Transport.seconds;\n    } else {\n      time = this.toSeconds(time);\n    }\n\n    if (!this._synced) {\n      this._stop.apply(this, arguments);\n    } else {\n      var sched = Tone.Transport.schedule(this._stop.bind(this), time);\n\n      this._scheduled.push(sched);\n    }\n\n    this._state.cancel(time);\n\n    this._state.setStateAtTime(Tone.State.Stopped, time);\n\n    return this;\n  };\n  /**\n   *  Sync the source to the Transport so that all subsequent\n   *  calls to `start` and `stop` are synced to the TransportTime\n   *  instead of the AudioContext time.\n   *\n   *  @returns {Tone.Source} this\n   *  @example\n   * //sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n   * source.sync().start(0).stop(0.3);\n   * //start the transport.\n   * Tone.Transport.start();\n   *\n   *  @example\n   * //start the transport with an offset and the sync'ed sources\n   * //will start in the correct position\n   * source.sync().start(0.1);\n   * //the source will be invoked with an offset of 0.4\n   * Tone.Transport.start(\"+0.5\", 0.5);\n   */\n\n\n  Tone.Source.prototype.sync = function () {\n    this._synced = true;\n\n    this._syncedStart = function (time, offset) {\n      if (offset > 0) {\n        // get the playback state at that time\n        var stateEvent = this._state.get(offset); // listen for start events which may occur in the middle of the sync'ed time\n\n\n        if (stateEvent && stateEvent.state === Tone.State.Started && stateEvent.time !== offset) {\n          // get the offset\n          var startOffset = offset - this.toSeconds(stateEvent.time);\n          var duration;\n\n          if (stateEvent.duration) {\n            duration = this.toSeconds(stateEvent.duration) - startOffset;\n          }\n\n          this._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n        }\n      }\n    }.bind(this);\n\n    this._syncedStop = function (time) {\n      var seconds = Tone.Transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n\n      if (this._state.getValueAtTime(seconds) === Tone.State.Started) {\n        this._stop(time);\n      }\n    }.bind(this);\n\n    Tone.Transport.on(\"start loopStart\", this._syncedStart);\n    Tone.Transport.on(\"stop pause loopEnd\", this._syncedStop);\n    return this;\n  };\n  /**\n   *  Unsync the source to the Transport. See Tone.Source.sync\n   *  @returns {Tone.Source} this\n   */\n\n\n  Tone.Source.prototype.unsync = function () {\n    if (this._synced) {\n      Tone.Transport.off(\"stop pause loopEnd\", this._syncedStop);\n      Tone.Transport.off(\"start loopStart\", this._syncedStart);\n    }\n\n    this._synced = false; // clear all of the scheduled ids\n\n    for (var i = 0; i < this._scheduled.length; i++) {\n      var id = this._scheduled[i];\n      Tone.Transport.clear(id);\n    }\n\n    this._scheduled = [];\n\n    this._state.cancel(0);\n\n    return this;\n  };\n  /**\n   *\tClean up.\n   *  @return {Tone.Source} this\n   */\n\n\n  Tone.Source.prototype.dispose = function () {\n    Tone.AudioNode.prototype.dispose.call(this);\n    this.unsync();\n    this._scheduled = null;\n\n    this._writable(\"volume\");\n\n    this._volume.dispose();\n\n    this._volume = null;\n    this.volume = null;\n\n    this._state.dispose();\n\n    this._state = null;\n  };\n\n  return Tone.Source;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3NvdXJjZS9Tb3VyY2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3NvdXJjZS9Tb3VyY2UuanM/MDE1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoW1wiVG9uZS9jb3JlL1RvbmVcIiwgXCJUb25lL2NvcmUvVHJhbnNwb3J0XCIsIFwiVG9uZS9jb21wb25lbnQvVm9sdW1lXCIsIFwiVG9uZS9jb3JlL01hc3RlclwiLCBcIlRvbmUvdHlwZS9UeXBlXCIsXG5cdFwiVG9uZS9jb3JlL1RpbWVsaW5lU3RhdGVcIiwgXCJUb25lL3NpZ25hbC9TaWduYWxcIiwgXCJUb25lL2NvcmUvQXVkaW9Ob2RlXCJdLCBmdW5jdGlvbihUb25lKXtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogIEBjbGFzcyAgQmFzZSBjbGFzcyBmb3Igc291cmNlcy4gU291cmNlcyBoYXZlIHN0YXJ0L3N0b3AgbWV0aG9kc1xuXHQgKiAgICAgICAgICBhbmQgdGhlIGFiaWxpdHkgdG8gYmUgc3luY2VkIHRvIHRoZVxuXHQgKiAgICAgICAgICBzdGFydC9zdG9wIG9mIFRvbmUuVHJhbnNwb3J0LlxuXHQgKlxuXHQgKiAgQGNvbnN0cnVjdG9yXG5cdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdCAqICBAZXhhbXBsZVxuXHQgKiAvL011bHRpcGxlIHN0YXRlIGNoYW5nZSBldmVudHMgY2FuIGJlIGNoYWluZWQgdG9nZXRoZXIsXG5cdCAqIC8vYnV0IG11c3QgYmUgc2V0IGluIHRoZSBjb3JyZWN0IG9yZGVyIGFuZCB3aXRoIGFzY2VuZGluZyB0aW1lc1xuXHQgKlxuXHQgKiAvLyBPS1xuXHQgKiBzdGF0ZS5zdGFydCgpLnN0b3AoXCIrMC4yXCIpO1xuXHQgKiAvLyBBTkRcblx0ICogc3RhdGUuc3RhcnQoKS5zdG9wKFwiKzAuMlwiKS5zdGFydChcIiswLjRcIikuc3RvcChcIiswLjdcIilcblx0ICpcblx0ICogLy8gQkFEXG5cdCAqIHN0YXRlLnN0b3AoXCIrMC4yXCIpLnN0YXJ0KCk7XG5cdCAqIC8vIE9SXG5cdCAqIHN0YXRlLnN0YXJ0KFwiKzAuM1wiKS5zdG9wKFwiKzAuMlwiKTtcblx0ICpcblx0ICovXG5cdFRvbmUuU291cmNlID0gZnVuY3Rpb24ob3B0aW9ucyl7XG5cblx0XHRvcHRpb25zID0gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMsIFRvbmUuU291cmNlLmRlZmF1bHRzKTtcblx0XHRUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXG5cdFx0LyoqXG5cdFx0ICogIFRoZSBvdXRwdXQgdm9sdW1lIG5vZGVcblx0XHQgKiAgQHR5cGUgIHtUb25lLlZvbHVtZX1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl92b2x1bWUgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLlZvbHVtZShvcHRpb25zLnZvbHVtZSk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdm9sdW1lIG9mIHRoZSBvdXRwdXQgaW4gZGVjaWJlbHMuXG5cdFx0ICogQHR5cGUge0RlY2liZWxzfVxuXHRcdCAqIEBzaWduYWxcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIHNvdXJjZS52b2x1bWUudmFsdWUgPSAtNjtcblx0XHQgKi9cblx0XHR0aGlzLnZvbHVtZSA9IHRoaXMuX3ZvbHVtZS52b2x1bWU7XG5cdFx0dGhpcy5fcmVhZE9ubHkoXCJ2b2x1bWVcIik7XG5cblx0XHQvKipcblx0XHQgKiBcdEtlZXAgdHJhY2sgb2YgdGhlIHNjaGVkdWxlZCBzdGF0ZS5cblx0XHQgKiAgQHR5cGUge1RvbmUuVGltZWxpbmVTdGF0ZX1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9zdGF0ZSA9IG5ldyBUb25lLlRpbWVsaW5lU3RhdGUoVG9uZS5TdGF0ZS5TdG9wcGVkKTtcblx0XHR0aGlzLl9zdGF0ZS5tZW1vcnkgPSAxMDA7XG5cblx0XHQvKipcblx0XHQgKiAgVGhlIHN5bmNlZCBgc3RhcnRgIGNhbGxiYWNrIGZ1bmN0aW9uIGZyb20gdGhlIHRyYW5zcG9ydFxuXHRcdCAqICBAdHlwZSB7RnVuY3Rpb259XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fc3luY2VkID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiAgS2VlcCB0cmFjayBvZiBhbGwgb2YgdGhlIHNjaGVkdWxlZCBldmVudCBpZHNcblx0XHQgKiAgQHR5cGUgIHtBcnJheX1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9zY2hlZHVsZWQgPSBbXTtcblxuXHRcdC8vbWFrZSB0aGUgb3V0cHV0IGV4cGxpY2l0bHkgc3RlcmVvXG5cdFx0dGhpcy5fdm9sdW1lLm91dHB1dC5vdXRwdXQuY2hhbm5lbENvdW50ID0gMjtcblx0XHR0aGlzLl92b2x1bWUub3V0cHV0Lm91dHB1dC5jaGFubmVsQ291bnRNb2RlID0gXCJleHBsaWNpdFwiO1xuXHRcdC8vbXV0ZSBpbml0aWFsbHlcblx0XHR0aGlzLm11dGUgPSBvcHRpb25zLm11dGU7XG5cdH07XG5cblx0VG9uZS5leHRlbmQoVG9uZS5Tb3VyY2UsIFRvbmUuQXVkaW9Ob2RlKTtcblxuXHQvKipcblx0ICogIFRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcblx0ICogIEBzdGF0aWNcblx0ICogIEBjb25zdFxuXHQgKiAgQHR5cGUge09iamVjdH1cblx0ICovXG5cdFRvbmUuU291cmNlLmRlZmF1bHRzID0ge1xuXHRcdFwidm9sdW1lXCIgOiAwLFxuXHRcdFwibXV0ZVwiIDogZmFsc2Vcblx0fTtcblxuXHQvKipcblx0ICogIFJldHVybnMgdGhlIHBsYXliYWNrIHN0YXRlIG9mIHRoZSBzb3VyY2UsIGVpdGhlciBcInN0YXJ0ZWRcIiBvciBcInN0b3BwZWRcIi5cblx0ICogIEB0eXBlIHtUb25lLlN0YXRlfVxuXHQgKiAgQHJlYWRPbmx5XG5cdCAqICBAbWVtYmVyT2YgVG9uZS5Tb3VyY2UjXG5cdCAqICBAbmFtZSBzdGF0ZVxuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU291cmNlLnByb3RvdHlwZSwgXCJzdGF0ZVwiLCB7XG5cdFx0Z2V0IDogZnVuY3Rpb24oKXtcblx0XHRcdGlmICh0aGlzLl9zeW5jZWQpe1xuXHRcdFx0XHRpZiAoVG9uZS5UcmFuc3BvcnQuc3RhdGUgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCl7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX3N0YXRlLmdldFZhbHVlQXRUaW1lKFRvbmUuVHJhbnNwb3J0LnNlY29uZHMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBUb25lLlN0YXRlLlN0b3BwZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aGlzLm5vdygpKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBNdXRlIHRoZSBvdXRwdXQuXG5cdCAqIEBtZW1iZXJPZiBUb25lLlNvdXJjZSNcblx0ICogQHR5cGUge2Jvb2xlYW59XG5cdCAqIEBuYW1lIG11dGVcblx0ICogQGV4YW1wbGVcblx0ICogLy9tdXRlIHRoZSBvdXRwdXRcblx0ICogc291cmNlLm11dGUgPSB0cnVlO1xuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU291cmNlLnByb3RvdHlwZSwgXCJtdXRlXCIsIHtcblx0XHRnZXQgOiBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX3ZvbHVtZS5tdXRlO1xuXHRcdH0sXG5cdFx0c2V0IDogZnVuY3Rpb24obXV0ZSl7XG5cdFx0XHR0aGlzLl92b2x1bWUubXV0ZSA9IG11dGU7XG5cdFx0fVxuXHR9KTtcblxuXHQvL292ZXJ3cml0ZSB0aGVzZSBmdW5jdGlvbnNcblx0VG9uZS5Tb3VyY2UucHJvdG90eXBlLl9zdGFydCA9IFRvbmUubm9PcDtcblx0VG9uZS5Tb3VyY2UucHJvdG90eXBlLnJlc3RhcnQgPSBUb25lLm5vT3A7XG5cdFRvbmUuU291cmNlLnByb3RvdHlwZS5fc3RvcCA9IFRvbmUubm9PcDtcblxuXHQvKipcblx0ICogIFN0YXJ0IHRoZSBzb3VyY2UgYXQgdGhlIHNwZWNpZmllZCB0aW1lLiBJZiBubyB0aW1lIGlzIGdpdmVuLFxuXHQgKiAgc3RhcnQgdGhlIHNvdXJjZSBub3cuXG5cdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddIFdoZW4gdGhlIHNvdXJjZSBzaG91bGQgYmUgc3RhcnRlZC5cblx0ICogIEByZXR1cm5zIHtUb25lLlNvdXJjZX0gdGhpc1xuXHQgKiAgQGV4YW1wbGVcblx0ICogc291cmNlLnN0YXJ0KFwiKzAuNVwiKTsgLy9zdGFydHMgdGhlIHNvdXJjZSAwLjUgc2Vjb25kcyBmcm9tIG5vd1xuXHQgKi9cblx0VG9uZS5Tb3VyY2UucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24odGltZSwgb2Zmc2V0LCBkdXJhdGlvbil7XG5cdFx0aWYgKFRvbmUuaXNVbmRlZih0aW1lKSAmJiB0aGlzLl9zeW5jZWQpe1xuXHRcdFx0dGltZSA9IFRvbmUuVHJhbnNwb3J0LnNlY29uZHM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0XHR9XG5cdFx0Ly9pZiBpdCdzIHN0YXJ0ZWQsIHN0b3AgaXQgYW5kIHJlc3RhcnQgaXRcblx0XHRpZiAodGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodGltZSkgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCl7XG5cdFx0XHR0aGlzLl9zdGF0ZS5jYW5jZWwodGltZSk7XG5cdFx0XHR0aGlzLl9zdGF0ZS5zZXRTdGF0ZUF0VGltZShUb25lLlN0YXRlLlN0YXJ0ZWQsIHRpbWUpO1xuXHRcdFx0dGhpcy5yZXN0YXJ0KHRpbWUsIG9mZnNldCwgZHVyYXRpb24pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zdGF0ZS5zZXRTdGF0ZUF0VGltZShUb25lLlN0YXRlLlN0YXJ0ZWQsIHRpbWUpO1xuXHRcdFx0aWYgKHRoaXMuX3N5bmNlZCl7XG5cdFx0XHRcdC8vIGFkZCB0aGUgb2Zmc2V0IHRpbWUgdG8gdGhlIGV2ZW50XG5cdFx0XHRcdHZhciBldmVudCA9IHRoaXMuX3N0YXRlLmdldCh0aW1lKTtcblx0XHRcdFx0ZXZlbnQub2Zmc2V0ID0gVG9uZS5kZWZhdWx0QXJnKG9mZnNldCwgMCk7XG5cdFx0XHRcdGV2ZW50LmR1cmF0aW9uID0gZHVyYXRpb247XG5cdFx0XHRcdHZhciBzY2hlZCA9IFRvbmUuVHJhbnNwb3J0LnNjaGVkdWxlKGZ1bmN0aW9uKHQpe1xuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0KHQsIG9mZnNldCwgZHVyYXRpb24pO1xuXHRcdFx0XHR9LmJpbmQodGhpcyksIHRpbWUpO1xuXHRcdFx0XHR0aGlzLl9zY2hlZHVsZWQucHVzaChzY2hlZCk7XG5cblx0XHRcdFx0Ly9pZiBpdCdzIGFscmVhZHkgc3RhcnRlZFxuXHRcdFx0XHRpZiAoVG9uZS5UcmFuc3BvcnQuc3RhdGUgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCl7XG5cdFx0XHRcdFx0dGhpcy5fc3luY2VkU3RhcnQodGhpcy5ub3coKSwgVG9uZS5UcmFuc3BvcnQuc2Vjb25kcyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3N0YXJ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgU3RvcCB0aGUgc291cmNlIGF0IHRoZSBzcGVjaWZpZWQgdGltZS4gSWYgbm8gdGltZSBpcyBnaXZlbixcblx0ICogIHN0b3AgdGhlIHNvdXJjZSBub3cuXG5cdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddIFdoZW4gdGhlIHNvdXJjZSBzaG91bGQgYmUgc3RvcHBlZC5cblx0ICogIEByZXR1cm5zIHtUb25lLlNvdXJjZX0gdGhpc1xuXHQgKiAgQGV4YW1wbGVcblx0ICogc291cmNlLnN0b3AoKTsgLy8gc3RvcHMgdGhlIHNvdXJjZSBpbW1lZGlhdGVseVxuXHQgKi9cblx0VG9uZS5Tb3VyY2UucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbih0aW1lKXtcblx0XHRpZiAoVG9uZS5pc1VuZGVmKHRpbWUpICYmIHRoaXMuX3N5bmNlZCl7XG5cdFx0XHR0aW1lID0gVG9uZS5UcmFuc3BvcnQuc2Vjb25kcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHRcdH1cblx0XHRpZiAoIXRoaXMuX3N5bmNlZCl7XG5cdFx0XHR0aGlzLl9zdG9wLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBzY2hlZCA9IFRvbmUuVHJhbnNwb3J0LnNjaGVkdWxlKHRoaXMuX3N0b3AuYmluZCh0aGlzKSwgdGltZSk7XG5cdFx0XHR0aGlzLl9zY2hlZHVsZWQucHVzaChzY2hlZCk7XG5cdFx0fVxuXHRcdHRoaXMuX3N0YXRlLmNhbmNlbCh0aW1lKTtcblx0XHR0aGlzLl9zdGF0ZS5zZXRTdGF0ZUF0VGltZShUb25lLlN0YXRlLlN0b3BwZWQsIHRpbWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgU3luYyB0aGUgc291cmNlIHRvIHRoZSBUcmFuc3BvcnQgc28gdGhhdCBhbGwgc3Vic2VxdWVudFxuXHQgKiAgY2FsbHMgdG8gYHN0YXJ0YCBhbmQgYHN0b3BgIGFyZSBzeW5jZWQgdG8gdGhlIFRyYW5zcG9ydFRpbWVcblx0ICogIGluc3RlYWQgb2YgdGhlIEF1ZGlvQ29udGV4dCB0aW1lLlxuXHQgKlxuXHQgKiAgQHJldHVybnMge1RvbmUuU291cmNlfSB0aGlzXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAvL3N5bmMgdGhlIHNvdXJjZSBzbyB0aGF0IGl0IHBsYXlzIGJldHdlZW4gMCBhbmQgMC4zIG9uIHRoZSBUcmFuc3BvcnQncyB0aW1lbGluZVxuXHQgKiBzb3VyY2Uuc3luYygpLnN0YXJ0KDApLnN0b3AoMC4zKTtcblx0ICogLy9zdGFydCB0aGUgdHJhbnNwb3J0LlxuXHQgKiBUb25lLlRyYW5zcG9ydC5zdGFydCgpO1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogLy9zdGFydCB0aGUgdHJhbnNwb3J0IHdpdGggYW4gb2Zmc2V0IGFuZCB0aGUgc3luYydlZCBzb3VyY2VzXG5cdCAqIC8vd2lsbCBzdGFydCBpbiB0aGUgY29ycmVjdCBwb3NpdGlvblxuXHQgKiBzb3VyY2Uuc3luYygpLnN0YXJ0KDAuMSk7XG5cdCAqIC8vdGhlIHNvdXJjZSB3aWxsIGJlIGludm9rZWQgd2l0aCBhbiBvZmZzZXQgb2YgMC40XG5cdCAqIFRvbmUuVHJhbnNwb3J0LnN0YXJ0KFwiKzAuNVwiLCAwLjUpO1xuXHQgKi9cblx0VG9uZS5Tb3VyY2UucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbigpe1xuXHRcdHRoaXMuX3N5bmNlZCA9IHRydWU7XG5cdFx0dGhpcy5fc3luY2VkU3RhcnQgPSBmdW5jdGlvbih0aW1lLCBvZmZzZXQpe1xuXHRcdFx0aWYgKG9mZnNldCA+IDApe1xuXHRcdFx0XHQvLyBnZXQgdGhlIHBsYXliYWNrIHN0YXRlIGF0IHRoYXQgdGltZVxuXHRcdFx0XHR2YXIgc3RhdGVFdmVudCA9IHRoaXMuX3N0YXRlLmdldChvZmZzZXQpO1xuXHRcdFx0XHQvLyBsaXN0ZW4gZm9yIHN0YXJ0IGV2ZW50cyB3aGljaCBtYXkgb2NjdXIgaW4gdGhlIG1pZGRsZSBvZiB0aGUgc3luYydlZCB0aW1lXG5cdFx0XHRcdGlmIChzdGF0ZUV2ZW50ICYmIHN0YXRlRXZlbnQuc3RhdGUgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCAmJiBzdGF0ZUV2ZW50LnRpbWUgIT09IG9mZnNldCl7XG5cdFx0XHRcdFx0Ly8gZ2V0IHRoZSBvZmZzZXRcblx0XHRcdFx0XHR2YXIgc3RhcnRPZmZzZXQgPSBvZmZzZXQgLSB0aGlzLnRvU2Vjb25kcyhzdGF0ZUV2ZW50LnRpbWUpO1xuXHRcdFx0XHRcdHZhciBkdXJhdGlvbjtcblx0XHRcdFx0XHRpZiAoc3RhdGVFdmVudC5kdXJhdGlvbil7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbiA9IHRoaXMudG9TZWNvbmRzKHN0YXRlRXZlbnQuZHVyYXRpb24pIC0gc3RhcnRPZmZzZXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0KHRpbWUsIHRoaXMudG9TZWNvbmRzKHN0YXRlRXZlbnQub2Zmc2V0KSArIHN0YXJ0T2Zmc2V0LCBkdXJhdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LmJpbmQodGhpcyk7XG5cdFx0dGhpcy5fc3luY2VkU3RvcCA9IGZ1bmN0aW9uKHRpbWUpe1xuXHRcdFx0dmFyIHNlY29uZHMgPSBUb25lLlRyYW5zcG9ydC5nZXRTZWNvbmRzQXRUaW1lKE1hdGgubWF4KHRpbWUgLSB0aGlzLnNhbXBsZVRpbWUsIDApKTtcblx0XHRcdGlmICh0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZShzZWNvbmRzKSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKXtcblx0XHRcdFx0dGhpcy5fc3RvcCh0aW1lKTtcblx0XHRcdH1cblx0XHR9LmJpbmQodGhpcyk7XG5cdFx0VG9uZS5UcmFuc3BvcnQub24oXCJzdGFydCBsb29wU3RhcnRcIiwgdGhpcy5fc3luY2VkU3RhcnQpO1xuXHRcdFRvbmUuVHJhbnNwb3J0Lm9uKFwic3RvcCBwYXVzZSBsb29wRW5kXCIsIHRoaXMuX3N5bmNlZFN0b3ApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgVW5zeW5jIHRoZSBzb3VyY2UgdG8gdGhlIFRyYW5zcG9ydC4gU2VlIFRvbmUuU291cmNlLnN5bmNcblx0ICogIEByZXR1cm5zIHtUb25lLlNvdXJjZX0gdGhpc1xuXHQgKi9cblx0VG9uZS5Tb3VyY2UucHJvdG90eXBlLnVuc3luYyA9IGZ1bmN0aW9uKCl7XG5cdFx0aWYgKHRoaXMuX3N5bmNlZCl7XG5cdFx0XHRUb25lLlRyYW5zcG9ydC5vZmYoXCJzdG9wIHBhdXNlIGxvb3BFbmRcIiwgdGhpcy5fc3luY2VkU3RvcCk7XG5cdFx0XHRUb25lLlRyYW5zcG9ydC5vZmYoXCJzdGFydCBsb29wU3RhcnRcIiwgdGhpcy5fc3luY2VkU3RhcnQpO1xuXHRcdH1cblx0XHR0aGlzLl9zeW5jZWQgPSBmYWxzZTtcblx0XHQvLyBjbGVhciBhbGwgb2YgdGhlIHNjaGVkdWxlZCBpZHNcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NjaGVkdWxlZC5sZW5ndGg7IGkrKyl7XG5cdFx0XHR2YXIgaWQgPSB0aGlzLl9zY2hlZHVsZWRbaV07XG5cdFx0XHRUb25lLlRyYW5zcG9ydC5jbGVhcihpZCk7XG5cdFx0fVxuXHRcdHRoaXMuX3NjaGVkdWxlZCA9IFtdO1xuXHRcdHRoaXMuX3N0YXRlLmNhbmNlbCgwKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICpcdENsZWFuIHVwLlxuXHQgKiAgQHJldHVybiB7VG9uZS5Tb3VyY2V9IHRoaXNcblx0ICovXG5cdFRvbmUuU291cmNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKXtcblx0XHRUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMudW5zeW5jKCk7XG5cdFx0dGhpcy5fc2NoZWR1bGVkID0gbnVsbDtcblx0XHR0aGlzLl93cml0YWJsZShcInZvbHVtZVwiKTtcblx0XHR0aGlzLl92b2x1bWUuZGlzcG9zZSgpO1xuXHRcdHRoaXMuX3ZvbHVtZSA9IG51bGw7XG5cdFx0dGhpcy52b2x1bWUgPSBudWxsO1xuXHRcdHRoaXMuX3N0YXRlLmRpc3Bvc2UoKTtcblx0XHR0aGlzLl9zdGF0ZSA9IG51bGw7XG5cdH07XG5cblx0cmV0dXJuIFRvbmUuU291cmNlO1xufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBR0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7QUFFQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBRUE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRkE7QUFLQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFBQTtBQURBO0FBY0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFKQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/source/Source.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/source/TickSource.js":
/*!*****************************************************!*\
  !*** ./node_modules/tone/Tone/source/TickSource.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/signal/TickSignal */ \"./node_modules/tone/Tone/signal/TickSignal.js\"), __webpack_require__(/*! Tone/core/TimelineState */ \"./node_modules/tone/Tone/core/TimelineState.js\"), __webpack_require__(/*! Tone/core/Timeline */ \"./node_modules/tone/Tone/core/Timeline.js\"), __webpack_require__(/*! Tone/core/Param */ \"./node_modules/tone/Tone/core/Param.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  \"use strict\";\n  /**\n   *  @class  Uses [Tone.TickSignal](TickSignal) to track elapsed ticks with\n   *  \t\tcomplex automation curves.\n   *\n   * \t@constructor\n      *  @param {Frequency} frequency The initial frequency that the signal ticks at\n   *  @extends {Tone}\n   */\n\n  Tone.TickSource = function () {\n    var options = Tone.defaults(arguments, [\"frequency\"], Tone.TickSource);\n    /**\n     *  The frequency the callback function should be invoked.\n     *  @type  {Frequency}\n     *  @signal\n     */\n\n    this.frequency = new Tone.TickSignal(options.frequency, Tone.Type.Frequency);\n\n    this._readOnly(\"frequency\");\n    /**\n     *  The state timeline\n     *  @type {Tone.TimelineState}\n     *  @private\n     */\n\n\n    this._state = new Tone.TimelineState(Tone.State.Stopped);\n\n    this._state.setStateAtTime(Tone.State.Stopped, 0);\n    /**\n     * The offset values of the ticks\n     * @type {Tone.Timeline}\n     * @private\n     */\n\n\n    this._tickOffset = new Tone.Timeline(); //add the first event\n\n    this.setTicksAtTime(0, 0);\n  };\n\n  Tone.extend(Tone.TickSource);\n  /**\n   *  The defaults\n   *  @const\n   *  @type  {Object}\n   */\n\n  Tone.TickSource.defaults = {\n    \"frequency\": 1\n  };\n  /**\n   *  Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n   *  @type {Tone.State}\n   *  @readOnly\n   *  @memberOf Tone.TickSource#\n   *  @name state\n   */\n\n  Object.defineProperty(Tone.TickSource.prototype, \"state\", {\n    get: function () {\n      function get() {\n        return this._state.getValueAtTime(this.now());\n      }\n\n      return get;\n    }()\n  });\n  /**\n   *  Start the clock at the given time. Optionally pass in an offset\n   *  of where to start the tick counter from.\n   *  @param  {Time=}  time    The time the clock should start\n   *  @param {Ticks=0} offset The number of ticks to start the source at\n   *  @return  {Tone.TickSource}  this\n   */\n\n  Tone.TickSource.prototype.start = function (time, offset) {\n    time = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(time) !== Tone.State.Started) {\n      this._state.setStateAtTime(Tone.State.Started, time);\n\n      if (Tone.isDefined(offset)) {\n        this.setTicksAtTime(offset, time);\n      }\n    }\n\n    return this;\n  };\n  /**\n   *  Stop the clock. Stopping the clock resets the tick counter to 0.\n   *  @param {Time} [time=now] The time when the clock should stop.\n   *  @returns {Tone.TickSource} this\n   *  @example\n   * clock.stop();\n   */\n\n\n  Tone.TickSource.prototype.stop = function (time) {\n    time = this.toSeconds(time); //cancel the previous stop\n\n    if (this._state.getValueAtTime(time) === Tone.State.Stopped) {\n      var event = this._state.get(time);\n\n      if (event.time > 0) {\n        this._tickOffset.cancel(event.time);\n\n        this._state.cancel(event.time);\n      }\n    }\n\n    this._state.cancel(time);\n\n    this._state.setStateAtTime(Tone.State.Stopped, time);\n\n    this.setTicksAtTime(0, time);\n    return this;\n  };\n  /**\n   *  Pause the clock. Pausing does not reset the tick counter.\n   *  @param {Time} [time=now] The time when the clock should stop.\n   *  @returns {Tone.TickSource} this\n   */\n\n\n  Tone.TickSource.prototype.pause = function (time) {\n    time = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(time) === Tone.State.Started) {\n      this._state.setStateAtTime(Tone.State.Paused, time);\n    }\n\n    return this;\n  };\n  /**\n   *  Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n   *  @param {Time} [time=now] When to clear the events after\n   *  @returns {Tone.TickSource} this\n   */\n\n\n  Tone.TickSource.prototype.cancel = function (time) {\n    time = this.toSeconds(time);\n\n    this._state.cancel(time);\n\n    this._tickOffset.cancel(time);\n\n    return this;\n  };\n  /**\n   * Get the elapsed ticks at the given time\n   * @param  {Time} time  When to get the tick value\n   * @return {Ticks}     The number of ticks\n   */\n\n\n  Tone.TickSource.prototype.getTicksAtTime = function (time) {\n    time = this.toSeconds(time);\n\n    var stopEvent = this._state.getLastState(Tone.State.Stopped, time); //this event allows forEachBetween to iterate until the current time\n\n\n    var tmpEvent = {\n      state: Tone.State.Paused,\n      time: time\n    };\n\n    this._state.add(tmpEvent); //keep track of the previous offset event\n\n\n    var lastState = stopEvent;\n    var elapsedTicks = 0; //iterate through all the events since the last stop\n\n    this._state.forEachBetween(stopEvent.time, time + this.sampleTime, function (e) {\n      var periodStartTime = lastState.time; //if there is an offset event in this period use that\n\n      var offsetEvent = this._tickOffset.get(e.time);\n\n      if (offsetEvent.time >= lastState.time) {\n        elapsedTicks = offsetEvent.ticks;\n        periodStartTime = offsetEvent.time;\n      }\n\n      if (lastState.state === Tone.State.Started && e.state !== Tone.State.Started) {\n        elapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n      }\n\n      lastState = e;\n    }.bind(this)); //remove the temporary event\n\n\n    this._state.remove(tmpEvent); //return the ticks\n\n\n    return elapsedTicks;\n  };\n  /**\n   *  The number of times the callback was invoked. Starts counting at 0\n   *  and increments after the callback was invoked. Returns -1 when stopped.\n   *  @memberOf Tone.TickSource#\n   *  @name ticks\n   *  @type {Ticks}\n   */\n\n\n  Object.defineProperty(Tone.TickSource.prototype, \"ticks\", {\n    get: function () {\n      function get() {\n        return this.getTicksAtTime(this.now());\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(t) {\n        this.setTicksAtTime(t, this.now());\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  The time since ticks=0 that the TickSource has been running. Accounts\n   *  for tempo curves\n   *  @memberOf Tone.TickSource#\n   *  @name seconds\n   *  @type {Seconds}\n   */\n\n  Object.defineProperty(Tone.TickSource.prototype, \"seconds\", {\n    get: function () {\n      function get() {\n        return this.getSecondsAtTime(this.now());\n      }\n\n      return get;\n    }(),\n    set: function () {\n      function set(s) {\n        var now = this.now();\n        var ticks = this.frequency.timeToTicks(s, now);\n        this.setTicksAtTime(ticks, now);\n      }\n\n      return set;\n    }()\n  });\n  /**\n   *  Return the elapsed seconds at the given time.\n   *  @param  {Time}  time  When to get the elapsed seconds\n   *  @return  {Seconds}  The number of elapsed seconds\n   */\n\n  Tone.TickSource.prototype.getSecondsAtTime = function (time) {\n    time = this.toSeconds(time);\n\n    var stopEvent = this._state.getLastState(Tone.State.Stopped, time); //this event allows forEachBetween to iterate until the current time\n\n\n    var tmpEvent = {\n      state: Tone.State.Paused,\n      time: time\n    };\n\n    this._state.add(tmpEvent); //keep track of the previous offset event\n\n\n    var lastState = stopEvent;\n    var elapsedSeconds = 0; //iterate through all the events since the last stop\n\n    this._state.forEachBetween(stopEvent.time, time + this.sampleTime, function (e) {\n      var periodStartTime = lastState.time; //if there is an offset event in this period use that\n\n      var offsetEvent = this._tickOffset.get(e.time);\n\n      if (offsetEvent.time >= lastState.time) {\n        elapsedSeconds = offsetEvent.seconds;\n        periodStartTime = offsetEvent.time;\n      }\n\n      if (lastState.state === Tone.State.Started && e.state !== Tone.State.Started) {\n        elapsedSeconds += e.time - periodStartTime;\n      }\n\n      lastState = e;\n    }.bind(this)); //remove the temporary event\n\n\n    this._state.remove(tmpEvent); //return the ticks\n\n\n    return elapsedSeconds;\n  };\n  /**\n   * Set the clock's ticks at the given time.\n   * @param  {Ticks} ticks The tick value to set\n   * @param  {Time} time  When to set the tick value\n   * @return {Tone.TickSource}       this\n   */\n\n\n  Tone.TickSource.prototype.setTicksAtTime = function (ticks, time) {\n    time = this.toSeconds(time);\n\n    this._tickOffset.cancel(time);\n\n    this._tickOffset.add({\n      \"time\": time,\n      \"ticks\": ticks,\n      \"seconds\": this.frequency.getDurationOfTicks(ticks, time)\n    });\n\n    return this;\n  };\n  /**\n   *  Returns the scheduled state at the given time.\n   *  @param  {Time}  time  The time to query.\n   *  @return  {String}  The name of the state input in setStateAtTime.\n   *  @example\n   * source.start(\"+0.1\");\n   * source.getStateAtTime(\"+0.1\"); //returns \"started\"\n   */\n\n\n  Tone.TickSource.prototype.getStateAtTime = function (time) {\n    time = this.toSeconds(time);\n    return this._state.getValueAtTime(time);\n  };\n  /**\n   * Get the time of the given tick. The second argument\n   * is when to test before. Since ticks can be set (with setTicksAtTime)\n   * there may be multiple times for a given tick value. \n   * @param  {Ticks} ticks The tick number.\n   * @param  {Time=} before When to measure the tick value from. \n   * @return {Time}       The time of the tick\n   */\n\n\n  Tone.TickSource.prototype.getTimeOfTick = function (tick, before) {\n    before = Tone.defaultArg(before, this.now());\n\n    var offset = this._tickOffset.get(before);\n\n    var event = this._state.get(before);\n\n    var startTime = Math.max(offset.time, event.time);\n    var absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n    return this.frequency.getTimeOfTick(absoluteTicks);\n  };\n  /**\n   *  Invoke the callback event at all scheduled ticks between the \n   *  start time and the end time\n   *  @param  {Time}    startTime  The beginning of the search range\n   *  @param  {Time}    endTime    The end of the search range\n   *  @param  {Function<Time,Ticks>}  callback   The callback to invoke with each tick\n   *  @return  {Tone.TickSource}    this\n   */\n\n\n  Tone.TickSource.prototype.forEachTickBetween = function (startTime, endTime, callback) {\n    //only iterate through the sections where it is \"started\"\n    var lastStateEvent = this._state.get(startTime);\n\n    this._state.forEachBetween(startTime, endTime, function (event) {\n      if (lastStateEvent.state === Tone.State.Started && event.state !== Tone.State.Started) {\n        this.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);\n      }\n\n      lastStateEvent = event;\n    }.bind(this));\n\n    startTime = Math.max(lastStateEvent.time, startTime);\n\n    if (lastStateEvent.state === Tone.State.Started && this._state) {\n      //figure out the difference between the frequency ticks and the \n      var startTicks = this.frequency.getTicksAtTime(startTime);\n      var ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n      var diff = startTicks - ticksAtStart;\n      var offset = diff % 1;\n\n      if (offset !== 0) {\n        offset = 1 - offset;\n      }\n\n      var nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n      var error = null;\n\n      while (nextTickTime < endTime && this._state) {\n        try {\n          callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n        } catch (e) {\n          error = e;\n          break;\n        }\n\n        if (this._state) {\n          nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n        }\n      }\n    }\n\n    if (error) {\n      throw error;\n    }\n\n    return this;\n  };\n  /**\n   *  Clean up\n   *  @returns {Tone.TickSource} this\n   */\n\n\n  Tone.TickSource.prototype.dispose = function () {\n    Tone.Param.prototype.dispose.call(this);\n\n    this._state.dispose();\n\n    this._state = null;\n\n    this._tickOffset.dispose();\n\n    this._tickOffset = null;\n\n    this._writable(\"frequency\");\n\n    this.frequency.dispose();\n    this.frequency = null;\n    return this;\n  };\n\n  return Tone.TickSource;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3NvdXJjZS9UaWNrU291cmNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RvbmUvVG9uZS9zb3VyY2UvVGlja1NvdXJjZS5qcz9mZmNlIl0sInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbXCJUb25lL2NvcmUvVG9uZVwiLCBcIlRvbmUvc2lnbmFsL1RpY2tTaWduYWxcIiwgXCJUb25lL2NvcmUvVGltZWxpbmVTdGF0ZVwiLFxuXHRcIlRvbmUvY29yZS9UaW1lbGluZVwiLCBcIlRvbmUvY29yZS9QYXJhbVwiXSwgZnVuY3Rpb24oVG9uZSl7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqICBAY2xhc3MgIFVzZXMgW1RvbmUuVGlja1NpZ25hbF0oVGlja1NpZ25hbCkgdG8gdHJhY2sgZWxhcHNlZCB0aWNrcyB3aXRoXG5cdCAqICBcdFx0Y29tcGxleCBhdXRvbWF0aW9uIGN1cnZlcy5cblx0ICpcblx0ICogXHRAY29uc3RydWN0b3JcbiAgICAgKiAgQHBhcmFtIHtGcmVxdWVuY3l9IGZyZXF1ZW5jeSBUaGUgaW5pdGlhbCBmcmVxdWVuY3kgdGhhdCB0aGUgc2lnbmFsIHRpY2tzIGF0XG5cdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0ICovXG5cdFRvbmUuVGlja1NvdXJjZSA9IGZ1bmN0aW9uKCl7XG5cblx0XHR2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXCJmcmVxdWVuY3lcIl0sIFRvbmUuVGlja1NvdXJjZSk7XG5cblx0XHQvKipcblx0XHQgKiAgVGhlIGZyZXF1ZW5jeSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gc2hvdWxkIGJlIGludm9rZWQuXG5cdFx0ICogIEB0eXBlICB7RnJlcXVlbmN5fVxuXHRcdCAqICBAc2lnbmFsXG5cdFx0ICovXG5cdFx0dGhpcy5mcmVxdWVuY3kgPSBuZXcgVG9uZS5UaWNrU2lnbmFsKG9wdGlvbnMuZnJlcXVlbmN5LCBUb25lLlR5cGUuRnJlcXVlbmN5KTtcblx0XHR0aGlzLl9yZWFkT25seShcImZyZXF1ZW5jeVwiKTtcblxuXHRcdC8qKlxuXHRcdCAqICBUaGUgc3RhdGUgdGltZWxpbmVcblx0XHQgKiAgQHR5cGUge1RvbmUuVGltZWxpbmVTdGF0ZX1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9zdGF0ZSA9IG5ldyBUb25lLlRpbWVsaW5lU3RhdGUoVG9uZS5TdGF0ZS5TdG9wcGVkKTtcblx0XHR0aGlzLl9zdGF0ZS5zZXRTdGF0ZUF0VGltZShUb25lLlN0YXRlLlN0b3BwZWQsIDApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG9mZnNldCB2YWx1ZXMgb2YgdGhlIHRpY2tzXG5cdFx0ICogQHR5cGUge1RvbmUuVGltZWxpbmV9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl90aWNrT2Zmc2V0ID0gbmV3IFRvbmUuVGltZWxpbmUoKTtcblx0XHQvL2FkZCB0aGUgZmlyc3QgZXZlbnRcblx0XHR0aGlzLnNldFRpY2tzQXRUaW1lKDAsIDApO1xuXHR9O1xuXG5cdFRvbmUuZXh0ZW5kKFRvbmUuVGlja1NvdXJjZSk7XG5cblx0LyoqXG5cdCAqICBUaGUgZGVmYXVsdHNcblx0ICogIEBjb25zdFxuXHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdCAqL1xuXHRUb25lLlRpY2tTb3VyY2UuZGVmYXVsdHMgPSB7XG5cdFx0XCJmcmVxdWVuY3lcIiA6IDEsXG5cdH07XG5cblx0LyoqXG5cdCAqICBSZXR1cm5zIHRoZSBwbGF5YmFjayBzdGF0ZSBvZiB0aGUgc291cmNlLCBlaXRoZXIgXCJzdGFydGVkXCIsIFwic3RvcHBlZFwiIG9yIFwicGF1c2VkXCIuXG5cdCAqICBAdHlwZSB7VG9uZS5TdGF0ZX1cblx0ICogIEByZWFkT25seVxuXHQgKiAgQG1lbWJlck9mIFRvbmUuVGlja1NvdXJjZSNcblx0ICogIEBuYW1lIHN0YXRlXG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UaWNrU291cmNlLnByb3RvdHlwZSwgXCJzdGF0ZVwiLCB7XG5cdFx0Z2V0IDogZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiB0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aGlzLm5vdygpKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiAgU3RhcnQgdGhlIGNsb2NrIGF0IHRoZSBnaXZlbiB0aW1lLiBPcHRpb25hbGx5IHBhc3MgaW4gYW4gb2Zmc2V0XG5cdCAqICBvZiB3aGVyZSB0byBzdGFydCB0aGUgdGljayBjb3VudGVyIGZyb20uXG5cdCAqICBAcGFyYW0gIHtUaW1lPX0gIHRpbWUgICAgVGhlIHRpbWUgdGhlIGNsb2NrIHNob3VsZCBzdGFydFxuXHQgKiAgQHBhcmFtIHtUaWNrcz0wfSBvZmZzZXQgVGhlIG51bWJlciBvZiB0aWNrcyB0byBzdGFydCB0aGUgc291cmNlIGF0XG5cdCAqICBAcmV0dXJuICB7VG9uZS5UaWNrU291cmNlfSAgdGhpc1xuXHQgKi9cblx0VG9uZS5UaWNrU291cmNlLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKHRpbWUsIG9mZnNldCl7XG5cdFx0dGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHRcdGlmICh0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aW1lKSAhPT0gVG9uZS5TdGF0ZS5TdGFydGVkKXtcblx0XHRcdHRoaXMuX3N0YXRlLnNldFN0YXRlQXRUaW1lKFRvbmUuU3RhdGUuU3RhcnRlZCwgdGltZSk7XG5cdFx0XHRpZiAoVG9uZS5pc0RlZmluZWQob2Zmc2V0KSl7XG5cdFx0XHRcdHRoaXMuc2V0VGlja3NBdFRpbWUob2Zmc2V0LCB0aW1lKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqICBTdG9wIHRoZSBjbG9jay4gU3RvcHBpbmcgdGhlIGNsb2NrIHJlc2V0cyB0aGUgdGljayBjb3VudGVyIHRvIDAuXG5cdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gVGhlIHRpbWUgd2hlbiB0aGUgY2xvY2sgc2hvdWxkIHN0b3AuXG5cdCAqICBAcmV0dXJucyB7VG9uZS5UaWNrU291cmNlfSB0aGlzXG5cdCAqICBAZXhhbXBsZVxuXHQgKiBjbG9jay5zdG9wKCk7XG5cdCAqL1xuXHRUb25lLlRpY2tTb3VyY2UucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbih0aW1lKXtcblx0XHR0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdFx0Ly9jYW5jZWwgdGhlIHByZXZpb3VzIHN0b3Bcblx0XHRpZiAodGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodGltZSkgPT09IFRvbmUuU3RhdGUuU3RvcHBlZCl7XG5cdFx0XHR2YXIgZXZlbnQgPSB0aGlzLl9zdGF0ZS5nZXQodGltZSk7XG5cdFx0XHRpZiAoZXZlbnQudGltZSA+IDApe1xuXHRcdFx0XHR0aGlzLl90aWNrT2Zmc2V0LmNhbmNlbChldmVudC50aW1lKTtcblx0XHRcdFx0dGhpcy5fc3RhdGUuY2FuY2VsKGV2ZW50LnRpbWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9zdGF0ZS5jYW5jZWwodGltZSk7XG5cdFx0dGhpcy5fc3RhdGUuc2V0U3RhdGVBdFRpbWUoVG9uZS5TdGF0ZS5TdG9wcGVkLCB0aW1lKTtcblx0XHR0aGlzLnNldFRpY2tzQXRUaW1lKDAsIHRpbWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgUGF1c2UgdGhlIGNsb2NrLiBQYXVzaW5nIGRvZXMgbm90IHJlc2V0IHRoZSB0aWNrIGNvdW50ZXIuXG5cdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gVGhlIHRpbWUgd2hlbiB0aGUgY2xvY2sgc2hvdWxkIHN0b3AuXG5cdCAqICBAcmV0dXJucyB7VG9uZS5UaWNrU291cmNlfSB0aGlzXG5cdCAqL1xuXHRUb25lLlRpY2tTb3VyY2UucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24odGltZSl7XG5cdFx0dGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHRcdGlmICh0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aW1lKSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKXtcblx0XHRcdHRoaXMuX3N0YXRlLnNldFN0YXRlQXRUaW1lKFRvbmUuU3RhdGUuUGF1c2VkLCB0aW1lKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqICBDYW5jZWwgc3RhcnQvc3RvcC9wYXVzZSBhbmQgc2V0VGlja0F0VGltZSBldmVudHMgc2NoZWR1bGVkIGFmdGVyIHRoZSBnaXZlbiB0aW1lLlxuXHQgKiAgQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIFdoZW4gdG8gY2xlYXIgdGhlIGV2ZW50cyBhZnRlclxuXHQgKiAgQHJldHVybnMge1RvbmUuVGlja1NvdXJjZX0gdGhpc1xuXHQgKi9cblx0VG9uZS5UaWNrU291cmNlLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbih0aW1lKXtcblx0XHR0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdFx0dGhpcy5fc3RhdGUuY2FuY2VsKHRpbWUpO1xuXHRcdHRoaXMuX3RpY2tPZmZzZXQuY2FuY2VsKHRpbWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGVsYXBzZWQgdGlja3MgYXQgdGhlIGdpdmVuIHRpbWVcblx0ICogQHBhcmFtICB7VGltZX0gdGltZSAgV2hlbiB0byBnZXQgdGhlIHRpY2sgdmFsdWVcblx0ICogQHJldHVybiB7VGlja3N9ICAgICBUaGUgbnVtYmVyIG9mIHRpY2tzXG5cdCAqL1xuXHRUb25lLlRpY2tTb3VyY2UucHJvdG90eXBlLmdldFRpY2tzQXRUaW1lID0gZnVuY3Rpb24odGltZSl7XG5cdFx0dGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHRcdHZhciBzdG9wRXZlbnQgPSB0aGlzLl9zdGF0ZS5nZXRMYXN0U3RhdGUoVG9uZS5TdGF0ZS5TdG9wcGVkLCB0aW1lKTtcblx0XHQvL3RoaXMgZXZlbnQgYWxsb3dzIGZvckVhY2hCZXR3ZWVuIHRvIGl0ZXJhdGUgdW50aWwgdGhlIGN1cnJlbnQgdGltZVxuXHRcdHZhciB0bXBFdmVudCA9IHsgc3RhdGUgOiBUb25lLlN0YXRlLlBhdXNlZCwgdGltZSA6IHRpbWUgfTtcblx0XHR0aGlzLl9zdGF0ZS5hZGQodG1wRXZlbnQpO1xuXG5cdFx0Ly9rZWVwIHRyYWNrIG9mIHRoZSBwcmV2aW91cyBvZmZzZXQgZXZlbnRcblx0XHR2YXIgbGFzdFN0YXRlID0gc3RvcEV2ZW50O1xuXHRcdHZhciBlbGFwc2VkVGlja3MgPSAwO1xuXG5cdFx0Ly9pdGVyYXRlIHRocm91Z2ggYWxsIHRoZSBldmVudHMgc2luY2UgdGhlIGxhc3Qgc3RvcFxuXHRcdHRoaXMuX3N0YXRlLmZvckVhY2hCZXR3ZWVuKHN0b3BFdmVudC50aW1lLCB0aW1lICsgdGhpcy5zYW1wbGVUaW1lLCBmdW5jdGlvbihlKXtcblx0XHRcdHZhciBwZXJpb2RTdGFydFRpbWUgPSBsYXN0U3RhdGUudGltZTtcblx0XHRcdC8vaWYgdGhlcmUgaXMgYW4gb2Zmc2V0IGV2ZW50IGluIHRoaXMgcGVyaW9kIHVzZSB0aGF0XG5cdFx0XHR2YXIgb2Zmc2V0RXZlbnQgPSB0aGlzLl90aWNrT2Zmc2V0LmdldChlLnRpbWUpO1xuXHRcdFx0aWYgKG9mZnNldEV2ZW50LnRpbWUgPj0gbGFzdFN0YXRlLnRpbWUpe1xuXHRcdFx0XHRlbGFwc2VkVGlja3MgPSBvZmZzZXRFdmVudC50aWNrcztcblx0XHRcdFx0cGVyaW9kU3RhcnRUaW1lID0gb2Zmc2V0RXZlbnQudGltZTtcblx0XHRcdH1cblx0XHRcdGlmIChsYXN0U3RhdGUuc3RhdGUgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCAmJiBlLnN0YXRlICE9PSBUb25lLlN0YXRlLlN0YXJ0ZWQpe1xuXHRcdFx0XHRlbGFwc2VkVGlja3MgKz0gdGhpcy5mcmVxdWVuY3kuZ2V0VGlja3NBdFRpbWUoZS50aW1lKSAtIHRoaXMuZnJlcXVlbmN5LmdldFRpY2tzQXRUaW1lKHBlcmlvZFN0YXJ0VGltZSk7XG5cdFx0XHR9IFxuXHRcdFx0bGFzdFN0YXRlID0gZTtcblx0XHR9LmJpbmQodGhpcykpO1xuXG5cdFx0Ly9yZW1vdmUgdGhlIHRlbXBvcmFyeSBldmVudFxuXHRcdHRoaXMuX3N0YXRlLnJlbW92ZSh0bXBFdmVudCk7XG5cblx0XHQvL3JldHVybiB0aGUgdGlja3Ncblx0XHRyZXR1cm4gZWxhcHNlZFRpY2tzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgY2FsbGJhY2sgd2FzIGludm9rZWQuIFN0YXJ0cyBjb3VudGluZyBhdCAwXG5cdCAqICBhbmQgaW5jcmVtZW50cyBhZnRlciB0aGUgY2FsbGJhY2sgd2FzIGludm9rZWQuIFJldHVybnMgLTEgd2hlbiBzdG9wcGVkLlxuXHQgKiAgQG1lbWJlck9mIFRvbmUuVGlja1NvdXJjZSNcblx0ICogIEBuYW1lIHRpY2tzXG5cdCAqICBAdHlwZSB7VGlja3N9XG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UaWNrU291cmNlLnByb3RvdHlwZSwgXCJ0aWNrc1wiLCB7XG5cdFx0Z2V0IDogZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiB0aGlzLmdldFRpY2tzQXRUaW1lKHRoaXMubm93KCkpO1xuXHRcdH0sXG5cdFx0c2V0IDogZnVuY3Rpb24odCl7XG5cdFx0XHR0aGlzLnNldFRpY2tzQXRUaW1lKHQsIHRoaXMubm93KCkpO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqICBUaGUgdGltZSBzaW5jZSB0aWNrcz0wIHRoYXQgdGhlIFRpY2tTb3VyY2UgaGFzIGJlZW4gcnVubmluZy4gQWNjb3VudHNcblx0ICogIGZvciB0ZW1wbyBjdXJ2ZXNcblx0ICogIEBtZW1iZXJPZiBUb25lLlRpY2tTb3VyY2UjXG5cdCAqICBAbmFtZSBzZWNvbmRzXG5cdCAqICBAdHlwZSB7U2Vjb25kc31cblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRpY2tTb3VyY2UucHJvdG90eXBlLCBcInNlY29uZHNcIiwge1xuXHRcdGdldCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRTZWNvbmRzQXRUaW1lKHRoaXMubm93KCkpO1xuXHRcdH0sXG5cdFx0c2V0IDogZnVuY3Rpb24ocyl7XG5cdFx0XHR2YXIgbm93ID0gdGhpcy5ub3coKTtcblx0XHRcdHZhciB0aWNrcyA9IHRoaXMuZnJlcXVlbmN5LnRpbWVUb1RpY2tzKHMsIG5vdyk7XG5cdFx0XHR0aGlzLnNldFRpY2tzQXRUaW1lKHRpY2tzLCBub3cpO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqICBSZXR1cm4gdGhlIGVsYXBzZWQgc2Vjb25kcyBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0ICogIEBwYXJhbSAge1RpbWV9ICB0aW1lICBXaGVuIHRvIGdldCB0aGUgZWxhcHNlZCBzZWNvbmRzXG5cdCAqICBAcmV0dXJuICB7U2Vjb25kc30gIFRoZSBudW1iZXIgb2YgZWxhcHNlZCBzZWNvbmRzXG5cdCAqL1xuXHRUb25lLlRpY2tTb3VyY2UucHJvdG90eXBlLmdldFNlY29uZHNBdFRpbWUgPSBmdW5jdGlvbih0aW1lKXtcblx0XHR0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdFx0dmFyIHN0b3BFdmVudCA9IHRoaXMuX3N0YXRlLmdldExhc3RTdGF0ZShUb25lLlN0YXRlLlN0b3BwZWQsIHRpbWUpO1xuXHRcdC8vdGhpcyBldmVudCBhbGxvd3MgZm9yRWFjaEJldHdlZW4gdG8gaXRlcmF0ZSB1bnRpbCB0aGUgY3VycmVudCB0aW1lXG5cdFx0dmFyIHRtcEV2ZW50ID0geyBzdGF0ZSA6IFRvbmUuU3RhdGUuUGF1c2VkLCB0aW1lIDogdGltZSB9O1xuXHRcdHRoaXMuX3N0YXRlLmFkZCh0bXBFdmVudCk7XG5cblx0XHQvL2tlZXAgdHJhY2sgb2YgdGhlIHByZXZpb3VzIG9mZnNldCBldmVudFxuXHRcdHZhciBsYXN0U3RhdGUgPSBzdG9wRXZlbnQ7XG5cdFx0dmFyIGVsYXBzZWRTZWNvbmRzID0gMDtcblxuXHRcdC8vaXRlcmF0ZSB0aHJvdWdoIGFsbCB0aGUgZXZlbnRzIHNpbmNlIHRoZSBsYXN0IHN0b3Bcblx0XHR0aGlzLl9zdGF0ZS5mb3JFYWNoQmV0d2VlbihzdG9wRXZlbnQudGltZSwgdGltZSArIHRoaXMuc2FtcGxlVGltZSwgZnVuY3Rpb24oZSl7XG5cdFx0XHR2YXIgcGVyaW9kU3RhcnRUaW1lID0gbGFzdFN0YXRlLnRpbWU7XG5cdFx0XHQvL2lmIHRoZXJlIGlzIGFuIG9mZnNldCBldmVudCBpbiB0aGlzIHBlcmlvZCB1c2UgdGhhdFxuXHRcdFx0dmFyIG9mZnNldEV2ZW50ID0gdGhpcy5fdGlja09mZnNldC5nZXQoZS50aW1lKTtcblx0XHRcdGlmIChvZmZzZXRFdmVudC50aW1lID49IGxhc3RTdGF0ZS50aW1lKXtcblx0XHRcdFx0ZWxhcHNlZFNlY29uZHMgPSBvZmZzZXRFdmVudC5zZWNvbmRzO1xuXHRcdFx0XHRwZXJpb2RTdGFydFRpbWUgPSBvZmZzZXRFdmVudC50aW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGxhc3RTdGF0ZS5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkICYmIGUuc3RhdGUgIT09IFRvbmUuU3RhdGUuU3RhcnRlZCl7XG5cdFx0XHRcdGVsYXBzZWRTZWNvbmRzICs9IGUudGltZSAtIHBlcmlvZFN0YXJ0VGltZTtcblx0XHRcdH0gXG5cdFx0XHRsYXN0U3RhdGUgPSBlO1xuXHRcdH0uYmluZCh0aGlzKSk7XG5cblx0XHQvL3JlbW92ZSB0aGUgdGVtcG9yYXJ5IGV2ZW50XG5cdFx0dGhpcy5fc3RhdGUucmVtb3ZlKHRtcEV2ZW50KTtcblxuXHRcdC8vcmV0dXJuIHRoZSB0aWNrc1xuXHRcdHJldHVybiBlbGFwc2VkU2Vjb25kcztcblx0fTtcblxuXHQvKipcblx0ICogU2V0IHRoZSBjbG9jaydzIHRpY2tzIGF0IHRoZSBnaXZlbiB0aW1lLlxuXHQgKiBAcGFyYW0gIHtUaWNrc30gdGlja3MgVGhlIHRpY2sgdmFsdWUgdG8gc2V0XG5cdCAqIEBwYXJhbSAge1RpbWV9IHRpbWUgIFdoZW4gdG8gc2V0IHRoZSB0aWNrIHZhbHVlXG5cdCAqIEByZXR1cm4ge1RvbmUuVGlja1NvdXJjZX0gICAgICAgdGhpc1xuXHQgKi9cblx0VG9uZS5UaWNrU291cmNlLnByb3RvdHlwZS5zZXRUaWNrc0F0VGltZSA9IGZ1bmN0aW9uKHRpY2tzLCB0aW1lKXtcblx0XHR0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdFx0dGhpcy5fdGlja09mZnNldC5jYW5jZWwodGltZSk7XG5cdFx0dGhpcy5fdGlja09mZnNldC5hZGQoe1xuXHRcdFx0XCJ0aW1lXCIgOiB0aW1lLFxuXHRcdFx0XCJ0aWNrc1wiIDogdGlja3MsXG5cdFx0XHRcInNlY29uZHNcIiA6IHRoaXMuZnJlcXVlbmN5LmdldER1cmF0aW9uT2ZUaWNrcyh0aWNrcywgdGltZSlcblx0XHR9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogIFJldHVybnMgdGhlIHNjaGVkdWxlZCBzdGF0ZSBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0ICogIEBwYXJhbSAge1RpbWV9ICB0aW1lICBUaGUgdGltZSB0byBxdWVyeS5cblx0ICogIEByZXR1cm4gIHtTdHJpbmd9ICBUaGUgbmFtZSBvZiB0aGUgc3RhdGUgaW5wdXQgaW4gc2V0U3RhdGVBdFRpbWUuXG5cdCAqICBAZXhhbXBsZVxuXHQgKiBzb3VyY2Uuc3RhcnQoXCIrMC4xXCIpO1xuXHQgKiBzb3VyY2UuZ2V0U3RhdGVBdFRpbWUoXCIrMC4xXCIpOyAvL3JldHVybnMgXCJzdGFydGVkXCJcblx0ICovXG5cdFRvbmUuVGlja1NvdXJjZS5wcm90b3R5cGUuZ2V0U3RhdGVBdFRpbWUgPSBmdW5jdGlvbih0aW1lKXtcblx0XHR0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdFx0cmV0dXJuIHRoaXMuX3N0YXRlLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHRpbWUgb2YgdGhlIGdpdmVuIHRpY2suIFRoZSBzZWNvbmQgYXJndW1lbnRcblx0ICogaXMgd2hlbiB0byB0ZXN0IGJlZm9yZS4gU2luY2UgdGlja3MgY2FuIGJlIHNldCAod2l0aCBzZXRUaWNrc0F0VGltZSlcblx0ICogdGhlcmUgbWF5IGJlIG11bHRpcGxlIHRpbWVzIGZvciBhIGdpdmVuIHRpY2sgdmFsdWUuIFxuXHQgKiBAcGFyYW0gIHtUaWNrc30gdGlja3MgVGhlIHRpY2sgbnVtYmVyLlxuXHQgKiBAcGFyYW0gIHtUaW1lPX0gYmVmb3JlIFdoZW4gdG8gbWVhc3VyZSB0aGUgdGljayB2YWx1ZSBmcm9tLiBcblx0ICogQHJldHVybiB7VGltZX0gICAgICAgVGhlIHRpbWUgb2YgdGhlIHRpY2tcblx0ICovXG5cdFRvbmUuVGlja1NvdXJjZS5wcm90b3R5cGUuZ2V0VGltZU9mVGljayA9IGZ1bmN0aW9uKHRpY2ssIGJlZm9yZSl7XG5cdFx0YmVmb3JlID0gVG9uZS5kZWZhdWx0QXJnKGJlZm9yZSwgdGhpcy5ub3coKSk7XG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuX3RpY2tPZmZzZXQuZ2V0KGJlZm9yZSk7XG5cdFx0dmFyIGV2ZW50ID0gdGhpcy5fc3RhdGUuZ2V0KGJlZm9yZSk7XG5cdFx0dmFyIHN0YXJ0VGltZSA9IE1hdGgubWF4KG9mZnNldC50aW1lLCBldmVudC50aW1lKTtcblx0XHR2YXIgYWJzb2x1dGVUaWNrcyA9IHRoaXMuZnJlcXVlbmN5LmdldFRpY2tzQXRUaW1lKHN0YXJ0VGltZSkgKyB0aWNrIC0gb2Zmc2V0LnRpY2tzO1xuXHRcdHJldHVybiB0aGlzLmZyZXF1ZW5jeS5nZXRUaW1lT2ZUaWNrKGFic29sdXRlVGlja3MpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgSW52b2tlIHRoZSBjYWxsYmFjayBldmVudCBhdCBhbGwgc2NoZWR1bGVkIHRpY2tzIGJldHdlZW4gdGhlIFxuXHQgKiAgc3RhcnQgdGltZSBhbmQgdGhlIGVuZCB0aW1lXG5cdCAqICBAcGFyYW0gIHtUaW1lfSAgICBzdGFydFRpbWUgIFRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlYXJjaCByYW5nZVxuXHQgKiAgQHBhcmFtICB7VGltZX0gICAgZW5kVGltZSAgICBUaGUgZW5kIG9mIHRoZSBzZWFyY2ggcmFuZ2Vcblx0ICogIEBwYXJhbSAge0Z1bmN0aW9uPFRpbWUsVGlja3M+fSAgY2FsbGJhY2sgICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCB0aWNrXG5cdCAqICBAcmV0dXJuICB7VG9uZS5UaWNrU291cmNlfSAgICB0aGlzXG5cdCAqL1xuXHRUb25lLlRpY2tTb3VyY2UucHJvdG90eXBlLmZvckVhY2hUaWNrQmV0d2VlbiA9IGZ1bmN0aW9uKHN0YXJ0VGltZSwgZW5kVGltZSwgY2FsbGJhY2spe1xuXG5cdFx0Ly9vbmx5IGl0ZXJhdGUgdGhyb3VnaCB0aGUgc2VjdGlvbnMgd2hlcmUgaXQgaXMgXCJzdGFydGVkXCJcblx0XHR2YXIgbGFzdFN0YXRlRXZlbnQgPSB0aGlzLl9zdGF0ZS5nZXQoc3RhcnRUaW1lKTtcblx0XHR0aGlzLl9zdGF0ZS5mb3JFYWNoQmV0d2VlbihzdGFydFRpbWUsIGVuZFRpbWUsIGZ1bmN0aW9uKGV2ZW50KXtcblx0XHRcdGlmIChsYXN0U3RhdGVFdmVudC5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkICYmIGV2ZW50LnN0YXRlICE9PSBUb25lLlN0YXRlLlN0YXJ0ZWQpe1xuXHRcdFx0XHR0aGlzLmZvckVhY2hUaWNrQmV0d2VlbihNYXRoLm1heChsYXN0U3RhdGVFdmVudC50aW1lLCBzdGFydFRpbWUpLCBldmVudC50aW1lIC0gdGhpcy5zYW1wbGVUaW1lLCBjYWxsYmFjayk7XG5cdFx0XHR9XG5cdFx0XHRsYXN0U3RhdGVFdmVudCA9IGV2ZW50O1xuXHRcdH0uYmluZCh0aGlzKSk7XG5cblx0XHRzdGFydFRpbWUgPSBNYXRoLm1heChsYXN0U3RhdGVFdmVudC50aW1lLCBzdGFydFRpbWUpO1xuXG5cdFx0aWYgKGxhc3RTdGF0ZUV2ZW50LnN0YXRlID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQgJiYgdGhpcy5fc3RhdGUpe1xuXHRcdFx0Ly9maWd1cmUgb3V0IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGZyZXF1ZW5jeSB0aWNrcyBhbmQgdGhlIFxuXHRcdFx0dmFyIHN0YXJ0VGlja3MgPSB0aGlzLmZyZXF1ZW5jeS5nZXRUaWNrc0F0VGltZShzdGFydFRpbWUpO1xuXHRcdFx0dmFyIHRpY2tzQXRTdGFydCA9IHRoaXMuZnJlcXVlbmN5LmdldFRpY2tzQXRUaW1lKGxhc3RTdGF0ZUV2ZW50LnRpbWUpO1xuXHRcdFx0dmFyIGRpZmYgPSBzdGFydFRpY2tzIC0gdGlja3NBdFN0YXJ0O1xuXHRcdFx0dmFyIG9mZnNldCA9IGRpZmYgJSAxO1xuXHRcdFx0aWYgKG9mZnNldCAhPT0gMCl7XG5cdFx0XHRcdG9mZnNldCA9IDEgLSBvZmZzZXQ7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbmV4dFRpY2tUaW1lID0gdGhpcy5mcmVxdWVuY3kuZ2V0VGltZU9mVGljayhzdGFydFRpY2tzICsgb2Zmc2V0KTtcblx0XHRcdHZhciBlcnJvciA9IG51bGw7XG5cdFx0XHR3aGlsZSAobmV4dFRpY2tUaW1lIDwgZW5kVGltZSAmJiB0aGlzLl9zdGF0ZSl7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sobmV4dFRpY2tUaW1lLCBNYXRoLnJvdW5kKHRoaXMuZ2V0VGlja3NBdFRpbWUobmV4dFRpY2tUaW1lKSkpO1xuXHRcdFx0XHR9IGNhdGNoIChlKXtcblx0XHRcdFx0XHRlcnJvciA9IGU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX3N0YXRlKXtcblx0XHRcdFx0XHRuZXh0VGlja1RpbWUgKz0gdGhpcy5mcmVxdWVuY3kuZ2V0RHVyYXRpb25PZlRpY2tzKDEsIG5leHRUaWNrVGltZSk7XG5cdFx0XHRcdH0gXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGVycm9yKXtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogIENsZWFuIHVwXG5cdCAqICBAcmV0dXJucyB7VG9uZS5UaWNrU291cmNlfSB0aGlzXG5cdCAqL1xuXHRUb25lLlRpY2tTb3VyY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpe1xuXHRcdFRvbmUuUGFyYW0ucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0XHR0aGlzLl9zdGF0ZS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5fc3RhdGUgPSBudWxsO1xuXHRcdHRoaXMuX3RpY2tPZmZzZXQuZGlzcG9zZSgpO1xuXHRcdHRoaXMuX3RpY2tPZmZzZXQgPSBudWxsO1xuXHRcdHRoaXMuX3dyaXRhYmxlKFwiZnJlcXVlbmN5XCIpO1xuXHRcdHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0cmV0dXJuIFRvbmUuVGlja1NvdXJjZTtcbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUdBO0FBRUE7Ozs7Ozs7OztBQVFBO0FBRUE7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQUFBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQUE7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFLQTtBQUNBO0FBREE7QUFJQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBREE7QUFNQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBSkE7QUFTQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUFBO0FBSkE7QUFXQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBSUE7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/source/TickSource.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/type/Frequency.js":
/*!**************************************************!*\
  !*** ./node_modules/tone/Tone/type/Frequency.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/type/TimeBase */ \"./node_modules/tone/Tone/type/TimeBase.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  /**\n   *  @class Tone.Frequency is a primitive type for encoding Frequency values.\n   *         Eventually all time values are evaluated to hertz\n   *         using the `eval` method.\n   *  @constructor\n   *  @extends {Tone.TimeBase}\n   *  @param  {String|Number}  val    The time value.\n   *  @param  {String=}  units  The units of the value.\n   *  @example\n   * Tone.Frequency(\"C3\") // 261\n   * Tone.Frequency(38, \"midi\") //\n   * Tone.Frequency(\"C3\").transpose(4);\n   */\n  Tone.Frequency = function (val, units) {\n    if (this instanceof Tone.Frequency) {\n      Tone.TimeBase.call(this, val, units);\n    } else {\n      return new Tone.Frequency(val, units);\n    }\n  };\n\n  Tone.extend(Tone.Frequency, Tone.TimeBase); ///////////////////////////////////////////////////////////////////////////\n  //\tAUGMENT BASE EXPRESSIONS\n  ///////////////////////////////////////////////////////////////////////////\n\n  Tone.Frequency.prototype._expressions = Object.assign({}, Tone.TimeBase.prototype._expressions, {\n    \"midi\": {\n      regexp: /^(\\d+(?:\\.\\d+)?midi)/,\n      method: function () {\n        function method(value) {\n          if (this._defaultUnits === \"midi\") {\n            return value;\n          } else {\n            return Tone.Frequency.mtof(value);\n          }\n        }\n\n        return method;\n      }()\n    },\n    \"note\": {\n      regexp: /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,\n      method: function () {\n        function method(pitch, octave) {\n          var index = noteToScaleIndex[pitch.toLowerCase()];\n          var noteNumber = index + (parseInt(octave) + 1) * 12;\n\n          if (this._defaultUnits === \"midi\") {\n            return noteNumber;\n          } else {\n            return Tone.Frequency.mtof(noteNumber);\n          }\n        }\n\n        return method;\n      }()\n    },\n    \"tr\": {\n      regexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?/,\n      method: function () {\n        function method(m, q, s) {\n          var total = 1;\n\n          if (m && m !== \"0\") {\n            total *= this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n          }\n\n          if (q && q !== \"0\") {\n            total *= this._beatsToUnits(parseFloat(q));\n          }\n\n          if (s && s !== \"0\") {\n            total *= this._beatsToUnits(parseFloat(s) / 4);\n          }\n\n          return total;\n        }\n\n        return method;\n      }()\n    }\n  }); ///////////////////////////////////////////////////////////////////////////\n  //\tEXPRESSIONS\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  Transposes the frequency by the given number of semitones.\n   *  @param  {Interval}  interval\n   *  @return  {Tone.Frequency} A new transposed frequency\n   *  @example\n   * Tone.Frequency(\"A4\").transpose(3); //\"C5\"\n   */\n\n  Tone.Frequency.prototype.transpose = function (interval) {\n    return new this.constructor(this.valueOf() * Tone.intervalToFrequencyRatio(interval));\n  };\n  /**\n   *  Takes an array of semitone intervals and returns\n   *  an array of frequencies transposed by those intervals.\n   *  @param  {Array}  intervals\n   *  @return  {Array<Tone.Frequency>} Returns an array of Frequencies\n   *  @example\n   * Tone.Frequency(\"A4\").harmonize([0, 3, 7]); //[\"A4\", \"C5\", \"E5\"]\n   */\n\n\n  Tone.Frequency.prototype.harmonize = function (intervals) {\n    return intervals.map(function (interval) {\n      return this.transpose(interval);\n    }.bind(this));\n  }; ///////////////////////////////////////////////////////////////////////////\n  //\tUNIT CONVERSIONS\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  Return the value of the frequency as a MIDI note\n   *  @return  {MIDI}\n   *  @example\n   * Tone.Frequency(\"C4\").toMidi(); //60\n   */\n\n\n  Tone.Frequency.prototype.toMidi = function () {\n    return Tone.Frequency.ftom(this.valueOf());\n  };\n  /**\n   *  Return the value of the frequency in Scientific Pitch Notation\n   *  @return  {Note}\n   *  @example\n   * Tone.Frequency(69, \"midi\").toNote(); //\"A4\"\n   */\n\n\n  Tone.Frequency.prototype.toNote = function () {\n    var freq = this.toFrequency();\n    var log = Math.log2(freq / Tone.Frequency.A4);\n    var noteNumber = Math.round(12 * log) + 57;\n    var octave = Math.floor(noteNumber / 12);\n\n    if (octave < 0) {\n      noteNumber += -12 * octave;\n    }\n\n    var noteName = scaleIndexToNote[noteNumber % 12];\n    return noteName + octave.toString();\n  };\n  /**\n   *  Return the duration of one cycle in seconds.\n   *  @return  {Seconds}\n   */\n\n\n  Tone.Frequency.prototype.toSeconds = function () {\n    return 1 / Tone.TimeBase.prototype.toSeconds.call(this);\n  };\n  /**\n   *  Return the value in Hertz\n   *  @return  {Frequency}\n   */\n\n\n  Tone.Frequency.prototype.toFrequency = function () {\n    return Tone.TimeBase.prototype.toFrequency.call(this);\n  };\n  /**\n   *  Return the duration of one cycle in ticks\n   *  @return  {Ticks}\n   */\n\n\n  Tone.Frequency.prototype.toTicks = function () {\n    var quarterTime = this._beatsToUnits(1);\n\n    var quarters = this.valueOf() / quarterTime;\n    return Math.floor(quarters * Tone.Transport.PPQ);\n  }; ///////////////////////////////////////////////////////////////////////////\n  //\tUNIT CONVERSIONS HELPERS\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  With no arguments, return 0\n   *  @return  {Number}\n   *  @private\n   */\n\n\n  Tone.Frequency.prototype._noArg = function () {\n    return 0;\n  };\n  /**\n   *  Returns the value of a frequency in the current units\n   *  @param {Frequency} freq\n   *  @return  {Number}\n   *  @private\n   */\n\n\n  Tone.Frequency.prototype._frequencyToUnits = function (freq) {\n    return freq;\n  };\n  /**\n   *  Returns the value of a tick in the current time units\n   *  @param {Ticks} ticks\n   *  @return  {Number}\n   *  @private\n   */\n\n\n  Tone.Frequency.prototype._ticksToUnits = function (ticks) {\n    return 1 / (ticks * 60 / (Tone.Transport.bpm.value * Tone.Transport.PPQ));\n  };\n  /**\n   *  Return the value of the beats in the current units\n   *  @param {Number} beats\n   *  @return  {Number}\n   *  @private\n   */\n\n\n  Tone.Frequency.prototype._beatsToUnits = function (beats) {\n    return 1 / Tone.TimeBase.prototype._beatsToUnits.call(this, beats);\n  };\n  /**\n   *  Returns the value of a second in the current units\n   *  @param {Seconds} seconds\n   *  @return  {Number}\n   *  @private\n   */\n\n\n  Tone.Frequency.prototype._secondsToUnits = function (seconds) {\n    return 1 / seconds;\n  };\n  /**\n   *  The default units if none are given.\n   *  @private\n   */\n\n\n  Tone.Frequency.prototype._defaultUnits = \"hz\"; ///////////////////////////////////////////////////////////////////////////\n  //\tFREQUENCY CONVERSIONS\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  Note to scale index\n   *  @type  {Object}\n   */\n\n  var noteToScaleIndex = {\n    \"cbb\": -2,\n    \"cb\": -1,\n    \"c\": 0,\n    \"c#\": 1,\n    \"cx\": 2,\n    \"dbb\": 0,\n    \"db\": 1,\n    \"d\": 2,\n    \"d#\": 3,\n    \"dx\": 4,\n    \"ebb\": 2,\n    \"eb\": 3,\n    \"e\": 4,\n    \"e#\": 5,\n    \"ex\": 6,\n    \"fbb\": 3,\n    \"fb\": 4,\n    \"f\": 5,\n    \"f#\": 6,\n    \"fx\": 7,\n    \"gbb\": 5,\n    \"gb\": 6,\n    \"g\": 7,\n    \"g#\": 8,\n    \"gx\": 9,\n    \"abb\": 7,\n    \"ab\": 8,\n    \"a\": 9,\n    \"a#\": 10,\n    \"ax\": 11,\n    \"bbb\": 9,\n    \"bb\": 10,\n    \"b\": 11,\n    \"b#\": 12,\n    \"bx\": 13\n  };\n  /**\n   *  scale index to note (sharps)\n   *  @type  {Array}\n   */\n\n  var scaleIndexToNote = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n  /**\n   *  The [concert pitch](https://en.wikipedia.org/wiki/Concert_pitch)\n   *  A4's values in Hertz.\n   *  @type {Frequency}\n   *  @static\n   */\n\n  Tone.Frequency.A4 = 440;\n  /**\n   *  Convert a MIDI note to frequency value.\n   *  @param  {MIDI} midi The midi number to convert.\n   *  @return {Frequency} the corresponding frequency value\n   *  @static\n   *  @example\n   * Tone.Frequency.mtof(69); // returns 440\n   */\n\n  Tone.Frequency.mtof = function (midi) {\n    return Tone.Frequency.A4 * Math.pow(2, (midi - 69) / 12);\n  };\n  /**\n   *  Convert a frequency value to a MIDI note.\n   *  @param {Frequency} frequency The value to frequency value to convert.\n   *  @returns  {MIDI}\n   *  @static\n   *  @example\n   * Tone.Frequency.ftom(440); // returns 69\n   */\n\n\n  Tone.Frequency.ftom = function (frequency) {\n    return 69 + Math.round(12 * Math.log2(frequency / Tone.Frequency.A4));\n  };\n\n  return Tone.Frequency;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3R5cGUvRnJlcXVlbmN5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RvbmUvVG9uZS90eXBlL0ZyZXF1ZW5jeS5qcz82NjYxIl0sInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbXCJUb25lL2NvcmUvVG9uZVwiLCBcIlRvbmUvdHlwZS9UaW1lQmFzZVwiXSwgZnVuY3Rpb24oVG9uZSl7XG5cblx0LyoqXG5cdCAqICBAY2xhc3MgVG9uZS5GcmVxdWVuY3kgaXMgYSBwcmltaXRpdmUgdHlwZSBmb3IgZW5jb2RpbmcgRnJlcXVlbmN5IHZhbHVlcy5cblx0ICogICAgICAgICBFdmVudHVhbGx5IGFsbCB0aW1lIHZhbHVlcyBhcmUgZXZhbHVhdGVkIHRvIGhlcnR6XG5cdCAqICAgICAgICAgdXNpbmcgdGhlIGBldmFsYCBtZXRob2QuXG5cdCAqICBAY29uc3RydWN0b3Jcblx0ICogIEBleHRlbmRzIHtUb25lLlRpbWVCYXNlfVxuXHQgKiAgQHBhcmFtICB7U3RyaW5nfE51bWJlcn0gIHZhbCAgICBUaGUgdGltZSB2YWx1ZS5cblx0ICogIEBwYXJhbSAge1N0cmluZz19ICB1bml0cyAgVGhlIHVuaXRzIG9mIHRoZSB2YWx1ZS5cblx0ICogIEBleGFtcGxlXG5cdCAqIFRvbmUuRnJlcXVlbmN5KFwiQzNcIikgLy8gMjYxXG5cdCAqIFRvbmUuRnJlcXVlbmN5KDM4LCBcIm1pZGlcIikgLy9cblx0ICogVG9uZS5GcmVxdWVuY3koXCJDM1wiKS50cmFuc3Bvc2UoNCk7XG5cdCAqL1xuXHRUb25lLkZyZXF1ZW5jeSA9IGZ1bmN0aW9uKHZhbCwgdW5pdHMpe1xuXHRcdGlmICh0aGlzIGluc3RhbmNlb2YgVG9uZS5GcmVxdWVuY3kpe1xuXG5cdFx0XHRUb25lLlRpbWVCYXNlLmNhbGwodGhpcywgdmFsLCB1bml0cyk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG5ldyBUb25lLkZyZXF1ZW5jeSh2YWwsIHVuaXRzKTtcblx0XHR9XG5cdH07XG5cblx0VG9uZS5leHRlbmQoVG9uZS5GcmVxdWVuY3ksIFRvbmUuVGltZUJhc2UpO1xuXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvL1x0QVVHTUVOVCBCQVNFIEVYUFJFU1NJT05TXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cdFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS5fZXhwcmVzc2lvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fZXhwcmVzc2lvbnMsIHtcblx0XHRcIm1pZGlcIiA6IHtcblx0XHRcdHJlZ2V4cCA6IC9eKFxcZCsoPzpcXC5cXGQrKT9taWRpKS8sXG5cdFx0XHRtZXRob2QgOiBmdW5jdGlvbih2YWx1ZSl7XG5cdFx0XHRcdGlmICh0aGlzLl9kZWZhdWx0VW5pdHMgPT09IFwibWlkaVwiKXtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIFRvbmUuRnJlcXVlbmN5Lm10b2YodmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIm5vdGVcIiA6IHtcblx0XHRcdHJlZ2V4cCA6IC9eKFthLWddezF9KD86YnwjfHh8YmIpPykoLT9bMC05XSspL2ksXG5cdFx0XHRtZXRob2QgOiBmdW5jdGlvbihwaXRjaCwgb2N0YXZlKXtcblx0XHRcdFx0dmFyIGluZGV4ID0gbm90ZVRvU2NhbGVJbmRleFtwaXRjaC50b0xvd2VyQ2FzZSgpXTtcblx0XHRcdFx0dmFyIG5vdGVOdW1iZXIgPSBpbmRleCArIChwYXJzZUludChvY3RhdmUpICsgMSkgKiAxMjtcblx0XHRcdFx0aWYgKHRoaXMuX2RlZmF1bHRVbml0cyA9PT0gXCJtaWRpXCIpe1xuXHRcdFx0XHRcdHJldHVybiBub3RlTnVtYmVyO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBUb25lLkZyZXF1ZW5jeS5tdG9mKG5vdGVOdW1iZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInRyXCIgOiB7XG5cdFx0XHRyZWdleHAgOiAvXihcXGQrKD86XFwuXFxkKyk/KTooXFxkKyg/OlxcLlxcZCspPyk6PyhcXGQrKD86XFwuXFxkKyk/KT8vLFxuXHRcdFx0bWV0aG9kIDogZnVuY3Rpb24obSwgcSwgcyl7XG5cdFx0XHRcdHZhciB0b3RhbCA9IDE7XG5cdFx0XHRcdGlmIChtICYmIG0gIT09IFwiMFwiKXtcblx0XHRcdFx0XHR0b3RhbCAqPSB0aGlzLl9iZWF0c1RvVW5pdHModGhpcy5fZ2V0VGltZVNpZ25hdHVyZSgpICogcGFyc2VGbG9hdChtKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHEgJiYgcSAhPT0gXCIwXCIpe1xuXHRcdFx0XHRcdHRvdGFsICo9IHRoaXMuX2JlYXRzVG9Vbml0cyhwYXJzZUZsb2F0KHEpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocyAmJiBzICE9PSBcIjBcIil7XG5cdFx0XHRcdFx0dG90YWwgKj0gdGhpcy5fYmVhdHNUb1VuaXRzKHBhcnNlRmxvYXQocykgLyA0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdG90YWw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly9cdEVYUFJFU1NJT05TXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cdC8qKlxuXHQgKiAgVHJhbnNwb3NlcyB0aGUgZnJlcXVlbmN5IGJ5IHRoZSBnaXZlbiBudW1iZXIgb2Ygc2VtaXRvbmVzLlxuXHQgKiAgQHBhcmFtICB7SW50ZXJ2YWx9ICBpbnRlcnZhbFxuXHQgKiAgQHJldHVybiAge1RvbmUuRnJlcXVlbmN5fSBBIG5ldyB0cmFuc3Bvc2VkIGZyZXF1ZW5jeVxuXHQgKiAgQGV4YW1wbGVcblx0ICogVG9uZS5GcmVxdWVuY3koXCJBNFwiKS50cmFuc3Bvc2UoMyk7IC8vXCJDNVwiXG5cdCAqL1xuXHRUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUudHJhbnNwb3NlID0gZnVuY3Rpb24oaW50ZXJ2YWwpe1xuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnZhbHVlT2YoKSAqIFRvbmUuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvKGludGVydmFsKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqICBUYWtlcyBhbiBhcnJheSBvZiBzZW1pdG9uZSBpbnRlcnZhbHMgYW5kIHJldHVybnNcblx0ICogIGFuIGFycmF5IG9mIGZyZXF1ZW5jaWVzIHRyYW5zcG9zZWQgYnkgdGhvc2UgaW50ZXJ2YWxzLlxuXHQgKiAgQHBhcmFtICB7QXJyYXl9ICBpbnRlcnZhbHNcblx0ICogIEByZXR1cm4gIHtBcnJheTxUb25lLkZyZXF1ZW5jeT59IFJldHVybnMgYW4gYXJyYXkgb2YgRnJlcXVlbmNpZXNcblx0ICogIEBleGFtcGxlXG5cdCAqIFRvbmUuRnJlcXVlbmN5KFwiQTRcIikuaGFybW9uaXplKFswLCAzLCA3XSk7IC8vW1wiQTRcIiwgXCJDNVwiLCBcIkU1XCJdXG5cdCAqL1xuXHRUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUuaGFybW9uaXplID0gZnVuY3Rpb24oaW50ZXJ2YWxzKXtcblx0XHRyZXR1cm4gaW50ZXJ2YWxzLm1hcChmdW5jdGlvbihpbnRlcnZhbCl7XG5cdFx0XHRyZXR1cm4gdGhpcy50cmFuc3Bvc2UoaW50ZXJ2YWwpO1xuXHRcdH0uYmluZCh0aGlzKSk7XG5cdH07XG5cblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vXHRVTklUIENPTlZFUlNJT05TXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cdC8qKlxuXHQgKiAgUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZnJlcXVlbmN5IGFzIGEgTUlESSBub3RlXG5cdCAqICBAcmV0dXJuICB7TUlESX1cblx0ICogIEBleGFtcGxlXG5cdCAqIFRvbmUuRnJlcXVlbmN5KFwiQzRcIikudG9NaWRpKCk7IC8vNjBcblx0ICovXG5cdFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS50b01pZGkgPSBmdW5jdGlvbigpe1xuXHRcdHJldHVybiBUb25lLkZyZXF1ZW5jeS5mdG9tKHRoaXMudmFsdWVPZigpKTtcblx0fTtcblxuXHQvKipcblx0ICogIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZyZXF1ZW5jeSBpbiBTY2llbnRpZmljIFBpdGNoIE5vdGF0aW9uXG5cdCAqICBAcmV0dXJuICB7Tm90ZX1cblx0ICogIEBleGFtcGxlXG5cdCAqIFRvbmUuRnJlcXVlbmN5KDY5LCBcIm1pZGlcIikudG9Ob3RlKCk7IC8vXCJBNFwiXG5cdCAqL1xuXHRUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUudG9Ob3RlID0gZnVuY3Rpb24oKXtcblx0XHR2YXIgZnJlcSA9IHRoaXMudG9GcmVxdWVuY3koKTtcblx0XHR2YXIgbG9nID0gTWF0aC5sb2cyKGZyZXEgLyBUb25lLkZyZXF1ZW5jeS5BNCk7XG5cdFx0dmFyIG5vdGVOdW1iZXIgPSBNYXRoLnJvdW5kKDEyICogbG9nKSArIDU3O1xuXHRcdHZhciBvY3RhdmUgPSBNYXRoLmZsb29yKG5vdGVOdW1iZXIvMTIpO1xuXHRcdGlmIChvY3RhdmUgPCAwKXtcblx0XHRcdG5vdGVOdW1iZXIgKz0gLTEyICogb2N0YXZlO1xuXHRcdH1cblx0XHR2YXIgbm90ZU5hbWUgPSBzY2FsZUluZGV4VG9Ob3RlW25vdGVOdW1iZXIgJSAxMl07XG5cdFx0cmV0dXJuIG5vdGVOYW1lICsgb2N0YXZlLnRvU3RyaW5nKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqICBSZXR1cm4gdGhlIGR1cmF0aW9uIG9mIG9uZSBjeWNsZSBpbiBzZWNvbmRzLlxuXHQgKiAgQHJldHVybiAge1NlY29uZHN9XG5cdCAqL1xuXHRUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUudG9TZWNvbmRzID0gZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gMSAvIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLnRvU2Vjb25kcy5jYWxsKHRoaXMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgUmV0dXJuIHRoZSB2YWx1ZSBpbiBIZXJ0elxuXHQgKiAgQHJldHVybiAge0ZyZXF1ZW5jeX1cblx0ICovXG5cdFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS50b0ZyZXF1ZW5jeSA9IGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLnRvRnJlcXVlbmN5LmNhbGwodGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqICBSZXR1cm4gdGhlIGR1cmF0aW9uIG9mIG9uZSBjeWNsZSBpbiB0aWNrc1xuXHQgKiAgQHJldHVybiAge1RpY2tzfVxuXHQgKi9cblx0VG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLnRvVGlja3MgPSBmdW5jdGlvbigpe1xuXHRcdHZhciBxdWFydGVyVGltZSA9IHRoaXMuX2JlYXRzVG9Vbml0cygxKTtcblx0XHR2YXIgcXVhcnRlcnMgPSB0aGlzLnZhbHVlT2YoKSAvIHF1YXJ0ZXJUaW1lO1xuXHRcdHJldHVybiBNYXRoLmZsb29yKHF1YXJ0ZXJzICogVG9uZS5UcmFuc3BvcnQuUFBRKTtcblx0fTtcblxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly9cdFVOSVQgQ09OVkVSU0lPTlMgSEVMUEVSU1xuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHQvKipcblx0ICogIFdpdGggbm8gYXJndW1lbnRzLCByZXR1cm4gMFxuXHQgKiAgQHJldHVybiAge051bWJlcn1cblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUuX25vQXJnID0gZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gMDtcblx0fTtcblxuXHQvKipcblx0ICogIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgZnJlcXVlbmN5IGluIHRoZSBjdXJyZW50IHVuaXRzXG5cdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gZnJlcVxuXHQgKiAgQHJldHVybiAge051bWJlcn1cblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUuX2ZyZXF1ZW5jeVRvVW5pdHMgPSBmdW5jdGlvbihmcmVxKXtcblx0XHRyZXR1cm4gZnJlcTtcblx0fTtcblxuXHQvKipcblx0ICogIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgdGljayBpbiB0aGUgY3VycmVudCB0aW1lIHVuaXRzXG5cdCAqICBAcGFyYW0ge1RpY2tzfSB0aWNrc1xuXHQgKiAgQHJldHVybiAge051bWJlcn1cblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUuX3RpY2tzVG9Vbml0cyA9IGZ1bmN0aW9uKHRpY2tzKXtcblx0XHRyZXR1cm4gMSAvICgodGlja3MgKiA2MCkgLyAoVG9uZS5UcmFuc3BvcnQuYnBtLnZhbHVlICogVG9uZS5UcmFuc3BvcnQuUFBRKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqICBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBiZWF0cyBpbiB0aGUgY3VycmVudCB1bml0c1xuXHQgKiAgQHBhcmFtIHtOdW1iZXJ9IGJlYXRzXG5cdCAqICBAcmV0dXJuICB7TnVtYmVyfVxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS5fYmVhdHNUb1VuaXRzID0gZnVuY3Rpb24oYmVhdHMpe1xuXHRcdHJldHVybiAxIC8gVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX2JlYXRzVG9Vbml0cy5jYWxsKHRoaXMsIGJlYXRzKTtcblx0fTtcblxuXHQvKipcblx0ICogIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgc2Vjb25kIGluIHRoZSBjdXJyZW50IHVuaXRzXG5cdCAqICBAcGFyYW0ge1NlY29uZHN9IHNlY29uZHNcblx0ICogIEByZXR1cm4gIHtOdW1iZXJ9XG5cdCAqICBAcHJpdmF0ZVxuXHQgKi9cblx0VG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLl9zZWNvbmRzVG9Vbml0cyA9IGZ1bmN0aW9uKHNlY29uZHMpe1xuXHRcdHJldHVybiAxIC8gc2Vjb25kcztcblx0fTtcblxuXHQvKipcblx0ICogIFRoZSBkZWZhdWx0IHVuaXRzIGlmIG5vbmUgYXJlIGdpdmVuLlxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS5fZGVmYXVsdFVuaXRzID0gXCJoelwiO1xuXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvL1x0RlJFUVVFTkNZIENPTlZFUlNJT05TXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cdC8qKlxuXHQgKiAgTm90ZSB0byBzY2FsZSBpbmRleFxuXHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdCAqL1xuXHR2YXIgbm90ZVRvU2NhbGVJbmRleCA9IHtcblx0XHRcImNiYlwiIDogLTIsIFwiY2JcIiA6IC0xLCBcImNcIiA6IDAsIFwiYyNcIiA6IDEsIFwiY3hcIiA6IDIsXG5cdFx0XCJkYmJcIiA6IDAsIFwiZGJcIiA6IDEsIFwiZFwiIDogMiwgXCJkI1wiIDogMywgXCJkeFwiIDogNCxcblx0XHRcImViYlwiIDogMiwgXCJlYlwiIDogMywgXCJlXCIgOiA0LCBcImUjXCIgOiA1LCBcImV4XCIgOiA2LFxuXHRcdFwiZmJiXCIgOiAzLCBcImZiXCIgOiA0LCBcImZcIiA6IDUsIFwiZiNcIiA6IDYsIFwiZnhcIiA6IDcsXG5cdFx0XCJnYmJcIiA6IDUsIFwiZ2JcIiA6IDYsIFwiZ1wiIDogNywgXCJnI1wiIDogOCwgXCJneFwiIDogOSxcblx0XHRcImFiYlwiIDogNywgXCJhYlwiIDogOCwgXCJhXCIgOiA5LCBcImEjXCIgOiAxMCwgXCJheFwiIDogMTEsXG5cdFx0XCJiYmJcIiA6IDksIFwiYmJcIiA6IDEwLCBcImJcIiA6IDExLCBcImIjXCIgOiAxMiwgXCJieFwiIDogMTMsXG5cdH07XG5cblx0LyoqXG5cdCAqICBzY2FsZSBpbmRleCB0byBub3RlIChzaGFycHMpXG5cdCAqICBAdHlwZSAge0FycmF5fVxuXHQgKi9cblx0dmFyIHNjYWxlSW5kZXhUb05vdGUgPSBbXCJDXCIsIFwiQyNcIiwgXCJEXCIsIFwiRCNcIiwgXCJFXCIsIFwiRlwiLCBcIkYjXCIsIFwiR1wiLCBcIkcjXCIsIFwiQVwiLCBcIkEjXCIsIFwiQlwiXTtcblxuXHQvKipcblx0ICogIFRoZSBbY29uY2VydCBwaXRjaF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uY2VydF9waXRjaClcblx0ICogIEE0J3MgdmFsdWVzIGluIEhlcnR6LlxuXHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0ICogIEBzdGF0aWNcblx0ICovXG5cdFRvbmUuRnJlcXVlbmN5LkE0ID0gNDQwO1xuXG5cdC8qKlxuXHQgKiAgQ29udmVydCBhIE1JREkgbm90ZSB0byBmcmVxdWVuY3kgdmFsdWUuXG5cdCAqICBAcGFyYW0gIHtNSURJfSBtaWRpIFRoZSBtaWRpIG51bWJlciB0byBjb252ZXJ0LlxuXHQgKiAgQHJldHVybiB7RnJlcXVlbmN5fSB0aGUgY29ycmVzcG9uZGluZyBmcmVxdWVuY3kgdmFsdWVcblx0ICogIEBzdGF0aWNcblx0ICogIEBleGFtcGxlXG5cdCAqIFRvbmUuRnJlcXVlbmN5Lm10b2YoNjkpOyAvLyByZXR1cm5zIDQ0MFxuXHQgKi9cblx0VG9uZS5GcmVxdWVuY3kubXRvZiA9IGZ1bmN0aW9uKG1pZGkpe1xuXHRcdHJldHVybiBUb25lLkZyZXF1ZW5jeS5BNCAqIE1hdGgucG93KDIsIChtaWRpIC0gNjkpIC8gMTIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgQ29udmVydCBhIGZyZXF1ZW5jeSB2YWx1ZSB0byBhIE1JREkgbm90ZS5cblx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBmcmVxdWVuY3kgVGhlIHZhbHVlIHRvIGZyZXF1ZW5jeSB2YWx1ZSB0byBjb252ZXJ0LlxuXHQgKiAgQHJldHVybnMgIHtNSURJfVxuXHQgKiAgQHN0YXRpY1xuXHQgKiAgQGV4YW1wbGVcblx0ICogVG9uZS5GcmVxdWVuY3kuZnRvbSg0NDApOyAvLyByZXR1cm5zIDY5XG5cdCAqL1xuXHRUb25lLkZyZXF1ZW5jeS5mdG9tID0gZnVuY3Rpb24oZnJlcXVlbmN5KXtcblx0XHRyZXR1cm4gNjkgKyBNYXRoLnJvdW5kKDEyICogTWF0aC5sb2cyKGZyZXF1ZW5jeSAvIFRvbmUuRnJlcXVlbmN5LkE0KSk7XG5cdH07XG5cblx0cmV0dXJuIFRvbmUuRnJlcXVlbmN5O1xufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUFBO0FBRkE7QUFVQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFBQTtBQUZBO0FBWUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBYkE7QUFBQTtBQUZBO0FBdkJBO0FBMENBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFQQTtBQVVBOzs7OztBQUlBO0FBRUE7Ozs7Ozs7QUFNQTtBQUVBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/type/Frequency.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/type/Ticks.js":
/*!**********************************************!*\
  !*** ./node_modules/tone/Tone/type/Ticks.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/type/TransportTime */ \"./node_modules/tone/Tone/type/TransportTime.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  /**\n   *  @class Tone.Ticks is a primitive type for encoding Time values.\n   *         Tone.Ticks can be constructed with or without the `new` keyword. Tone.Ticks can be passed\n   *         into the parameter of any method which takes time as an argument.\n   *  @constructor\n   *  @extends {Tone.TransportTime}\n   *  @param  {String|Number}  val    The time value.\n   *  @param  {String=}  units  The units of the value.\n   *  @example\n   * var t = Tone.Ticks(\"4n\");//a quarter note\n   */\n  Tone.Ticks = function (val, units) {\n    if (this instanceof Tone.Ticks) {\n      Tone.TransportTime.call(this, val, units);\n    } else {\n      return new Tone.Ticks(val, units);\n    }\n  };\n\n  Tone.extend(Tone.Ticks, Tone.TransportTime);\n  /**\n   *  The default units if none are given.\n   *  @type {String}\n   *  @private\n   */\n\n  Tone.Ticks.prototype._defaultUnits = \"i\";\n  /**\n   * Get the current time in the given units\n   * @return {Ticks}\n   * @private\n   */\n\n  Tone.Ticks.prototype._now = function () {\n    return Tone.Transport.ticks;\n  };\n  /**\n   *  Return the value of the beats in the current units\n   *  @param {Number} beats\n   *  @return  {Number}\n   *  @private\n   */\n\n\n  Tone.Ticks.prototype._beatsToUnits = function (beats) {\n    return this._getPPQ() * beats;\n  };\n  /**\n   *  Returns the value of a second in the current units\n   *  @param {Seconds} seconds\n   *  @return  {Number}\n   *  @private\n   */\n\n\n  Tone.Ticks.prototype._secondsToUnits = function (seconds) {\n    return seconds / (60 / this._getBpm()) * this._getPPQ();\n  };\n  /**\n   *  Returns the value of a tick in the current time units\n   *  @param {Ticks} ticks\n   *  @return  {Number}\n   *  @private\n   */\n\n\n  Tone.Ticks.prototype._ticksToUnits = function (ticks) {\n    return ticks;\n  };\n  /**\n   *  Return the time in ticks\n   *  @return  {Ticks}\n   */\n\n\n  Tone.Ticks.prototype.toTicks = function () {\n    return this.valueOf();\n  };\n  /**\n   *  Return the time in ticks\n   *  @return  {Ticks}\n   */\n\n\n  Tone.Ticks.prototype.toSeconds = function () {\n    return this.valueOf() / this._getPPQ() * (60 / this._getBpm());\n  };\n\n  return Tone.Ticks;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3R5cGUvVGlja3MuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3R5cGUvVGlja3MuanM/YjZjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoW1wiVG9uZS9jb3JlL1RvbmVcIiwgXCJUb25lL3R5cGUvVHJhbnNwb3J0VGltZVwiXSwgZnVuY3Rpb24oVG9uZSl7XG5cblx0LyoqXG5cdCAqICBAY2xhc3MgVG9uZS5UaWNrcyBpcyBhIHByaW1pdGl2ZSB0eXBlIGZvciBlbmNvZGluZyBUaW1lIHZhbHVlcy5cblx0ICogICAgICAgICBUb25lLlRpY2tzIGNhbiBiZSBjb25zdHJ1Y3RlZCB3aXRoIG9yIHdpdGhvdXQgdGhlIGBuZXdgIGtleXdvcmQuIFRvbmUuVGlja3MgY2FuIGJlIHBhc3NlZFxuXHQgKiAgICAgICAgIGludG8gdGhlIHBhcmFtZXRlciBvZiBhbnkgbWV0aG9kIHdoaWNoIHRha2VzIHRpbWUgYXMgYW4gYXJndW1lbnQuXG5cdCAqICBAY29uc3RydWN0b3Jcblx0ICogIEBleHRlbmRzIHtUb25lLlRyYW5zcG9ydFRpbWV9XG5cdCAqICBAcGFyYW0gIHtTdHJpbmd8TnVtYmVyfSAgdmFsICAgIFRoZSB0aW1lIHZhbHVlLlxuXHQgKiAgQHBhcmFtICB7U3RyaW5nPX0gIHVuaXRzICBUaGUgdW5pdHMgb2YgdGhlIHZhbHVlLlxuXHQgKiAgQGV4YW1wbGVcblx0ICogdmFyIHQgPSBUb25lLlRpY2tzKFwiNG5cIik7Ly9hIHF1YXJ0ZXIgbm90ZVxuXHQgKi9cblx0VG9uZS5UaWNrcyA9IGZ1bmN0aW9uKHZhbCwgdW5pdHMpe1xuXHRcdGlmICh0aGlzIGluc3RhbmNlb2YgVG9uZS5UaWNrcyl7XG5cblx0XHRcdFRvbmUuVHJhbnNwb3J0VGltZS5jYWxsKHRoaXMsIHZhbCwgdW5pdHMpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBuZXcgVG9uZS5UaWNrcyh2YWwsIHVuaXRzKTtcblx0XHR9XG5cdH07XG5cblx0VG9uZS5leHRlbmQoVG9uZS5UaWNrcywgVG9uZS5UcmFuc3BvcnRUaW1lKTtcblxuXHQvKipcblx0ICogIFRoZSBkZWZhdWx0IHVuaXRzIGlmIG5vbmUgYXJlIGdpdmVuLlxuXHQgKiAgQHR5cGUge1N0cmluZ31cblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLlRpY2tzLnByb3RvdHlwZS5fZGVmYXVsdFVuaXRzID0gXCJpXCI7XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgY3VycmVudCB0aW1lIGluIHRoZSBnaXZlbiB1bml0c1xuXHQgKiBAcmV0dXJuIHtUaWNrc31cblx0ICogQHByaXZhdGVcblx0ICovXG5cdFRvbmUuVGlja3MucHJvdG90eXBlLl9ub3cgPSBmdW5jdGlvbigpe1xuXHRcdHJldHVybiBUb25lLlRyYW5zcG9ydC50aWNrcztcblx0fTtcblxuXHQvKipcblx0ICogIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGJlYXRzIGluIHRoZSBjdXJyZW50IHVuaXRzXG5cdCAqICBAcGFyYW0ge051bWJlcn0gYmVhdHNcblx0ICogIEByZXR1cm4gIHtOdW1iZXJ9XG5cdCAqICBAcHJpdmF0ZVxuXHQgKi9cblx0VG9uZS5UaWNrcy5wcm90b3R5cGUuX2JlYXRzVG9Vbml0cyA9IGZ1bmN0aW9uKGJlYXRzKXtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0UFBRKCkgKiBiZWF0cztcblx0fTtcblxuXHQvKipcblx0ICogIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgc2Vjb25kIGluIHRoZSBjdXJyZW50IHVuaXRzXG5cdCAqICBAcGFyYW0ge1NlY29uZHN9IHNlY29uZHNcblx0ICogIEByZXR1cm4gIHtOdW1iZXJ9XG5cdCAqICBAcHJpdmF0ZVxuXHQgKi9cblx0VG9uZS5UaWNrcy5wcm90b3R5cGUuX3NlY29uZHNUb1VuaXRzID0gZnVuY3Rpb24oc2Vjb25kcyl7XG5cdFx0cmV0dXJuIHNlY29uZHMgLyAoNjAgLyB0aGlzLl9nZXRCcG0oKSkgKiB0aGlzLl9nZXRQUFEoKTtcblx0fTtcblxuXHQvKipcblx0ICogIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgdGljayBpbiB0aGUgY3VycmVudCB0aW1lIHVuaXRzXG5cdCAqICBAcGFyYW0ge1RpY2tzfSB0aWNrc1xuXHQgKiAgQHJldHVybiAge051bWJlcn1cblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLlRpY2tzLnByb3RvdHlwZS5fdGlja3NUb1VuaXRzID0gZnVuY3Rpb24odGlja3Mpe1xuXHRcdHJldHVybiB0aWNrcztcblx0fTtcblxuXHQvKipcblx0ICogIFJldHVybiB0aGUgdGltZSBpbiB0aWNrc1xuXHQgKiAgQHJldHVybiAge1RpY2tzfVxuXHQgKi9cblx0VG9uZS5UaWNrcy5wcm90b3R5cGUudG9UaWNrcyA9IGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVPZigpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgUmV0dXJuIHRoZSB0aW1lIGluIHRpY2tzXG5cdCAqICBAcmV0dXJuICB7VGlja3N9XG5cdCAqL1xuXHRUb25lLlRpY2tzLnByb3RvdHlwZS50b1NlY29uZHMgPSBmdW5jdGlvbigpe1xuXHRcdHJldHVybiAodGhpcy52YWx1ZU9mKCkgLyB0aGlzLl9nZXRQUFEoKSkgKiAoNjAgLyB0aGlzLl9nZXRCcG0oKSk7XG5cdH07XG5cblx0cmV0dXJuIFRvbmUuVGlja3M7XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBS0E7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/type/Ticks.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/type/Time.js":
/*!*********************************************!*\
  !*** ./node_modules/tone/Tone/type/Time.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/type/TimeBase */ \"./node_modules/tone/Tone/type/TimeBase.js\"), __webpack_require__(/*! Tone/type/Frequency */ \"./node_modules/tone/Tone/type/Frequency.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  /**\n   *  @class Tone.Time is a primitive type for encoding Time values.\n   *         Tone.Time can be constructed with or without the `new` keyword. Tone.Time can be passed\n   *         into the parameter of any method which takes time as an argument.\n   *  @constructor\n   *  @extends {Tone.TimeBase}\n   *  @param  {String|Number}  val    The time value.\n   *  @param  {String=}  units  The units of the value.\n   *  @example\n   * var t = Tone.Time(\"4n\");//a quarter note\n   */\n  Tone.Time = function (val, units) {\n    if (this instanceof Tone.Time) {\n      Tone.TimeBase.call(this, val, units);\n    } else {\n      return new Tone.Time(val, units);\n    }\n  };\n\n  Tone.extend(Tone.Time, Tone.TimeBase);\n  /**\n   * Extend the base expressions\n   */\n\n  Tone.Time.prototype._expressions = Object.assign({}, Tone.TimeBase.prototype._expressions, {\n    \"quantize\": {\n      regexp: /^@(.+)/,\n      method: function () {\n        function method(capture) {\n          if (Tone.Transport) {\n            var quantTo = new this.constructor(capture);\n            return Tone.Transport.nextSubdivision(quantTo);\n          } else {\n            return 0;\n          }\n        }\n\n        return method;\n      }()\n    },\n    \"now\": {\n      regexp: /^\\+(.+)/,\n      method: function () {\n        function method(capture) {\n          return this._now() + new this.constructor(capture);\n        }\n\n        return method;\n      }()\n    }\n  });\n  /**\n   *  Quantize the time by the given subdivision. Optionally add a\n   *  percentage which will move the time value towards the ideal\n   *  quantized value by that percentage.\n   *  @param  {Number|Time}  val    The subdivision to quantize to\n   *  @param  {NormalRange}  [percent=1]  Move the time value\n   *                                   towards the quantized value by\n   *                                   a percentage.\n   *  @return  {Number}  this\n   *  @example\n   * Tone.Time(21).quantize(2) //returns 22\n   * Tone.Time(0.6).quantize(\"4n\", 0.5) //returns 0.55\n   */\n\n  Tone.Time.prototype.quantize = function (subdiv, percent) {\n    percent = Tone.defaultArg(percent, 1);\n    var subdivision = new this.constructor(subdiv);\n    var value = this.valueOf();\n    var multiple = Math.round(value / subdivision);\n    var ideal = multiple * subdivision;\n    var diff = ideal - value;\n    return value + diff * percent;\n  }; ///////////////////////////////////////////////////////////////////////////\n  // CONVERSIONS\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  Convert a Time to Notation. The notation values are will be the\n   *  closest representation between 1m to 128th note.\n   *  @return {Notation}\n   *  @example\n   * //if the Transport is at 120bpm:\n   * Tone.Time(2).toNotation();//returns \"1m\"\n   */\n\n\n  Tone.Time.prototype.toNotation = function () {\n    var time = this.toSeconds();\n    var testNotations = [\"1m\"];\n\n    for (var power = 1; power < 8; power++) {\n      var subdiv = Math.pow(2, power);\n      testNotations.push(subdiv + \"n.\");\n      testNotations.push(subdiv + \"n\");\n      testNotations.push(subdiv + \"t\");\n    }\n\n    testNotations.push(\"0\"); //find the closets notation representation\n\n    var closest = testNotations[0];\n    var closestSeconds = Tone.Time(testNotations[0]).toSeconds();\n    testNotations.forEach(function (notation) {\n      var notationSeconds = Tone.Time(notation).toSeconds();\n\n      if (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {\n        closest = notation;\n        closestSeconds = notationSeconds;\n      }\n    });\n    return closest;\n  };\n  /**\n   *  Return the time encoded as Bars:Beats:Sixteenths.\n   *  @return  {BarsBeatsSixteenths}\n   */\n\n\n  Tone.Time.prototype.toBarsBeatsSixteenths = function () {\n    var quarterTime = this._beatsToUnits(1);\n\n    var quarters = this.valueOf() / quarterTime;\n    var measures = Math.floor(quarters / this._getTimeSignature());\n    var sixteenths = quarters % 1 * 4;\n    quarters = Math.floor(quarters) % this._getTimeSignature();\n    sixteenths = sixteenths.toString();\n\n    if (sixteenths.length > 3) {\n      // the additional parseFloat removes insignificant trailing zeroes\n      sixteenths = parseFloat(parseFloat(sixteenths).toFixed(3));\n    }\n\n    var progress = [measures, quarters, sixteenths];\n    return progress.join(\":\");\n  };\n  /**\n   *  Return the time in ticks.\n   *  @return  {Ticks}\n   */\n\n\n  Tone.Time.prototype.toTicks = function () {\n    var quarterTime = this._beatsToUnits(1);\n\n    var quarters = this.valueOf() / quarterTime;\n    return Math.round(quarters * this._getPPQ());\n  };\n  /**\n   *  Return the time in seconds.\n   *  @return  {Seconds}\n   */\n\n\n  Tone.Time.prototype.toSeconds = function () {\n    return this.valueOf();\n  };\n  /**\n   *  Return the value as a midi note.\n   *  @return  {Midi}\n   */\n\n\n  Tone.Time.prototype.toMidi = function () {\n    return Tone.Frequency.ftom(this.toFrequency());\n  };\n\n  return Tone.Time;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3R5cGUvVGltZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90b25lL1RvbmUvdHlwZS9UaW1lLmpzPzk3YzIiXSwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFtcIlRvbmUvY29yZS9Ub25lXCIsIFwiVG9uZS90eXBlL1RpbWVCYXNlXCIsIFwiVG9uZS90eXBlL0ZyZXF1ZW5jeVwiXSwgZnVuY3Rpb24oVG9uZSl7XG5cblx0LyoqXG5cdCAqICBAY2xhc3MgVG9uZS5UaW1lIGlzIGEgcHJpbWl0aXZlIHR5cGUgZm9yIGVuY29kaW5nIFRpbWUgdmFsdWVzLlxuXHQgKiAgICAgICAgIFRvbmUuVGltZSBjYW4gYmUgY29uc3RydWN0ZWQgd2l0aCBvciB3aXRob3V0IHRoZSBgbmV3YCBrZXl3b3JkLiBUb25lLlRpbWUgY2FuIGJlIHBhc3NlZFxuXHQgKiAgICAgICAgIGludG8gdGhlIHBhcmFtZXRlciBvZiBhbnkgbWV0aG9kIHdoaWNoIHRha2VzIHRpbWUgYXMgYW4gYXJndW1lbnQuXG5cdCAqICBAY29uc3RydWN0b3Jcblx0ICogIEBleHRlbmRzIHtUb25lLlRpbWVCYXNlfVxuXHQgKiAgQHBhcmFtICB7U3RyaW5nfE51bWJlcn0gIHZhbCAgICBUaGUgdGltZSB2YWx1ZS5cblx0ICogIEBwYXJhbSAge1N0cmluZz19ICB1bml0cyAgVGhlIHVuaXRzIG9mIHRoZSB2YWx1ZS5cblx0ICogIEBleGFtcGxlXG5cdCAqIHZhciB0ID0gVG9uZS5UaW1lKFwiNG5cIik7Ly9hIHF1YXJ0ZXIgbm90ZVxuXHQgKi9cblx0VG9uZS5UaW1lID0gZnVuY3Rpb24odmFsLCB1bml0cyl7XG5cdFx0aWYgKHRoaXMgaW5zdGFuY2VvZiBUb25lLlRpbWUpe1xuXG5cdFx0XHRUb25lLlRpbWVCYXNlLmNhbGwodGhpcywgdmFsLCB1bml0cyk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG5ldyBUb25lLlRpbWUodmFsLCB1bml0cyk7XG5cdFx0fVxuXHR9O1xuXG5cdFRvbmUuZXh0ZW5kKFRvbmUuVGltZSwgVG9uZS5UaW1lQmFzZSk7XG5cblx0LyoqXG5cdCAqIEV4dGVuZCB0aGUgYmFzZSBleHByZXNzaW9uc1xuXHQgKi9cblx0VG9uZS5UaW1lLnByb3RvdHlwZS5fZXhwcmVzc2lvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fZXhwcmVzc2lvbnMsIHtcblx0XHRcInF1YW50aXplXCIgOiB7XG5cdFx0XHRyZWdleHAgOiAvXkAoLispLyxcblx0XHRcdG1ldGhvZCA6IGZ1bmN0aW9uKGNhcHR1cmUpe1xuXHRcdFx0XHRpZiAoVG9uZS5UcmFuc3BvcnQpe1xuXHRcdFx0XHRcdHZhciBxdWFudFRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoY2FwdHVyZSk7XG5cdFx0XHRcdFx0cmV0dXJuIFRvbmUuVHJhbnNwb3J0Lm5leHRTdWJkaXZpc2lvbihxdWFudFRvKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJub3dcIiA6IHtcblx0XHRcdHJlZ2V4cCA6IC9eXFwrKC4rKS8sXG5cdFx0XHRtZXRob2QgOiBmdW5jdGlvbihjYXB0dXJlKXtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX25vdygpICsgKG5ldyB0aGlzLmNvbnN0cnVjdG9yKGNhcHR1cmUpKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiAgUXVhbnRpemUgdGhlIHRpbWUgYnkgdGhlIGdpdmVuIHN1YmRpdmlzaW9uLiBPcHRpb25hbGx5IGFkZCBhXG5cdCAqICBwZXJjZW50YWdlIHdoaWNoIHdpbGwgbW92ZSB0aGUgdGltZSB2YWx1ZSB0b3dhcmRzIHRoZSBpZGVhbFxuXHQgKiAgcXVhbnRpemVkIHZhbHVlIGJ5IHRoYXQgcGVyY2VudGFnZS5cblx0ICogIEBwYXJhbSAge051bWJlcnxUaW1lfSAgdmFsICAgIFRoZSBzdWJkaXZpc2lvbiB0byBxdWFudGl6ZSB0b1xuXHQgKiAgQHBhcmFtICB7Tm9ybWFsUmFuZ2V9ICBbcGVyY2VudD0xXSAgTW92ZSB0aGUgdGltZSB2YWx1ZVxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG93YXJkcyB0aGUgcXVhbnRpemVkIHZhbHVlIGJ5XG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIHBlcmNlbnRhZ2UuXG5cdCAqICBAcmV0dXJuICB7TnVtYmVyfSAgdGhpc1xuXHQgKiAgQGV4YW1wbGVcblx0ICogVG9uZS5UaW1lKDIxKS5xdWFudGl6ZSgyKSAvL3JldHVybnMgMjJcblx0ICogVG9uZS5UaW1lKDAuNikucXVhbnRpemUoXCI0blwiLCAwLjUpIC8vcmV0dXJucyAwLjU1XG5cdCAqL1xuXHRUb25lLlRpbWUucHJvdG90eXBlLnF1YW50aXplID0gZnVuY3Rpb24oc3ViZGl2LCBwZXJjZW50KXtcblx0XHRwZXJjZW50ID0gVG9uZS5kZWZhdWx0QXJnKHBlcmNlbnQsIDEpO1xuXHRcdHZhciBzdWJkaXZpc2lvbiA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHN1YmRpdik7XG5cdFx0dmFyIHZhbHVlID0gdGhpcy52YWx1ZU9mKCk7XG5cdFx0dmFyIG11bHRpcGxlID0gTWF0aC5yb3VuZCh2YWx1ZSAvIHN1YmRpdmlzaW9uKTtcblx0XHR2YXIgaWRlYWwgPSBtdWx0aXBsZSAqIHN1YmRpdmlzaW9uO1xuXHRcdHZhciBkaWZmID0gaWRlYWwgLSB2YWx1ZTtcblx0XHRyZXR1cm4gdmFsdWUgKyBkaWZmICogcGVyY2VudDtcblx0fTtcblxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly8gQ09OVkVSU0lPTlNcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblx0LyoqXG5cdCAqICBDb252ZXJ0IGEgVGltZSB0byBOb3RhdGlvbi4gVGhlIG5vdGF0aW9uIHZhbHVlcyBhcmUgd2lsbCBiZSB0aGVcblx0ICogIGNsb3Nlc3QgcmVwcmVzZW50YXRpb24gYmV0d2VlbiAxbSB0byAxMjh0aCBub3RlLlxuXHQgKiAgQHJldHVybiB7Tm90YXRpb259XG5cdCAqICBAZXhhbXBsZVxuXHQgKiAvL2lmIHRoZSBUcmFuc3BvcnQgaXMgYXQgMTIwYnBtOlxuXHQgKiBUb25lLlRpbWUoMikudG9Ob3RhdGlvbigpOy8vcmV0dXJucyBcIjFtXCJcblx0ICovXG5cdFRvbmUuVGltZS5wcm90b3R5cGUudG9Ob3RhdGlvbiA9IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIHRpbWUgPSB0aGlzLnRvU2Vjb25kcygpO1xuXHRcdHZhciB0ZXN0Tm90YXRpb25zID0gW1wiMW1cIl07XG5cdFx0Zm9yICh2YXIgcG93ZXIgPSAxOyBwb3dlciA8IDg7IHBvd2VyKyspe1xuXHRcdFx0dmFyIHN1YmRpdiA9IE1hdGgucG93KDIsIHBvd2VyKTtcblx0XHRcdHRlc3ROb3RhdGlvbnMucHVzaChzdWJkaXYgKyBcIm4uXCIpO1xuXHRcdFx0dGVzdE5vdGF0aW9ucy5wdXNoKHN1YmRpdiArIFwiblwiKTtcblx0XHRcdHRlc3ROb3RhdGlvbnMucHVzaChzdWJkaXYgKyBcInRcIik7XG5cdFx0fVxuXHRcdHRlc3ROb3RhdGlvbnMucHVzaChcIjBcIik7XG5cdFx0Ly9maW5kIHRoZSBjbG9zZXRzIG5vdGF0aW9uIHJlcHJlc2VudGF0aW9uXG5cdFx0dmFyIGNsb3Nlc3QgPSB0ZXN0Tm90YXRpb25zWzBdO1xuXHRcdHZhciBjbG9zZXN0U2Vjb25kcyA9IFRvbmUuVGltZSh0ZXN0Tm90YXRpb25zWzBdKS50b1NlY29uZHMoKTtcblx0XHR0ZXN0Tm90YXRpb25zLmZvckVhY2goZnVuY3Rpb24obm90YXRpb24pe1xuXHRcdFx0dmFyIG5vdGF0aW9uU2Vjb25kcyA9IFRvbmUuVGltZShub3RhdGlvbikudG9TZWNvbmRzKCk7XG5cdFx0XHRpZiAoTWF0aC5hYnMobm90YXRpb25TZWNvbmRzIC0gdGltZSkgPCBNYXRoLmFicyhjbG9zZXN0U2Vjb25kcyAtIHRpbWUpKXtcblx0XHRcdFx0Y2xvc2VzdCA9IG5vdGF0aW9uO1xuXHRcdFx0XHRjbG9zZXN0U2Vjb25kcyA9IG5vdGF0aW9uU2Vjb25kcztcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gY2xvc2VzdDtcblx0fTtcblxuXHQvKipcblx0ICogIFJldHVybiB0aGUgdGltZSBlbmNvZGVkIGFzIEJhcnM6QmVhdHM6U2l4dGVlbnRocy5cblx0ICogIEByZXR1cm4gIHtCYXJzQmVhdHNTaXh0ZWVudGhzfVxuXHQgKi9cblx0VG9uZS5UaW1lLnByb3RvdHlwZS50b0JhcnNCZWF0c1NpeHRlZW50aHMgPSBmdW5jdGlvbigpe1xuXHRcdHZhciBxdWFydGVyVGltZSA9IHRoaXMuX2JlYXRzVG9Vbml0cygxKTtcblx0XHR2YXIgcXVhcnRlcnMgPSB0aGlzLnZhbHVlT2YoKSAvIHF1YXJ0ZXJUaW1lO1xuXHRcdHZhciBtZWFzdXJlcyA9IE1hdGguZmxvb3IocXVhcnRlcnMgLyB0aGlzLl9nZXRUaW1lU2lnbmF0dXJlKCkpO1xuXHRcdHZhciBzaXh0ZWVudGhzID0gKHF1YXJ0ZXJzICUgMSkgKiA0O1xuXHRcdHF1YXJ0ZXJzID0gTWF0aC5mbG9vcihxdWFydGVycykgJSB0aGlzLl9nZXRUaW1lU2lnbmF0dXJlKCk7XG5cdFx0c2l4dGVlbnRocyA9IHNpeHRlZW50aHMudG9TdHJpbmcoKTtcblx0XHRpZiAoc2l4dGVlbnRocy5sZW5ndGggPiAzKXtcblx0XHRcdC8vIHRoZSBhZGRpdGlvbmFsIHBhcnNlRmxvYXQgcmVtb3ZlcyBpbnNpZ25pZmljYW50IHRyYWlsaW5nIHplcm9lc1xuXHRcdFx0c2l4dGVlbnRocyA9IHBhcnNlRmxvYXQocGFyc2VGbG9hdChzaXh0ZWVudGhzKS50b0ZpeGVkKDMpKTtcblx0XHR9XG5cdFx0dmFyIHByb2dyZXNzID0gW21lYXN1cmVzLCBxdWFydGVycywgc2l4dGVlbnRoc107XG5cdFx0cmV0dXJuIHByb2dyZXNzLmpvaW4oXCI6XCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgUmV0dXJuIHRoZSB0aW1lIGluIHRpY2tzLlxuXHQgKiAgQHJldHVybiAge1RpY2tzfVxuXHQgKi9cblx0VG9uZS5UaW1lLnByb3RvdHlwZS50b1RpY2tzID0gZnVuY3Rpb24oKXtcblx0XHR2YXIgcXVhcnRlclRpbWUgPSB0aGlzLl9iZWF0c1RvVW5pdHMoMSk7XG5cdFx0dmFyIHF1YXJ0ZXJzID0gdGhpcy52YWx1ZU9mKCkgLyBxdWFydGVyVGltZTtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZChxdWFydGVycyAqIHRoaXMuX2dldFBQUSgpKTtcblx0fTtcblxuXHQvKipcblx0ICogIFJldHVybiB0aGUgdGltZSBpbiBzZWNvbmRzLlxuXHQgKiAgQHJldHVybiAge1NlY29uZHN9XG5cdCAqL1xuXHRUb25lLlRpbWUucHJvdG90eXBlLnRvU2Vjb25kcyA9IGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVPZigpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgUmV0dXJuIHRoZSB2YWx1ZSBhcyBhIG1pZGkgbm90ZS5cblx0ICogIEByZXR1cm4gIHtNaWRpfVxuXHQgKi9cblx0VG9uZS5UaW1lLnByb3RvdHlwZS50b01pZGkgPSBmdW5jdGlvbigpe1xuXHRcdHJldHVybiBUb25lLkZyZXF1ZW5jeS5mdG9tKHRoaXMudG9GcmVxdWVuY3koKSk7XG5cdH07XG5cblx0cmV0dXJuIFRvbmUuVGltZTtcbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUVBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUFBO0FBRkE7QUFXQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFGQTtBQVpBO0FBb0JBOzs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/type/Time.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/type/TimeBase.js":
/*!*************************************************!*\
  !*** ./node_modules/tone/Tone/type/TimeBase.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  /**\n   *  @class Tone.TimeBase is a flexible encoding of time\n   *         which can be evaluated to and from a string.\n   *  @extends {Tone}\n   *  @param  {Time}  val    The time value as a number or string\n   *  @param  {String=}  units  Unit values\n   *  @example\n   * Tone.TimeBase(4, \"n\")\n   * Tone.TimeBase(2, \"t\")\n   * Tone.TimeBase(\"2t\")\n   * Tone.TimeBase(\"2t\") + Tone.TimeBase(\"4n\");\n   */\n  Tone.TimeBase = function (val, units) {\n    //allows it to be constructed with or without 'new'\n    if (this instanceof Tone.TimeBase) {\n      /**\n       *  The value\n       *  @type  {Number|String|Tone.TimeBase}\n       *  @private\n       */\n      this._val = val;\n      /**\n       * The units\n       * @type {String?}\n       * @private\n       */\n\n      this._units = units; //test if the value is a string representation of a number\n\n      if (Tone.isUndef(this._units) && Tone.isString(this._val) && // eslint-disable-next-line eqeqeq\n      parseFloat(this._val) == this._val && this._val.charAt(0) !== \"+\") {\n        this._val = parseFloat(this._val);\n        this._units = this._defaultUnits;\n      } else if (val && val.constructor === this.constructor) {\n        //if they're the same type, just copy values over\n        this._val = val._val;\n        this._units = val._units;\n      } else if (val instanceof Tone.TimeBase) {\n        switch (this._defaultUnits) {\n          case \"s\":\n            this._val = val.toSeconds();\n            break;\n\n          case \"i\":\n            this._val = val.toTicks();\n            break;\n\n          case \"hz\":\n            this._val = val.toFrequency();\n            break;\n\n          case \"midi\":\n            this._val = val.toMidi();\n            break;\n\n          default:\n            throw new Error(\"Unrecognized default units \" + this._defaultUnits);\n        }\n      }\n    } else {\n      return new Tone.TimeBase(val, units);\n    }\n  };\n\n  Tone.extend(Tone.TimeBase); ///////////////////////////////////////////////////////////////////////////\n  //\tABSTRACT SYNTAX TREE PARSER\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  All the primary expressions.\n   *  @private\n   *  @type  {Object}\n   */\n\n  Tone.TimeBase.prototype._expressions = {\n    \"n\": {\n      regexp: /^(\\d+)n(\\.?)$/i,\n      method: function () {\n        function method(value, dot) {\n          value = parseInt(value);\n          var scalar = dot === \".\" ? 1.5 : 1;\n\n          if (value === 1) {\n            return this._beatsToUnits(this._getTimeSignature()) * scalar;\n          } else {\n            return this._beatsToUnits(4 / value) * scalar;\n          }\n        }\n\n        return method;\n      }()\n    },\n    \"t\": {\n      regexp: /^(\\d+)t$/i,\n      method: function () {\n        function method(value) {\n          value = parseInt(value);\n          return this._beatsToUnits(8 / (parseInt(value) * 3));\n        }\n\n        return method;\n      }()\n    },\n    \"m\": {\n      regexp: /^(\\d+)m$/i,\n      method: function () {\n        function method(value) {\n          return this._beatsToUnits(parseInt(value) * this._getTimeSignature());\n        }\n\n        return method;\n      }()\n    },\n    \"i\": {\n      regexp: /^(\\d+)i$/i,\n      method: function () {\n        function method(value) {\n          return this._ticksToUnits(parseInt(value));\n        }\n\n        return method;\n      }()\n    },\n    \"hz\": {\n      regexp: /^(\\d+(?:\\.\\d+)?)hz$/i,\n      method: function () {\n        function method(value) {\n          return this._frequencyToUnits(parseFloat(value));\n        }\n\n        return method;\n      }()\n    },\n    \"tr\": {\n      regexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?$/,\n      method: function () {\n        function method(m, q, s) {\n          var total = 0;\n\n          if (m && m !== \"0\") {\n            total += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n          }\n\n          if (q && q !== \"0\") {\n            total += this._beatsToUnits(parseFloat(q));\n          }\n\n          if (s && s !== \"0\") {\n            total += this._beatsToUnits(parseFloat(s) / 4);\n          }\n\n          return total;\n        }\n\n        return method;\n      }()\n    },\n    \"s\": {\n      regexp: /^(\\d+(?:\\.\\d+)?)s$/,\n      method: function () {\n        function method(value) {\n          return this._secondsToUnits(parseFloat(value));\n        }\n\n        return method;\n      }()\n    },\n    \"samples\": {\n      regexp: /^(\\d+)samples$/,\n      method: function () {\n        function method(value) {\n          return parseInt(value) / this.context.sampleRate;\n        }\n\n        return method;\n      }()\n    },\n    \"default\": {\n      regexp: /^(\\d+(?:\\.\\d+)?)$/,\n      method: function () {\n        function method(value) {\n          return this._expressions[this._defaultUnits].method.call(this, value);\n        }\n\n        return method;\n      }()\n    }\n  };\n  /**\n   *  The default units if none are given.\n   *  @type {String}\n   *  @private\n   */\n\n  Tone.TimeBase.prototype._defaultUnits = \"s\"; ///////////////////////////////////////////////////////////////////////////\n  //\tTRANSPORT FALLBACKS\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Return the bpm, or 120 if Transport is not available\n   * @type {Number}\n   * @private\n   */\n\n  Tone.TimeBase.prototype._getBpm = function () {\n    if (Tone.Transport) {\n      return Tone.Transport.bpm.value;\n    } else {\n      return 120;\n    }\n  };\n  /**\n   * Return the timeSignature or 4 if Transport is not available\n   * @type {Number}\n   * @private\n   */\n\n\n  Tone.TimeBase.prototype._getTimeSignature = function () {\n    if (Tone.Transport) {\n      return Tone.Transport.timeSignature;\n    } else {\n      return 4;\n    }\n  };\n  /**\n   * Return the PPQ or 192 if Transport is not available\n   * @type {Number}\n   * @private\n   */\n\n\n  Tone.TimeBase.prototype._getPPQ = function () {\n    if (Tone.Transport) {\n      return Tone.Transport.PPQ;\n    } else {\n      return 192;\n    }\n  };\n  /**\n   * Return the current time in whichever context is relevant\n   * @type {Number}\n   * @private\n   */\n\n\n  Tone.TimeBase.prototype._now = function () {\n    return this.now();\n  }; ///////////////////////////////////////////////////////////////////////////\n  //\tUNIT CONVERSIONS\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  Returns the value of a frequency in the current units\n   *  @param {Frequency} freq\n   *  @return  {Number}\n   *  @private\n   */\n\n\n  Tone.TimeBase.prototype._frequencyToUnits = function (freq) {\n    return 1 / freq;\n  };\n  /**\n   *  Return the value of the beats in the current units\n   *  @param {Number} beats\n   *  @return  {Number}\n   *  @private\n   */\n\n\n  Tone.TimeBase.prototype._beatsToUnits = function (beats) {\n    return 60 / this._getBpm() * beats;\n  };\n  /**\n   *  Returns the value of a second in the current units\n   *  @param {Seconds} seconds\n   *  @return  {Number}\n   *  @private\n   */\n\n\n  Tone.TimeBase.prototype._secondsToUnits = function (seconds) {\n    return seconds;\n  };\n  /**\n   *  Returns the value of a tick in the current time units\n   *  @param {Ticks} ticks\n   *  @return  {Number}\n   *  @private\n   */\n\n\n  Tone.TimeBase.prototype._ticksToUnits = function (ticks) {\n    return ticks * (this._beatsToUnits(1) / this._getPPQ());\n  };\n  /**\n   * With no arguments, return 'now'\n   *  @return  {Number}\n   *  @private\n   */\n\n\n  Tone.TimeBase.prototype._noArg = function () {\n    return this._now();\n  }; ///////////////////////////////////////////////////////////////////////////\n  //\tEXPRESSIONS\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  Evaluate the time value. Returns the time\n   *  in seconds.\n   *  @return  {Seconds}\n   */\n\n\n  Tone.TimeBase.prototype.valueOf = function () {\n    if (Tone.isUndef(this._val)) {\n      return this._noArg();\n    } else if (Tone.isString(this._val) && Tone.isUndef(this._units)) {\n      for (var units in this._expressions) {\n        if (this._expressions[units].regexp.test(this._val.trim())) {\n          this._units = units;\n          break;\n        }\n      }\n    }\n\n    if (Tone.isDefined(this._units)) {\n      var expr = this._expressions[this._units];\n\n      var matching = this._val.toString().trim().match(expr.regexp);\n\n      if (matching) {\n        return expr.method.apply(this, matching.slice(1));\n      } else {\n        return expr.method.call(this, parseFloat(this._val));\n      }\n    } else {\n      return this._val;\n    }\n  };\n  /**\n   *  Return the value in seconds\n   *  @return {Seconds}\n   */\n\n\n  Tone.TimeBase.prototype.toSeconds = function () {\n    return this.valueOf();\n  };\n  /**\n   *  Return the value in hertz\n   *  @return {Frequency}\n   */\n\n\n  Tone.TimeBase.prototype.toFrequency = function () {\n    return 1 / this.toSeconds();\n  };\n  /**\n   *  Return the time in samples\n   *  @return  {Samples}\n   */\n\n\n  Tone.TimeBase.prototype.toSamples = function () {\n    return this.toSeconds() * this.context.sampleRate;\n  };\n  /**\n   *  Return the time in milliseconds.\n   *  @return  {Milliseconds}\n   */\n\n\n  Tone.TimeBase.prototype.toMilliseconds = function () {\n    return this.toSeconds() * 1000;\n  };\n  /**\n   *  Clean up\n   *  @return {Tone.TimeBase} this\n   */\n\n\n  Tone.TimeBase.prototype.dispose = function () {\n    this._val = null;\n    this._units = null;\n  };\n\n  return Tone.TimeBase;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3R5cGUvVGltZUJhc2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3R5cGUvVGltZUJhc2UuanM/NDQ0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoW1wiVG9uZS9jb3JlL1RvbmVcIl0sIGZ1bmN0aW9uKFRvbmUpe1xuXG5cdC8qKlxuXHQgKiAgQGNsYXNzIFRvbmUuVGltZUJhc2UgaXMgYSBmbGV4aWJsZSBlbmNvZGluZyBvZiB0aW1lXG5cdCAqICAgICAgICAgd2hpY2ggY2FuIGJlIGV2YWx1YXRlZCB0byBhbmQgZnJvbSBhIHN0cmluZy5cblx0ICogIEBleHRlbmRzIHtUb25lfVxuXHQgKiAgQHBhcmFtICB7VGltZX0gIHZhbCAgICBUaGUgdGltZSB2YWx1ZSBhcyBhIG51bWJlciBvciBzdHJpbmdcblx0ICogIEBwYXJhbSAge1N0cmluZz19ICB1bml0cyAgVW5pdCB2YWx1ZXNcblx0ICogIEBleGFtcGxlXG5cdCAqIFRvbmUuVGltZUJhc2UoNCwgXCJuXCIpXG5cdCAqIFRvbmUuVGltZUJhc2UoMiwgXCJ0XCIpXG5cdCAqIFRvbmUuVGltZUJhc2UoXCIydFwiKVxuXHQgKiBUb25lLlRpbWVCYXNlKFwiMnRcIikgKyBUb25lLlRpbWVCYXNlKFwiNG5cIik7XG5cdCAqL1xuXHRUb25lLlRpbWVCYXNlID0gZnVuY3Rpb24odmFsLCB1bml0cyl7XG5cblx0XHQvL2FsbG93cyBpdCB0byBiZSBjb25zdHJ1Y3RlZCB3aXRoIG9yIHdpdGhvdXQgJ25ldydcblx0XHRpZiAodGhpcyBpbnN0YW5jZW9mIFRvbmUuVGltZUJhc2Upe1xuXG5cdFx0XHQvKipcblx0XHRcdCAqICBUaGUgdmFsdWVcblx0XHRcdCAqICBAdHlwZSAge051bWJlcnxTdHJpbmd8VG9uZS5UaW1lQmFzZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLl92YWwgPSB2YWw7XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIHVuaXRzXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nP31cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMuX3VuaXRzID0gdW5pdHM7XG5cblx0XHRcdC8vdGVzdCBpZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBudW1iZXJcblx0XHRcdGlmIChUb25lLmlzVW5kZWYodGhpcy5fdW5pdHMpICYmIFRvbmUuaXNTdHJpbmcodGhpcy5fdmFsKSAmJlxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRcdHBhcnNlRmxvYXQodGhpcy5fdmFsKSA9PSB0aGlzLl92YWwgJiYgdGhpcy5fdmFsLmNoYXJBdCgwKSAhPT0gXCIrXCIpe1xuXHRcdFx0XHR0aGlzLl92YWwgPSBwYXJzZUZsb2F0KHRoaXMuX3ZhbCk7XG5cdFx0XHRcdHRoaXMuX3VuaXRzID0gdGhpcy5fZGVmYXVsdFVuaXRzO1xuXHRcdFx0fSBlbHNlIGlmICh2YWwgJiYgdmFsLmNvbnN0cnVjdG9yID09PSB0aGlzLmNvbnN0cnVjdG9yKXtcblx0XHRcdFx0Ly9pZiB0aGV5J3JlIHRoZSBzYW1lIHR5cGUsIGp1c3QgY29weSB2YWx1ZXMgb3ZlclxuXHRcdFx0XHR0aGlzLl92YWwgPSB2YWwuX3ZhbDtcblx0XHRcdFx0dGhpcy5fdW5pdHMgPSB2YWwuX3VuaXRzO1xuXHRcdFx0fSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBUb25lLlRpbWVCYXNlKXtcblx0XHRcdFx0c3dpdGNoICh0aGlzLl9kZWZhdWx0VW5pdHMpe1xuXHRcdFx0XHRcdGNhc2UgXCJzXCIgOlxuXHRcdFx0XHRcdFx0dGhpcy5fdmFsID0gdmFsLnRvU2Vjb25kcygpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcImlcIiA6XG5cdFx0XHRcdFx0XHR0aGlzLl92YWwgPSB2YWwudG9UaWNrcygpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcImh6XCIgOlxuXHRcdFx0XHRcdFx0dGhpcy5fdmFsID0gdmFsLnRvRnJlcXVlbmN5KCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwibWlkaVwiIDpcblx0XHRcdFx0XHRcdHRoaXMuX3ZhbCA9IHZhbC50b01pZGkoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQgOlxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIGRlZmF1bHQgdW5pdHMgXCIrdGhpcy5fZGVmYXVsdFVuaXRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBUb25lLlRpbWVCYXNlKHZhbCwgdW5pdHMpO1xuXHRcdH1cblx0fTtcblxuXHRUb25lLmV4dGVuZChUb25lLlRpbWVCYXNlKTtcblxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly9cdEFCU1RSQUNUIFNZTlRBWCBUUkVFIFBBUlNFUlxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHQvKipcblx0ICogIEFsbCB0aGUgcHJpbWFyeSBleHByZXNzaW9ucy5cblx0ICogIEBwcml2YXRlXG5cdCAqICBAdHlwZSAge09iamVjdH1cblx0ICovXG5cdFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9leHByZXNzaW9ucyA9IHtcblx0XHRcIm5cIiA6IHtcblx0XHRcdHJlZ2V4cCA6IC9eKFxcZCspbihcXC4/KSQvaSxcblx0XHRcdG1ldGhvZCA6IGZ1bmN0aW9uKHZhbHVlLCBkb3Qpe1xuXHRcdFx0XHR2YWx1ZSA9IHBhcnNlSW50KHZhbHVlKTtcblx0XHRcdFx0dmFyIHNjYWxhciA9IGRvdCA9PT0gXCIuXCIgPyAxLjUgOiAxO1xuXHRcdFx0XHRpZiAodmFsdWUgPT09IDEpe1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9iZWF0c1RvVW5pdHModGhpcy5fZ2V0VGltZVNpZ25hdHVyZSgpKSpzY2FsYXI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2JlYXRzVG9Vbml0cyg0IC8gdmFsdWUpKnNjYWxhcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJ0XCIgOiB7XG5cdFx0XHRyZWdleHAgOiAvXihcXGQrKXQkL2ksXG5cdFx0XHRtZXRob2QgOiBmdW5jdGlvbih2YWx1ZSl7XG5cdFx0XHRcdHZhbHVlID0gcGFyc2VJbnQodmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fYmVhdHNUb1VuaXRzKDggLyAocGFyc2VJbnQodmFsdWUpICogMykpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJtXCIgOiB7XG5cdFx0XHRyZWdleHAgOiAvXihcXGQrKW0kL2ksXG5cdFx0XHRtZXRob2QgOiBmdW5jdGlvbih2YWx1ZSl7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9iZWF0c1RvVW5pdHMocGFyc2VJbnQodmFsdWUpICogdGhpcy5fZ2V0VGltZVNpZ25hdHVyZSgpKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiaVwiIDoge1xuXHRcdFx0cmVnZXhwIDogL14oXFxkKylpJC9pLFxuXHRcdFx0bWV0aG9kIDogZnVuY3Rpb24odmFsdWUpe1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdGlja3NUb1VuaXRzKHBhcnNlSW50KHZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImh6XCIgOiB7XG5cdFx0XHRyZWdleHAgOiAvXihcXGQrKD86XFwuXFxkKyk/KWh6JC9pLFxuXHRcdFx0bWV0aG9kIDogZnVuY3Rpb24odmFsdWUpe1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZnJlcXVlbmN5VG9Vbml0cyhwYXJzZUZsb2F0KHZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInRyXCIgOiB7XG5cdFx0XHRyZWdleHAgOiAvXihcXGQrKD86XFwuXFxkKyk/KTooXFxkKyg/OlxcLlxcZCspPyk6PyhcXGQrKD86XFwuXFxkKyk/KT8kLyxcblx0XHRcdG1ldGhvZCA6IGZ1bmN0aW9uKG0sIHEsIHMpe1xuXHRcdFx0XHR2YXIgdG90YWwgPSAwO1xuXHRcdFx0XHRpZiAobSAmJiBtICE9PSBcIjBcIil7XG5cdFx0XHRcdFx0dG90YWwgKz0gdGhpcy5fYmVhdHNUb1VuaXRzKHRoaXMuX2dldFRpbWVTaWduYXR1cmUoKSAqIHBhcnNlRmxvYXQobSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChxICYmIHEgIT09IFwiMFwiKXtcblx0XHRcdFx0XHR0b3RhbCArPSB0aGlzLl9iZWF0c1RvVW5pdHMocGFyc2VGbG9hdChxKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHMgJiYgcyAhPT0gXCIwXCIpe1xuXHRcdFx0XHRcdHRvdGFsICs9IHRoaXMuX2JlYXRzVG9Vbml0cyhwYXJzZUZsb2F0KHMpIC8gNCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRvdGFsO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJzXCIgOiB7XG5cdFx0XHRyZWdleHAgOiAvXihcXGQrKD86XFwuXFxkKyk/KXMkLyxcblx0XHRcdG1ldGhvZCA6IGZ1bmN0aW9uKHZhbHVlKXtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3NlY29uZHNUb1VuaXRzKHBhcnNlRmxvYXQodmFsdWUpKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwic2FtcGxlc1wiIDoge1xuXHRcdFx0cmVnZXhwIDogL14oXFxkKylzYW1wbGVzJC8sXG5cdFx0XHRtZXRob2QgOiBmdW5jdGlvbih2YWx1ZSl7XG5cdFx0XHRcdHJldHVybiBwYXJzZUludCh2YWx1ZSkgLyB0aGlzLmNvbnRleHQuc2FtcGxlUmF0ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiZGVmYXVsdFwiIDoge1xuXHRcdFx0cmVnZXhwIDogL14oXFxkKyg/OlxcLlxcZCspPykkLyxcblx0XHRcdG1ldGhvZCA6IGZ1bmN0aW9uKHZhbHVlKXtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2V4cHJlc3Npb25zW3RoaXMuX2RlZmF1bHRVbml0c10ubWV0aG9kLmNhbGwodGhpcywgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogIFRoZSBkZWZhdWx0IHVuaXRzIGlmIG5vbmUgYXJlIGdpdmVuLlxuXHQgKiAgQHR5cGUge1N0cmluZ31cblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fZGVmYXVsdFVuaXRzID0gXCJzXCI7XG5cblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vXHRUUkFOU1BPUlQgRkFMTEJBQ0tTXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIGJwbSwgb3IgMTIwIGlmIFRyYW5zcG9ydCBpcyBub3QgYXZhaWxhYmxlXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fZ2V0QnBtID0gZnVuY3Rpb24oKXtcblx0XHRpZiAoVG9uZS5UcmFuc3BvcnQpe1xuXHRcdFx0cmV0dXJuIFRvbmUuVHJhbnNwb3J0LmJwbS52YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIDEyMDtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgdGltZVNpZ25hdHVyZSBvciA0IGlmIFRyYW5zcG9ydCBpcyBub3QgYXZhaWxhYmxlXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fZ2V0VGltZVNpZ25hdHVyZSA9IGZ1bmN0aW9uKCl7XG5cdFx0aWYgKFRvbmUuVHJhbnNwb3J0KXtcblx0XHRcdHJldHVybiBUb25lLlRyYW5zcG9ydC50aW1lU2lnbmF0dXJlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gNDtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgUFBRIG9yIDE5MiBpZiBUcmFuc3BvcnQgaXMgbm90IGF2YWlsYWJsZVxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0VG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX2dldFBQUSA9IGZ1bmN0aW9uKCl7XG5cdFx0aWYgKFRvbmUuVHJhbnNwb3J0KXtcblx0XHRcdHJldHVybiBUb25lLlRyYW5zcG9ydC5QUFE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAxOTI7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIGN1cnJlbnQgdGltZSBpbiB3aGljaGV2ZXIgY29udGV4dCBpcyByZWxldmFudFxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0VG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX25vdyA9IGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIHRoaXMubm93KCk7XG5cdH07XG5cblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vXHRVTklUIENPTlZFUlNJT05TXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cdC8qKlxuXHQgKiAgUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBmcmVxdWVuY3kgaW4gdGhlIGN1cnJlbnQgdW5pdHNcblx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBmcmVxXG5cdCAqICBAcmV0dXJuICB7TnVtYmVyfVxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9mcmVxdWVuY3lUb1VuaXRzID0gZnVuY3Rpb24oZnJlcSl7XG5cdFx0cmV0dXJuIDEvZnJlcTtcblx0fTtcblxuXHQvKipcblx0ICogIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGJlYXRzIGluIHRoZSBjdXJyZW50IHVuaXRzXG5cdCAqICBAcGFyYW0ge051bWJlcn0gYmVhdHNcblx0ICogIEByZXR1cm4gIHtOdW1iZXJ9XG5cdCAqICBAcHJpdmF0ZVxuXHQgKi9cblx0VG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX2JlYXRzVG9Vbml0cyA9IGZ1bmN0aW9uKGJlYXRzKXtcblx0XHRyZXR1cm4gKDYwIC8gdGhpcy5fZ2V0QnBtKCkpICogYmVhdHM7XG5cdH07XG5cblx0LyoqXG5cdCAqICBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIHNlY29uZCBpbiB0aGUgY3VycmVudCB1bml0c1xuXHQgKiAgQHBhcmFtIHtTZWNvbmRzfSBzZWNvbmRzXG5cdCAqICBAcmV0dXJuICB7TnVtYmVyfVxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9zZWNvbmRzVG9Vbml0cyA9IGZ1bmN0aW9uKHNlY29uZHMpe1xuXHRcdHJldHVybiBzZWNvbmRzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgUmV0dXJucyB0aGUgdmFsdWUgb2YgYSB0aWNrIGluIHRoZSBjdXJyZW50IHRpbWUgdW5pdHNcblx0ICogIEBwYXJhbSB7VGlja3N9IHRpY2tzXG5cdCAqICBAcmV0dXJuICB7TnVtYmVyfVxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl90aWNrc1RvVW5pdHMgPSBmdW5jdGlvbih0aWNrcyl7XG5cdFx0cmV0dXJuIHRpY2tzICogKHRoaXMuX2JlYXRzVG9Vbml0cygxKSAvIHRoaXMuX2dldFBQUSgpKTtcblx0fTtcblxuXHQvKipcblx0ICogV2l0aCBubyBhcmd1bWVudHMsIHJldHVybiAnbm93J1xuXHQgKiAgQHJldHVybiAge051bWJlcn1cblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fbm9BcmcgPSBmdW5jdGlvbigpe1xuXHRcdHJldHVybiB0aGlzLl9ub3coKTtcblx0fTtcblxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly9cdEVYUFJFU1NJT05TXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cdC8qKlxuXHQgKiAgRXZhbHVhdGUgdGhlIHRpbWUgdmFsdWUuIFJldHVybnMgdGhlIHRpbWVcblx0ICogIGluIHNlY29uZHMuXG5cdCAqICBAcmV0dXJuICB7U2Vjb25kc31cblx0ICovXG5cdFRvbmUuVGltZUJhc2UucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbigpe1xuXHRcdGlmIChUb25lLmlzVW5kZWYodGhpcy5fdmFsKSl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbm9BcmcoKTtcblx0XHR9IGVsc2UgaWYgKFRvbmUuaXNTdHJpbmcodGhpcy5fdmFsKSAmJiBUb25lLmlzVW5kZWYodGhpcy5fdW5pdHMpKXtcblx0XHRcdGZvciAodmFyIHVuaXRzIGluIHRoaXMuX2V4cHJlc3Npb25zKXtcblx0XHRcdFx0aWYgKHRoaXMuX2V4cHJlc3Npb25zW3VuaXRzXS5yZWdleHAudGVzdCh0aGlzLl92YWwudHJpbSgpKSl7XG5cdFx0XHRcdFx0dGhpcy5fdW5pdHMgPSB1bml0cztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoVG9uZS5pc0RlZmluZWQodGhpcy5fdW5pdHMpKXtcblx0XHRcdHZhciBleHByID0gdGhpcy5fZXhwcmVzc2lvbnNbdGhpcy5fdW5pdHNdO1xuXHRcdFx0dmFyIG1hdGNoaW5nID0gdGhpcy5fdmFsLnRvU3RyaW5nKCkudHJpbSgpLm1hdGNoKGV4cHIucmVnZXhwKTtcblx0XHRcdGlmIChtYXRjaGluZyl7XG5cdFx0XHRcdHJldHVybiBleHByLm1ldGhvZC5hcHBseSh0aGlzLCBtYXRjaGluZy5zbGljZSgxKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gZXhwci5tZXRob2QuY2FsbCh0aGlzLCBwYXJzZUZsb2F0KHRoaXMuX3ZhbCkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdmFsO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogIFJldHVybiB0aGUgdmFsdWUgaW4gc2Vjb25kc1xuXHQgKiAgQHJldHVybiB7U2Vjb25kc31cblx0ICovXG5cdFRvbmUuVGltZUJhc2UucHJvdG90eXBlLnRvU2Vjb25kcyA9IGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVPZigpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAgUmV0dXJuIHRoZSB2YWx1ZSBpbiBoZXJ0elxuXHQgKiAgQHJldHVybiB7RnJlcXVlbmN5fVxuXHQgKi9cblx0VG9uZS5UaW1lQmFzZS5wcm90b3R5cGUudG9GcmVxdWVuY3kgPSBmdW5jdGlvbigpe1xuXHRcdHJldHVybiAxIC8gdGhpcy50b1NlY29uZHMoKTtcblx0fTtcblxuXHQvKipcblx0ICogIFJldHVybiB0aGUgdGltZSBpbiBzYW1wbGVzXG5cdCAqICBAcmV0dXJuICB7U2FtcGxlc31cblx0ICovXG5cdFRvbmUuVGltZUJhc2UucHJvdG90eXBlLnRvU2FtcGxlcyA9IGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIHRoaXMudG9TZWNvbmRzKCkgKiB0aGlzLmNvbnRleHQuc2FtcGxlUmF0ZTtcblx0fTtcblxuXHQvKipcblx0ICogIFJldHVybiB0aGUgdGltZSBpbiBtaWxsaXNlY29uZHMuXG5cdCAqICBAcmV0dXJuICB7TWlsbGlzZWNvbmRzfVxuXHQgKi9cblx0VG9uZS5UaW1lQmFzZS5wcm90b3R5cGUudG9NaWxsaXNlY29uZHMgPSBmdW5jdGlvbigpe1xuXHRcdHJldHVybiB0aGlzLnRvU2Vjb25kcygpICogMTAwMDtcblx0fTtcblxuXHQvKipcblx0ICogIENsZWFuIHVwXG5cdCAqICBAcmV0dXJuIHtUb25lLlRpbWVCYXNlfSB0aGlzXG5cdCAqL1xuXHRUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKXtcblx0XHR0aGlzLl92YWwgPSBudWxsO1xuXHRcdHRoaXMuX3VuaXRzID0gbnVsbDtcblx0fTtcblxuXHRyZXR1cm4gVG9uZS5UaW1lQmFzZTtcbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUVBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUVBOzs7Ozs7QUFLQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFkQTtBQWdCQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQUFBO0FBRkE7QUFZQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFBQTtBQUZBO0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBRkE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFGQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUZBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBYkE7QUFBQTtBQUZBO0FBZ0JBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUZBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBRkE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFGQTtBQWxFQTtBQTBFQTs7Ozs7O0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/type/TimeBase.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/type/TransportTime.js":
/*!******************************************************!*\
  !*** ./node_modules/tone/Tone/type/TransportTime.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/type/Time */ \"./node_modules/tone/Tone/type/Time.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  /**\n   *  @class Tone.TransportTime is a the time along the Transport's\n   *         timeline. It is similar to Tone.Time, but instead of evaluating\n   *         against the AudioContext's clock, it is evaluated against\n   *         the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n   *  @constructor\n   *  @param  {Time}  val    The time value as a number or string\n   *  @param  {String=}  units  Unit values\n   *  @extends {Tone.Time}\n   */\n  Tone.TransportTime = function (val, units) {\n    if (this instanceof Tone.TransportTime) {\n      Tone.Time.call(this, val, units);\n    } else {\n      return new Tone.TransportTime(val, units);\n    }\n  };\n\n  Tone.extend(Tone.TransportTime, Tone.Time);\n  /**\n   * Return the current time in whichever context is relevant\n   * @type {Number}\n   * @private\n   */\n\n  Tone.TransportTime.prototype._now = function () {\n    return Tone.Transport.seconds;\n  };\n\n  return Tone.TransportTime;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3R5cGUvVHJhbnNwb3J0VGltZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90b25lL1RvbmUvdHlwZS9UcmFuc3BvcnRUaW1lLmpzP2QyYWEiXSwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFtcIlRvbmUvY29yZS9Ub25lXCIsIFwiVG9uZS90eXBlL1RpbWVcIl0sIGZ1bmN0aW9uKFRvbmUpe1xuXG5cdC8qKlxuXHQgKiAgQGNsYXNzIFRvbmUuVHJhbnNwb3J0VGltZSBpcyBhIHRoZSB0aW1lIGFsb25nIHRoZSBUcmFuc3BvcnQnc1xuXHQgKiAgICAgICAgIHRpbWVsaW5lLiBJdCBpcyBzaW1pbGFyIHRvIFRvbmUuVGltZSwgYnV0IGluc3RlYWQgb2YgZXZhbHVhdGluZ1xuXHQgKiAgICAgICAgIGFnYWluc3QgdGhlIEF1ZGlvQ29udGV4dCdzIGNsb2NrLCBpdCBpcyBldmFsdWF0ZWQgYWdhaW5zdFxuXHQgKiAgICAgICAgIHRoZSBUcmFuc3BvcnQncyBwb3NpdGlvbi4gU2VlIFtUcmFuc3BvcnRUaW1lIHdpa2ldKGh0dHBzOi8vZ2l0aHViLmNvbS9Ub25lanMvVG9uZS5qcy93aWtpL1RyYW5zcG9ydFRpbWUpLlxuXHQgKiAgQGNvbnN0cnVjdG9yXG5cdCAqICBAcGFyYW0gIHtUaW1lfSAgdmFsICAgIFRoZSB0aW1lIHZhbHVlIGFzIGEgbnVtYmVyIG9yIHN0cmluZ1xuXHQgKiAgQHBhcmFtICB7U3RyaW5nPX0gIHVuaXRzICBVbml0IHZhbHVlc1xuXHQgKiAgQGV4dGVuZHMge1RvbmUuVGltZX1cblx0ICovXG5cdFRvbmUuVHJhbnNwb3J0VGltZSA9IGZ1bmN0aW9uKHZhbCwgdW5pdHMpe1xuXHRcdGlmICh0aGlzIGluc3RhbmNlb2YgVG9uZS5UcmFuc3BvcnRUaW1lKXtcblxuXHRcdFx0VG9uZS5UaW1lLmNhbGwodGhpcywgdmFsLCB1bml0cyk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG5ldyBUb25lLlRyYW5zcG9ydFRpbWUodmFsLCB1bml0cyk7XG5cdFx0fVxuXHR9O1xuXG5cdFRvbmUuZXh0ZW5kKFRvbmUuVHJhbnNwb3J0VGltZSwgVG9uZS5UaW1lKTtcblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBjdXJyZW50IHRpbWUgaW4gd2hpY2hldmVyIGNvbnRleHQgaXMgcmVsZXZhbnRcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdFRvbmUuVHJhbnNwb3J0VGltZS5wcm90b3R5cGUuX25vdyA9IGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIFRvbmUuVHJhbnNwb3J0LnNlY29uZHM7XG5cdH07XG5cblx0cmV0dXJuIFRvbmUuVHJhbnNwb3J0VGltZTtcbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUVBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/type/TransportTime.js\n");

/***/ }),

/***/ "./node_modules/tone/Tone/type/Type.js":
/*!*********************************************!*\
  !*** ./node_modules/tone/Tone/type/Type.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\"), __webpack_require__(/*! Tone/type/Time */ \"./node_modules/tone/Tone/type/Time.js\"), __webpack_require__(/*! Tone/type/Frequency */ \"./node_modules/tone/Tone/type/Frequency.js\"), __webpack_require__(/*! Tone/type/TransportTime */ \"./node_modules/tone/Tone/type/TransportTime.js\"), __webpack_require__(/*! Tone/core/Context */ \"./node_modules/tone/Tone/core/Context.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Tone) {\n  ///////////////////////////////////////////////////////////////////////////\n  //\tTYPES\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Units which a value can take on.\n   * @enum {String}\n   */\n  Tone.Type = {\n    /**\n     *  Default units\n     *  @typedef {Default}\n     */\n    Default: \"number\",\n\n    /**\n     *  Time can be described in a number of ways. Read more [Time](https://github.com/Tonejs/Tone.js/wiki/Time).\n     *\n     *  * Numbers, which will be taken literally as the time (in seconds).\n     *  * Notation, (\"4n\", \"8t\") describes time in BPM and time signature relative values.\n     *  * TransportTime, (\"4:3:2\") will also provide tempo and time signature relative times\n     *  in the form BARS:QUARTERS:SIXTEENTHS.\n     *  * Frequency, (\"8hz\") is converted to the length of the cycle in seconds.\n     *  * Now-Relative, (\"+1\") prefix any of the above with \"+\" and it will be interpreted as\n     *  \"the current time plus whatever expression follows\".\n     *  * Expressions, (\"3:0 + 2 - (1m / 7)\") any of the above can also be combined\n     *  into a mathematical expression which will be evaluated to compute the desired time.\n     *  * No Argument, for methods which accept time, no argument will be interpreted as\n     *  \"now\" (i.e. the currentTime).\n     *\n     *  @typedef {Time}\n     */\n    Time: \"time\",\n\n    /**\n     *  Frequency can be described similar to time, except ultimately the\n     *  values are converted to frequency instead of seconds. A number\n     *  is taken literally as the value in hertz. Additionally any of the\n     *  Time encodings can be used. Note names in the form\n     *  of NOTE OCTAVE (i.e. C4) are also accepted and converted to their\n     *  frequency value.\n     *  @typedef {Frequency}\n     */\n    Frequency: \"frequency\",\n\n    /**\n     *  TransportTime describes a position along the Transport's timeline. It is\n     *  similar to Time in that it uses all the same encodings, but TransportTime specifically\n     *  pertains to the Transport's timeline, which is startable, stoppable, loopable, and seekable.\n     *  [Read more](https://github.com/Tonejs/Tone.js/wiki/TransportTime)\n     *  @typedef {TransportTime}\n     */\n    TransportTime: \"transportTime\",\n\n    /**\n     *  Ticks are the basic subunit of the Transport. They are\n     *  the smallest unit of time that the Transport supports.\n     *  @typedef {Ticks}\n     */\n    Ticks: \"ticks\",\n\n    /**\n     *  Normal values are within the range [0, 1].\n     *  @typedef {NormalRange}\n     */\n    NormalRange: \"normalRange\",\n\n    /**\n     *  AudioRange values are between [-1, 1].\n     *  @typedef {AudioRange}\n     */\n    AudioRange: \"audioRange\",\n\n    /**\n     *  Decibels are a logarithmic unit of measurement which is useful for volume\n     *  because of the logarithmic way that we perceive loudness. 0 decibels\n     *  means no change in volume. -10db is approximately half as loud and 10db\n     *  is twice is loud.\n     *  @typedef {Decibels}\n     */\n    Decibels: \"db\",\n\n    /**\n     *  Half-step note increments, i.e. 12 is an octave above the root. and 1 is a half-step up.\n     *  @typedef {Interval}\n     */\n    Interval: \"interval\",\n\n    /**\n     *  Beats per minute.\n     *  @typedef {BPM}\n     */\n    BPM: \"bpm\",\n\n    /**\n     *  The value must be greater than or equal to 0.\n     *  @typedef {Positive}\n     */\n    Positive: \"positive\",\n\n    /**\n     *  Gain is the ratio between input and output of a signal.\n     *  A gain of 0 is the same as silencing the signal. A gain of\n     *  1, causes no change to the incoming signal.\n     *  @typedef {Gain}\n     */\n    Gain: \"gain\",\n\n    /**\n     *  A cent is a hundredth of a semitone.\n     *  @typedef {Cents}\n     */\n    Cents: \"cents\",\n\n    /**\n     *  Angle between 0 and 360.\n     *  @typedef {Degrees}\n     */\n    Degrees: \"degrees\",\n\n    /**\n     *  A number representing a midi note.\n     *  @typedef {MIDI}\n     */\n    MIDI: \"midi\",\n\n    /**\n     *  A colon-separated representation of time in the form of\n     *  Bars:Beats:Sixteenths.\n     *  @typedef {BarsBeatsSixteenths}\n     */\n    BarsBeatsSixteenths: \"barsBeatsSixteenths\",\n\n    /**\n     *  Sampling is the reduction of a continuous signal to a discrete signal.\n     *  Audio is typically sampled 44100 times per second.\n     *  @typedef {Samples}\n     */\n    Samples: \"samples\",\n\n    /**\n     *  Hertz are a frequency representation defined as one cycle per second.\n     *  @typedef {Hertz}\n     */\n    Hertz: \"hertz\",\n\n    /**\n     *  A frequency represented by a letter name,\n     *  accidental and octave. This system is known as\n     *  [Scientific Pitch Notation](https://en.wikipedia.org/wiki/Scientific_pitch_notation).\n     *  @typedef {Note}\n     */\n    Note: \"note\",\n\n    /**\n     *  One millisecond is a thousandth of a second.\n     *  @typedef {Milliseconds}\n     */\n    Milliseconds: \"milliseconds\",\n\n    /**\n     *  Seconds are the time unit of the AudioContext. In the end,\n     *  all values need to be evaluated to seconds.\n     *  @typedef {Seconds}\n     */\n    Seconds: \"seconds\",\n\n    /**\n     *  A string representing a duration relative to a measure.\n     *  * \"4n\" = quarter note\n     *  * \"2m\" = two measures\n     *  * \"8t\" = eighth-note triplet\n     *  @typedef {Notation}\n     */\n    Notation: \"notation\"\n  }; ///////////////////////////////////////////////////////////////////////////\n  // AUGMENT TONE's PROTOTYPE\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  Convert Time into seconds.\n   *\n   *  Unlike the method which it overrides, this takes into account\n   *  transporttime and musical notation.\n   *\n   *  Time : 1.40\n   *  Notation: 4n or 1m or 2t\n   *  Now Relative: +3n\n   *  Math: 3n+16n or even complicated expressions ((3n*2)/6 + 1)\n   *\n   *  @param  {Time} time\n   *  @return {Seconds}\n   */\n\n  Tone.prototype.toSeconds = function (time) {\n    if (Tone.isNumber(time)) {\n      return time;\n    } else if (Tone.isUndef(time)) {\n      return this.now();\n    } else if (Tone.isString(time)) {\n      return new Tone.Time(time).toSeconds();\n    } else if (time instanceof Tone.TimeBase) {\n      return time.toSeconds();\n    }\n  };\n  /**\n   *  Convert a frequency representation into a number.\n   *  @param  {Frequency} freq\n   *  @return {Hertz}      the frequency in hertz\n   */\n\n\n  Tone.prototype.toFrequency = function (freq) {\n    if (Tone.isNumber(freq)) {\n      return freq;\n    } else if (Tone.isString(freq) || Tone.isUndef(freq)) {\n      return new Tone.Frequency(freq).valueOf();\n    } else if (freq instanceof Tone.TimeBase) {\n      return freq.toFrequency();\n    }\n  };\n  /**\n   *  Convert a time representation into ticks.\n   *  @param  {Time} time\n   *  @return {Ticks}  the time in ticks\n   */\n\n\n  Tone.prototype.toTicks = function (time) {\n    if (Tone.isNumber(time) || Tone.isString(time)) {\n      return new Tone.TransportTime(time).toTicks();\n    } else if (Tone.isUndef(time)) {\n      return Tone.Transport.ticks;\n    } else if (time instanceof Tone.TimeBase) {\n      return time.toTicks();\n    }\n  };\n\n  return Tone;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9uZS9Ub25lL3R5cGUvVHlwZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90b25lL1RvbmUvdHlwZS9UeXBlLmpzPzk5NTMiXSwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFtcIlRvbmUvY29yZS9Ub25lXCIsIFwiVG9uZS90eXBlL1RpbWVcIiwgXCJUb25lL3R5cGUvRnJlcXVlbmN5XCIsIFwiVG9uZS90eXBlL1RyYW5zcG9ydFRpbWVcIiwgXCJUb25lL2NvcmUvQ29udGV4dFwiXSwgZnVuY3Rpb24oVG9uZSl7XG5cblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vXHRUWVBFU1xuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHQvKipcblx0ICogVW5pdHMgd2hpY2ggYSB2YWx1ZSBjYW4gdGFrZSBvbi5cblx0ICogQGVudW0ge1N0cmluZ31cblx0ICovXG5cdFRvbmUuVHlwZSA9IHtcblx0XHQvKipcblx0XHQgKiAgRGVmYXVsdCB1bml0c1xuXHRcdCAqICBAdHlwZWRlZiB7RGVmYXVsdH1cblx0XHQgKi9cblx0XHREZWZhdWx0IDogXCJudW1iZXJcIixcblx0XHQvKipcblx0XHQgKiAgVGltZSBjYW4gYmUgZGVzY3JpYmVkIGluIGEgbnVtYmVyIG9mIHdheXMuIFJlYWQgbW9yZSBbVGltZV0oaHR0cHM6Ly9naXRodWIuY29tL1RvbmVqcy9Ub25lLmpzL3dpa2kvVGltZSkuXG5cdFx0ICpcblx0XHQgKiAgKiBOdW1iZXJzLCB3aGljaCB3aWxsIGJlIHRha2VuIGxpdGVyYWxseSBhcyB0aGUgdGltZSAoaW4gc2Vjb25kcykuXG5cdFx0ICogICogTm90YXRpb24sIChcIjRuXCIsIFwiOHRcIikgZGVzY3JpYmVzIHRpbWUgaW4gQlBNIGFuZCB0aW1lIHNpZ25hdHVyZSByZWxhdGl2ZSB2YWx1ZXMuXG5cdFx0ICogICogVHJhbnNwb3J0VGltZSwgKFwiNDozOjJcIikgd2lsbCBhbHNvIHByb3ZpZGUgdGVtcG8gYW5kIHRpbWUgc2lnbmF0dXJlIHJlbGF0aXZlIHRpbWVzXG5cdFx0ICogIGluIHRoZSBmb3JtIEJBUlM6UVVBUlRFUlM6U0lYVEVFTlRIUy5cblx0XHQgKiAgKiBGcmVxdWVuY3ksIChcIjhoelwiKSBpcyBjb252ZXJ0ZWQgdG8gdGhlIGxlbmd0aCBvZiB0aGUgY3ljbGUgaW4gc2Vjb25kcy5cblx0XHQgKiAgKiBOb3ctUmVsYXRpdmUsIChcIisxXCIpIHByZWZpeCBhbnkgb2YgdGhlIGFib3ZlIHdpdGggXCIrXCIgYW5kIGl0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXNcblx0XHQgKiAgXCJ0aGUgY3VycmVudCB0aW1lIHBsdXMgd2hhdGV2ZXIgZXhwcmVzc2lvbiBmb2xsb3dzXCIuXG5cdFx0ICogICogRXhwcmVzc2lvbnMsIChcIjM6MCArIDIgLSAoMW0gLyA3KVwiKSBhbnkgb2YgdGhlIGFib3ZlIGNhbiBhbHNvIGJlIGNvbWJpbmVkXG5cdFx0ICogIGludG8gYSBtYXRoZW1hdGljYWwgZXhwcmVzc2lvbiB3aGljaCB3aWxsIGJlIGV2YWx1YXRlZCB0byBjb21wdXRlIHRoZSBkZXNpcmVkIHRpbWUuXG5cdFx0ICogICogTm8gQXJndW1lbnQsIGZvciBtZXRob2RzIHdoaWNoIGFjY2VwdCB0aW1lLCBubyBhcmd1bWVudCB3aWxsIGJlIGludGVycHJldGVkIGFzXG5cdFx0ICogIFwibm93XCIgKGkuZS4gdGhlIGN1cnJlbnRUaW1lKS5cblx0XHQgKlxuXHRcdCAqICBAdHlwZWRlZiB7VGltZX1cblx0XHQgKi9cblx0XHRUaW1lIDogXCJ0aW1lXCIsXG5cdFx0LyoqXG5cdFx0ICogIEZyZXF1ZW5jeSBjYW4gYmUgZGVzY3JpYmVkIHNpbWlsYXIgdG8gdGltZSwgZXhjZXB0IHVsdGltYXRlbHkgdGhlXG5cdFx0ICogIHZhbHVlcyBhcmUgY29udmVydGVkIHRvIGZyZXF1ZW5jeSBpbnN0ZWFkIG9mIHNlY29uZHMuIEEgbnVtYmVyXG5cdFx0ICogIGlzIHRha2VuIGxpdGVyYWxseSBhcyB0aGUgdmFsdWUgaW4gaGVydHouIEFkZGl0aW9uYWxseSBhbnkgb2YgdGhlXG5cdFx0ICogIFRpbWUgZW5jb2RpbmdzIGNhbiBiZSB1c2VkLiBOb3RlIG5hbWVzIGluIHRoZSBmb3JtXG5cdFx0ICogIG9mIE5PVEUgT0NUQVZFIChpLmUuIEM0KSBhcmUgYWxzbyBhY2NlcHRlZCBhbmQgY29udmVydGVkIHRvIHRoZWlyXG5cdFx0ICogIGZyZXF1ZW5jeSB2YWx1ZS5cblx0XHQgKiAgQHR5cGVkZWYge0ZyZXF1ZW5jeX1cblx0XHQgKi9cblx0XHRGcmVxdWVuY3kgOiBcImZyZXF1ZW5jeVwiLFxuXHRcdC8qKlxuXHRcdCAqICBUcmFuc3BvcnRUaW1lIGRlc2NyaWJlcyBhIHBvc2l0aW9uIGFsb25nIHRoZSBUcmFuc3BvcnQncyB0aW1lbGluZS4gSXQgaXNcblx0XHQgKiAgc2ltaWxhciB0byBUaW1lIGluIHRoYXQgaXQgdXNlcyBhbGwgdGhlIHNhbWUgZW5jb2RpbmdzLCBidXQgVHJhbnNwb3J0VGltZSBzcGVjaWZpY2FsbHlcblx0XHQgKiAgcGVydGFpbnMgdG8gdGhlIFRyYW5zcG9ydCdzIHRpbWVsaW5lLCB3aGljaCBpcyBzdGFydGFibGUsIHN0b3BwYWJsZSwgbG9vcGFibGUsIGFuZCBzZWVrYWJsZS5cblx0XHQgKiAgW1JlYWQgbW9yZV0oaHR0cHM6Ly9naXRodWIuY29tL1RvbmVqcy9Ub25lLmpzL3dpa2kvVHJhbnNwb3J0VGltZSlcblx0XHQgKiAgQHR5cGVkZWYge1RyYW5zcG9ydFRpbWV9XG5cdFx0ICovXG5cdFx0VHJhbnNwb3J0VGltZSA6IFwidHJhbnNwb3J0VGltZVwiLFxuXHRcdC8qKlxuXHRcdCAqICBUaWNrcyBhcmUgdGhlIGJhc2ljIHN1YnVuaXQgb2YgdGhlIFRyYW5zcG9ydC4gVGhleSBhcmVcblx0XHQgKiAgdGhlIHNtYWxsZXN0IHVuaXQgb2YgdGltZSB0aGF0IHRoZSBUcmFuc3BvcnQgc3VwcG9ydHMuXG5cdFx0ICogIEB0eXBlZGVmIHtUaWNrc31cblx0XHQgKi9cblx0XHRUaWNrcyA6IFwidGlja3NcIixcblx0XHQvKipcblx0XHQgKiAgTm9ybWFsIHZhbHVlcyBhcmUgd2l0aGluIHRoZSByYW5nZSBbMCwgMV0uXG5cdFx0ICogIEB0eXBlZGVmIHtOb3JtYWxSYW5nZX1cblx0XHQgKi9cblx0XHROb3JtYWxSYW5nZSA6IFwibm9ybWFsUmFuZ2VcIixcblx0XHQvKipcblx0XHQgKiAgQXVkaW9SYW5nZSB2YWx1ZXMgYXJlIGJldHdlZW4gWy0xLCAxXS5cblx0XHQgKiAgQHR5cGVkZWYge0F1ZGlvUmFuZ2V9XG5cdFx0ICovXG5cdFx0QXVkaW9SYW5nZSA6IFwiYXVkaW9SYW5nZVwiLFxuXHRcdC8qKlxuXHRcdCAqICBEZWNpYmVscyBhcmUgYSBsb2dhcml0aG1pYyB1bml0IG9mIG1lYXN1cmVtZW50IHdoaWNoIGlzIHVzZWZ1bCBmb3Igdm9sdW1lXG5cdFx0ICogIGJlY2F1c2Ugb2YgdGhlIGxvZ2FyaXRobWljIHdheSB0aGF0IHdlIHBlcmNlaXZlIGxvdWRuZXNzLiAwIGRlY2liZWxzXG5cdFx0ICogIG1lYW5zIG5vIGNoYW5nZSBpbiB2b2x1bWUuIC0xMGRiIGlzIGFwcHJveGltYXRlbHkgaGFsZiBhcyBsb3VkIGFuZCAxMGRiXG5cdFx0ICogIGlzIHR3aWNlIGlzIGxvdWQuXG5cdFx0ICogIEB0eXBlZGVmIHtEZWNpYmVsc31cblx0XHQgKi9cblx0XHREZWNpYmVscyA6IFwiZGJcIixcblx0XHQvKipcblx0XHQgKiAgSGFsZi1zdGVwIG5vdGUgaW5jcmVtZW50cywgaS5lLiAxMiBpcyBhbiBvY3RhdmUgYWJvdmUgdGhlIHJvb3QuIGFuZCAxIGlzIGEgaGFsZi1zdGVwIHVwLlxuXHRcdCAqICBAdHlwZWRlZiB7SW50ZXJ2YWx9XG5cdFx0ICovXG5cdFx0SW50ZXJ2YWwgOiBcImludGVydmFsXCIsXG5cdFx0LyoqXG5cdFx0ICogIEJlYXRzIHBlciBtaW51dGUuXG5cdFx0ICogIEB0eXBlZGVmIHtCUE19XG5cdFx0ICovXG5cdFx0QlBNIDogXCJicG1cIixcblx0XHQvKipcblx0XHQgKiAgVGhlIHZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAuXG5cdFx0ICogIEB0eXBlZGVmIHtQb3NpdGl2ZX1cblx0XHQgKi9cblx0XHRQb3NpdGl2ZSA6IFwicG9zaXRpdmVcIixcblx0XHQvKipcblx0XHQgKiAgR2FpbiBpcyB0aGUgcmF0aW8gYmV0d2VlbiBpbnB1dCBhbmQgb3V0cHV0IG9mIGEgc2lnbmFsLlxuXHRcdCAqICBBIGdhaW4gb2YgMCBpcyB0aGUgc2FtZSBhcyBzaWxlbmNpbmcgdGhlIHNpZ25hbC4gQSBnYWluIG9mXG5cdFx0ICogIDEsIGNhdXNlcyBubyBjaGFuZ2UgdG8gdGhlIGluY29taW5nIHNpZ25hbC5cblx0XHQgKiAgQHR5cGVkZWYge0dhaW59XG5cdFx0ICovXG5cdFx0R2FpbiA6IFwiZ2FpblwiLFxuXHRcdC8qKlxuXHRcdCAqICBBIGNlbnQgaXMgYSBodW5kcmVkdGggb2YgYSBzZW1pdG9uZS5cblx0XHQgKiAgQHR5cGVkZWYge0NlbnRzfVxuXHRcdCAqL1xuXHRcdENlbnRzIDogXCJjZW50c1wiLFxuXHRcdC8qKlxuXHRcdCAqICBBbmdsZSBiZXR3ZWVuIDAgYW5kIDM2MC5cblx0XHQgKiAgQHR5cGVkZWYge0RlZ3JlZXN9XG5cdFx0ICovXG5cdFx0RGVncmVlcyA6IFwiZGVncmVlc1wiLFxuXHRcdC8qKlxuXHRcdCAqICBBIG51bWJlciByZXByZXNlbnRpbmcgYSBtaWRpIG5vdGUuXG5cdFx0ICogIEB0eXBlZGVmIHtNSURJfVxuXHRcdCAqL1xuXHRcdE1JREkgOiBcIm1pZGlcIixcblx0XHQvKipcblx0XHQgKiAgQSBjb2xvbi1zZXBhcmF0ZWQgcmVwcmVzZW50YXRpb24gb2YgdGltZSBpbiB0aGUgZm9ybSBvZlxuXHRcdCAqICBCYXJzOkJlYXRzOlNpeHRlZW50aHMuXG5cdFx0ICogIEB0eXBlZGVmIHtCYXJzQmVhdHNTaXh0ZWVudGhzfVxuXHRcdCAqL1xuXHRcdEJhcnNCZWF0c1NpeHRlZW50aHMgOiBcImJhcnNCZWF0c1NpeHRlZW50aHNcIixcblx0XHQvKipcblx0XHQgKiAgU2FtcGxpbmcgaXMgdGhlIHJlZHVjdGlvbiBvZiBhIGNvbnRpbnVvdXMgc2lnbmFsIHRvIGEgZGlzY3JldGUgc2lnbmFsLlxuXHRcdCAqICBBdWRpbyBpcyB0eXBpY2FsbHkgc2FtcGxlZCA0NDEwMCB0aW1lcyBwZXIgc2Vjb25kLlxuXHRcdCAqICBAdHlwZWRlZiB7U2FtcGxlc31cblx0XHQgKi9cblx0XHRTYW1wbGVzIDogXCJzYW1wbGVzXCIsXG5cdFx0LyoqXG5cdFx0ICogIEhlcnR6IGFyZSBhIGZyZXF1ZW5jeSByZXByZXNlbnRhdGlvbiBkZWZpbmVkIGFzIG9uZSBjeWNsZSBwZXIgc2Vjb25kLlxuXHRcdCAqICBAdHlwZWRlZiB7SGVydHp9XG5cdFx0ICovXG5cdFx0SGVydHogOiBcImhlcnR6XCIsXG5cdFx0LyoqXG5cdFx0ICogIEEgZnJlcXVlbmN5IHJlcHJlc2VudGVkIGJ5IGEgbGV0dGVyIG5hbWUsXG5cdFx0ICogIGFjY2lkZW50YWwgYW5kIG9jdGF2ZS4gVGhpcyBzeXN0ZW0gaXMga25vd24gYXNcblx0XHQgKiAgW1NjaWVudGlmaWMgUGl0Y2ggTm90YXRpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NjaWVudGlmaWNfcGl0Y2hfbm90YXRpb24pLlxuXHRcdCAqICBAdHlwZWRlZiB7Tm90ZX1cblx0XHQgKi9cblx0XHROb3RlIDogXCJub3RlXCIsXG5cdFx0LyoqXG5cdFx0ICogIE9uZSBtaWxsaXNlY29uZCBpcyBhIHRob3VzYW5kdGggb2YgYSBzZWNvbmQuXG5cdFx0ICogIEB0eXBlZGVmIHtNaWxsaXNlY29uZHN9XG5cdFx0ICovXG5cdFx0TWlsbGlzZWNvbmRzIDogXCJtaWxsaXNlY29uZHNcIixcblx0XHQvKipcblx0XHQgKiAgU2Vjb25kcyBhcmUgdGhlIHRpbWUgdW5pdCBvZiB0aGUgQXVkaW9Db250ZXh0LiBJbiB0aGUgZW5kLFxuXHRcdCAqICBhbGwgdmFsdWVzIG5lZWQgdG8gYmUgZXZhbHVhdGVkIHRvIHNlY29uZHMuXG5cdFx0ICogIEB0eXBlZGVmIHtTZWNvbmRzfVxuXHRcdCAqL1xuXHRcdFNlY29uZHMgOiBcInNlY29uZHNcIixcblx0XHQvKipcblx0XHQgKiAgQSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZHVyYXRpb24gcmVsYXRpdmUgdG8gYSBtZWFzdXJlLlxuXHRcdCAqICAqIFwiNG5cIiA9IHF1YXJ0ZXIgbm90ZVxuXHRcdCAqICAqIFwiMm1cIiA9IHR3byBtZWFzdXJlc1xuXHRcdCAqICAqIFwiOHRcIiA9IGVpZ2h0aC1ub3RlIHRyaXBsZXRcblx0XHQgKiAgQHR5cGVkZWYge05vdGF0aW9ufVxuXHRcdCAqL1xuXHRcdE5vdGF0aW9uIDogXCJub3RhdGlvblwiLFxuXHR9O1xuXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBBVUdNRU5UIFRPTkUncyBQUk9UT1RZUEVcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblx0LyoqXG5cdCAqICBDb252ZXJ0IFRpbWUgaW50byBzZWNvbmRzLlxuXHQgKlxuXHQgKiAgVW5saWtlIHRoZSBtZXRob2Qgd2hpY2ggaXQgb3ZlcnJpZGVzLCB0aGlzIHRha2VzIGludG8gYWNjb3VudFxuXHQgKiAgdHJhbnNwb3J0dGltZSBhbmQgbXVzaWNhbCBub3RhdGlvbi5cblx0ICpcblx0ICogIFRpbWUgOiAxLjQwXG5cdCAqICBOb3RhdGlvbjogNG4gb3IgMW0gb3IgMnRcblx0ICogIE5vdyBSZWxhdGl2ZTogKzNuXG5cdCAqICBNYXRoOiAzbisxNm4gb3IgZXZlbiBjb21wbGljYXRlZCBleHByZXNzaW9ucyAoKDNuKjIpLzYgKyAxKVxuXHQgKlxuXHQgKiAgQHBhcmFtICB7VGltZX0gdGltZVxuXHQgKiAgQHJldHVybiB7U2Vjb25kc31cblx0ICovXG5cdFRvbmUucHJvdG90eXBlLnRvU2Vjb25kcyA9IGZ1bmN0aW9uKHRpbWUpe1xuXHRcdGlmIChUb25lLmlzTnVtYmVyKHRpbWUpKXtcblx0XHRcdHJldHVybiB0aW1lO1xuXHRcdH0gZWxzZSBpZiAoVG9uZS5pc1VuZGVmKHRpbWUpKXtcblx0XHRcdHJldHVybiB0aGlzLm5vdygpO1xuXHRcdH0gZWxzZSBpZiAoVG9uZS5pc1N0cmluZyh0aW1lKSl7XG5cdFx0XHRyZXR1cm4gKG5ldyBUb25lLlRpbWUodGltZSkpLnRvU2Vjb25kcygpO1xuXHRcdH0gZWxzZSBpZiAodGltZSBpbnN0YW5jZW9mIFRvbmUuVGltZUJhc2Upe1xuXHRcdFx0cmV0dXJuIHRpbWUudG9TZWNvbmRzKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiAgQ29udmVydCBhIGZyZXF1ZW5jeSByZXByZXNlbnRhdGlvbiBpbnRvIGEgbnVtYmVyLlxuXHQgKiAgQHBhcmFtICB7RnJlcXVlbmN5fSBmcmVxXG5cdCAqICBAcmV0dXJuIHtIZXJ0en0gICAgICB0aGUgZnJlcXVlbmN5IGluIGhlcnR6XG5cdCAqL1xuXHRUb25lLnByb3RvdHlwZS50b0ZyZXF1ZW5jeSA9IGZ1bmN0aW9uKGZyZXEpe1xuXHRcdGlmIChUb25lLmlzTnVtYmVyKGZyZXEpKXtcblx0XHRcdHJldHVybiBmcmVxO1xuXHRcdH0gZWxzZSBpZiAoVG9uZS5pc1N0cmluZyhmcmVxKSB8fCBUb25lLmlzVW5kZWYoZnJlcSkpe1xuXHRcdFx0cmV0dXJuIChuZXcgVG9uZS5GcmVxdWVuY3koZnJlcSkpLnZhbHVlT2YoKTtcblx0XHR9IGVsc2UgaWYgKGZyZXEgaW5zdGFuY2VvZiBUb25lLlRpbWVCYXNlKXtcblx0XHRcdHJldHVybiBmcmVxLnRvRnJlcXVlbmN5KCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiAgQ29udmVydCBhIHRpbWUgcmVwcmVzZW50YXRpb24gaW50byB0aWNrcy5cblx0ICogIEBwYXJhbSAge1RpbWV9IHRpbWVcblx0ICogIEByZXR1cm4ge1RpY2tzfSAgdGhlIHRpbWUgaW4gdGlja3Ncblx0ICovXG5cdFRvbmUucHJvdG90eXBlLnRvVGlja3MgPSBmdW5jdGlvbih0aW1lKXtcblx0XHRpZiAoVG9uZS5pc051bWJlcih0aW1lKSB8fCBUb25lLmlzU3RyaW5nKHRpbWUpKXtcblx0XHRcdHJldHVybiAobmV3IFRvbmUuVHJhbnNwb3J0VGltZSh0aW1lKSkudG9UaWNrcygpO1xuXHRcdH0gZWxzZSBpZiAoVG9uZS5pc1VuZGVmKHRpbWUpKXtcblx0XHRcdHJldHVybiBUb25lLlRyYW5zcG9ydC50aWNrcztcblx0XHR9IGVsc2UgaWYgKHRpbWUgaW5zdGFuY2VvZiBUb25lLlRpbWVCYXNlKXtcblx0XHRcdHJldHVybiB0aW1lLnRvVGlja3MoKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIFRvbmU7XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUFBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQUE7Ozs7O0FBS0E7QUFDQTtBQUFBOzs7O0FBSUE7QUFDQTtBQUFBOzs7O0FBSUE7QUFDQTtBQUFBOzs7Ozs7O0FBT0E7QUFDQTtBQUFBOzs7O0FBSUE7QUFDQTtBQUFBOzs7O0FBSUE7QUFDQTtBQUFBOzs7O0FBSUE7QUFDQTtBQUFBOzs7Ozs7QUFNQTtBQUNBO0FBQUE7Ozs7QUFJQTtBQUNBO0FBQUE7Ozs7QUFJQTtBQUNBO0FBQUE7Ozs7QUFJQTtBQUNBO0FBQUE7Ozs7O0FBS0E7QUFDQTtBQUFBOzs7OztBQUtBO0FBQ0E7QUFBQTs7OztBQUlBO0FBQ0E7QUFBQTs7Ozs7O0FBTUE7QUFDQTtBQUFBOzs7O0FBSUE7QUFDQTtBQUFBOzs7OztBQUtBO0FBQ0E7QUFBQTs7Ozs7OztBQU9BO0FBakpBO0FBcUpBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tone/Tone/type/Type.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var tone_Tone_instrument_Sampler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tone/Tone/instrument/Sampler */ \"./node_modules/tone/Tone/instrument/Sampler.js\");\n/* harmony import */ var tone_Tone_instrument_Sampler__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tone_Tone_instrument_Sampler__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./styles.css */ \"./src/styles.css\");\n/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_styles_css__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nvar sounds = __webpack_require__(\"./src/salamander sync recursive \\\\.(mp3)\");\n\nvar noteToKeyboardMap = new Map([[70, 'C'], // f\n[84, 'C#'], // t\n[71, 'D'], // g\n[89, 'D#'], // y\n[72, 'E'], // h\n[74, 'F'], // j\n[73, 'F#'], // i\n[75, 'G'], // k\n[79, 'G#'], // o\n[76, 'A'], // l\n[80, 'A#'], // p\n[186, 'B'], // ;\n[222, 'Ce']]);\nvar octave = 4;\n\nfunction filenameToNotename(name) {\n  // ej. Convert ./Ds4.mp3 into D#4\n  return name.split('.')[1].replace('/', '').replace('s', '#');\n}\n\nvar soundsSources = sounds.keys().reduce(function (res, key) {\n  res[filenameToNotename(key)] = \"./dist/\".concat(sounds(key));\n  return res;\n}, {});\nvar piano = new tone_Tone_instrument_Sampler__WEBPACK_IMPORTED_MODULE_0___default.a(soundsSources, function () {}).toMaster();\nvar keysDown = {}; // We need compute octave in order to allow 2 C keys to coexist\n\nfunction computeNote(n, t) {\n  if (n === 'Ce') {\n    return \"C\".concat(t >= 7 ? 0 : t + 1);\n  }\n\n  return \"\".concat(n).concat(t);\n}\n\nfunction pressKey(item, note) {\n  return function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    keysDown[note] = true;\n    piano.triggerAttack(computeNote(note, octave), '+0.05');\n    item.classList.add('playing');\n  };\n}\n\nfunction releaseKey(item, note) {\n  return function (e) {\n    if (e.preventDefault() && e.stopPropagation() && keysDown[note]) {\n      piano.triggerRelease(computeNote(note, octave));\n      keysDown[note] = false;\n    }\n\n    setTimeout(function () {\n      item.classList.remove('playing');\n    }, 200);\n  };\n}\n\nvar octaveDisplayer = document.querySelector('#octaveDisplayer');\n\nfunction updateOctave(t) {\n  octave = t >= 1 && t <= 7 ? t : octave;\n  octaveDisplayer.innerHTML = \"Octave: \".concat(octave);\n}\n\nvar keys = document.querySelectorAll('[playable]');\nvar keyPressers = {};\nvar keyReleasers = {};\n\nfor (var i = 0; i < keys.length; i += 1) {\n  var note = keys[i].getAttribute('note');\n  keyPressers[note] = pressKey(keys[i], note);\n  keyReleasers[note] = releaseKey(keys[i], note);\n  keys[i].addEventListener('pointerdown', keyPressers[note]);\n  keys[i].addEventListener('pointerup', keyReleasers[note]);\n}\n\nwindow.addEventListener('keydown', function (e) {\n  var note = noteToKeyboardMap.get(e.which);\n\n  if (typeof keyPressers[note] === 'function') {\n    keyPressers[note](e);\n  }\n\n  if (e.which === 65) {\n    updateOctave(octave - 1);\n  } else if (e.which === 81) {\n    updateOctave(octave + 1);\n  }\n});\nwindow.addEventListener('keyup', function (e) {\n  var note = noteToKeyboardMap.get(e.which);\n\n  if (typeof keyReleasers[note] === 'function') {\n    keyReleasers[note](e);\n  }\n});\nupdateOctave(octave);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU2FtcGxlciBmcm9tICd0b25lL1RvbmUvaW5zdHJ1bWVudC9TYW1wbGVyJztcbmltcG9ydCAnLi9zdHlsZXMuY3NzJztcblxuY29uc3Qgc291bmRzID0gcmVxdWlyZS5jb250ZXh0KCcuL3NhbGFtYW5kZXInLCB0cnVlLCAvXFwuKG1wMykvKTtcbmNvbnN0IG5vdGVUb0tleWJvYXJkTWFwID0gbmV3IE1hcChbXG4gIFs3MCwgJ0MnXSwgLy8gZlxuICBbODQsICdDIyddLCAvLyB0XG4gIFs3MSwgJ0QnXSwgLy8gZ1xuICBbODksICdEIyddLCAvLyB5XG4gIFs3MiwgJ0UnXSwgLy8gaFxuICBbNzQsICdGJ10sIC8vIGpcbiAgWzczLCAnRiMnXSwgLy8gaVxuICBbNzUsICdHJ10sIC8vIGtcbiAgWzc5LCAnRyMnXSwgLy8gb1xuICBbNzYsICdBJ10sIC8vIGxcbiAgWzgwLCAnQSMnXSwgLy8gcFxuICBbMTg2LCAnQiddLCAvLyA7XG4gIFsyMjIsICdDZSddLCAvLyAnXG5dKTtcblxubGV0IG9jdGF2ZSA9IDQ7XG5cbmZ1bmN0aW9uIGZpbGVuYW1lVG9Ob3RlbmFtZShuYW1lKSB7XG4gIC8vIGVqLiBDb252ZXJ0IC4vRHM0Lm1wMyBpbnRvIEQjNFxuICByZXR1cm4gbmFtZS5zcGxpdCgnLicpWzFdLnJlcGxhY2UoJy8nLCAnJykucmVwbGFjZSgncycsICcjJyk7XG59XG5cbmNvbnN0IHNvdW5kc1NvdXJjZXMgPSBzb3VuZHMua2V5cygpLnJlZHVjZSgocmVzLCBrZXkpID0+IHtcbiAgcmVzW2ZpbGVuYW1lVG9Ob3RlbmFtZShrZXkpXSA9IGAuL2Rpc3QvJHtzb3VuZHMoa2V5KX1gO1xuICByZXR1cm4gcmVzO1xufSwge30pO1xuXG5jb25zdCBwaWFubyA9IG5ldyBTYW1wbGVyKHNvdW5kc1NvdXJjZXMsICgpID0+IHt9KS50b01hc3RlcigpO1xuY29uc3Qga2V5c0Rvd24gPSB7fTtcblxuLy8gV2UgbmVlZCBjb21wdXRlIG9jdGF2ZSBpbiBvcmRlciB0byBhbGxvdyAyIEMga2V5cyB0byBjb2V4aXN0XG5mdW5jdGlvbiBjb21wdXRlTm90ZShuLCB0KSB7XG4gIGlmIChuID09PSAnQ2UnKSB7XG4gICAgcmV0dXJuIGBDJHt0ID49IDcgPyAwIDogdCArIDF9YDtcbiAgfVxuICByZXR1cm4gYCR7bn0ke3R9YDtcbn1cblxuZnVuY3Rpb24gcHJlc3NLZXkoaXRlbSwgbm90ZSkge1xuICByZXR1cm4gKGUpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBrZXlzRG93bltub3RlXSA9IHRydWU7XG4gICAgcGlhbm8udHJpZ2dlckF0dGFjayhjb21wdXRlTm90ZShub3RlLCBvY3RhdmUpLCAnKzAuMDUnKTtcbiAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ3BsYXlpbmcnKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZUtleShpdGVtLCBub3RlKSB7XG4gIHJldHVybiAoZSkgPT4ge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KCkgJiYgZS5zdG9wUHJvcGFnYXRpb24oKSAmJiBrZXlzRG93bltub3RlXSkge1xuICAgICAgcGlhbm8udHJpZ2dlclJlbGVhc2UoY29tcHV0ZU5vdGUobm90ZSwgb2N0YXZlKSk7XG4gICAgICBrZXlzRG93bltub3RlXSA9IGZhbHNlO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgncGxheWluZycpO1xuICAgIH0sIDIwMCk7XG4gIH07XG59XG5cbmNvbnN0IG9jdGF2ZURpc3BsYXllciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNvY3RhdmVEaXNwbGF5ZXInKTtcblxuZnVuY3Rpb24gdXBkYXRlT2N0YXZlKHQpIHtcbiAgb2N0YXZlID0gdCA+PSAxICYmIHQgPD0gNyA/IHQgOiBvY3RhdmU7XG4gIG9jdGF2ZURpc3BsYXllci5pbm5lckhUTUwgPSBgT2N0YXZlOiAke29jdGF2ZX1gO1xufVxuXG5jb25zdCBrZXlzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW3BsYXlhYmxlXScpO1xuY29uc3Qga2V5UHJlc3NlcnMgPSB7fTtcbmNvbnN0IGtleVJlbGVhc2VycyA9IHt9O1xuXG5cbmZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICBjb25zdCBub3RlID0ga2V5c1tpXS5nZXRBdHRyaWJ1dGUoJ25vdGUnKTtcbiAga2V5UHJlc3NlcnNbbm90ZV0gPSBwcmVzc0tleShrZXlzW2ldLCBub3RlKTtcbiAga2V5UmVsZWFzZXJzW25vdGVdID0gcmVsZWFzZUtleShrZXlzW2ldLCBub3RlKTtcbiAga2V5c1tpXS5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGtleVByZXNzZXJzW25vdGVdKTtcbiAga2V5c1tpXS5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBrZXlSZWxlYXNlcnNbbm90ZV0pO1xufVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChlKSA9PiB7XG4gIGNvbnN0IG5vdGUgPSBub3RlVG9LZXlib2FyZE1hcC5nZXQoZS53aGljaCk7XG4gIGlmICh0eXBlb2Yga2V5UHJlc3NlcnNbbm90ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBrZXlQcmVzc2Vyc1tub3RlXShlKTtcbiAgfVxuICBpZiAoZS53aGljaCA9PT0gNjUpIHtcbiAgICB1cGRhdGVPY3RhdmUob2N0YXZlIC0gMSk7XG4gIH0gZWxzZSBpZiAoZS53aGljaCA9PT0gODEpIHtcbiAgICB1cGRhdGVPY3RhdmUob2N0YXZlICsgMSk7XG4gIH1cbn0pO1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCAoZSkgPT4ge1xuICBjb25zdCBub3RlID0gbm90ZVRvS2V5Ym9hcmRNYXAuZ2V0KGUud2hpY2gpO1xuICBpZiAodHlwZW9mIGtleVJlbGVhc2Vyc1tub3RlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGtleVJlbGVhc2Vyc1tub3RlXShlKTtcbiAgfVxufSk7XG5cbnVwZGF0ZU9jdGF2ZShvY3RhdmUpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/salamander sync recursive \\.(mp3)":
/*!*************************************!*\
  !*** ./src/salamander sync \.(mp3) ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var map = {\n\t\"./A0.mp3\": \"./src/salamander/A0.mp3\",\n\t\"./A1.mp3\": \"./src/salamander/A1.mp3\",\n\t\"./A2.mp3\": \"./src/salamander/A2.mp3\",\n\t\"./A3.mp3\": \"./src/salamander/A3.mp3\",\n\t\"./A4.mp3\": \"./src/salamander/A4.mp3\",\n\t\"./A5.mp3\": \"./src/salamander/A5.mp3\",\n\t\"./A6.mp3\": \"./src/salamander/A6.mp3\",\n\t\"./A7.mp3\": \"./src/salamander/A7.mp3\",\n\t\"./C1.mp3\": \"./src/salamander/C1.mp3\",\n\t\"./C2.mp3\": \"./src/salamander/C2.mp3\",\n\t\"./C3.mp3\": \"./src/salamander/C3.mp3\",\n\t\"./C4.mp3\": \"./src/salamander/C4.mp3\",\n\t\"./C5.mp3\": \"./src/salamander/C5.mp3\",\n\t\"./C6.mp3\": \"./src/salamander/C6.mp3\",\n\t\"./C7.mp3\": \"./src/salamander/C7.mp3\",\n\t\"./C8.mp3\": \"./src/salamander/C8.mp3\",\n\t\"./Ds1.mp3\": \"./src/salamander/Ds1.mp3\",\n\t\"./Ds2.mp3\": \"./src/salamander/Ds2.mp3\",\n\t\"./Ds3.mp3\": \"./src/salamander/Ds3.mp3\",\n\t\"./Ds4.mp3\": \"./src/salamander/Ds4.mp3\",\n\t\"./Ds5.mp3\": \"./src/salamander/Ds5.mp3\",\n\t\"./Ds6.mp3\": \"./src/salamander/Ds6.mp3\",\n\t\"./Ds7.mp3\": \"./src/salamander/Ds7.mp3\",\n\t\"./Fs1.mp3\": \"./src/salamander/Fs1.mp3\",\n\t\"./Fs2.mp3\": \"./src/salamander/Fs2.mp3\",\n\t\"./Fs3.mp3\": \"./src/salamander/Fs3.mp3\",\n\t\"./Fs4.mp3\": \"./src/salamander/Fs4.mp3\",\n\t\"./Fs5.mp3\": \"./src/salamander/Fs5.mp3\",\n\t\"./Fs6.mp3\": \"./src/salamander/Fs6.mp3\",\n\t\"./Fs7.mp3\": \"./src/salamander/Fs7.mp3\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) { // check for number or string\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn id;\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/salamander sync recursive \\\\.(mp3)\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlciBzeW5jIHJlY3Vyc2l2ZSBcXC4obXAzKS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zYWxhbWFuZGVyIHN5bmMgXFwuKG1wMyk/YzMyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWFwID0ge1xuXHRcIi4vQTAubXAzXCI6IFwiLi9zcmMvc2FsYW1hbmRlci9BMC5tcDNcIixcblx0XCIuL0ExLm1wM1wiOiBcIi4vc3JjL3NhbGFtYW5kZXIvQTEubXAzXCIsXG5cdFwiLi9BMi5tcDNcIjogXCIuL3NyYy9zYWxhbWFuZGVyL0EyLm1wM1wiLFxuXHRcIi4vQTMubXAzXCI6IFwiLi9zcmMvc2FsYW1hbmRlci9BMy5tcDNcIixcblx0XCIuL0E0Lm1wM1wiOiBcIi4vc3JjL3NhbGFtYW5kZXIvQTQubXAzXCIsXG5cdFwiLi9BNS5tcDNcIjogXCIuL3NyYy9zYWxhbWFuZGVyL0E1Lm1wM1wiLFxuXHRcIi4vQTYubXAzXCI6IFwiLi9zcmMvc2FsYW1hbmRlci9BNi5tcDNcIixcblx0XCIuL0E3Lm1wM1wiOiBcIi4vc3JjL3NhbGFtYW5kZXIvQTcubXAzXCIsXG5cdFwiLi9DMS5tcDNcIjogXCIuL3NyYy9zYWxhbWFuZGVyL0MxLm1wM1wiLFxuXHRcIi4vQzIubXAzXCI6IFwiLi9zcmMvc2FsYW1hbmRlci9DMi5tcDNcIixcblx0XCIuL0MzLm1wM1wiOiBcIi4vc3JjL3NhbGFtYW5kZXIvQzMubXAzXCIsXG5cdFwiLi9DNC5tcDNcIjogXCIuL3NyYy9zYWxhbWFuZGVyL0M0Lm1wM1wiLFxuXHRcIi4vQzUubXAzXCI6IFwiLi9zcmMvc2FsYW1hbmRlci9DNS5tcDNcIixcblx0XCIuL0M2Lm1wM1wiOiBcIi4vc3JjL3NhbGFtYW5kZXIvQzYubXAzXCIsXG5cdFwiLi9DNy5tcDNcIjogXCIuL3NyYy9zYWxhbWFuZGVyL0M3Lm1wM1wiLFxuXHRcIi4vQzgubXAzXCI6IFwiLi9zcmMvc2FsYW1hbmRlci9DOC5tcDNcIixcblx0XCIuL0RzMS5tcDNcIjogXCIuL3NyYy9zYWxhbWFuZGVyL0RzMS5tcDNcIixcblx0XCIuL0RzMi5tcDNcIjogXCIuL3NyYy9zYWxhbWFuZGVyL0RzMi5tcDNcIixcblx0XCIuL0RzMy5tcDNcIjogXCIuL3NyYy9zYWxhbWFuZGVyL0RzMy5tcDNcIixcblx0XCIuL0RzNC5tcDNcIjogXCIuL3NyYy9zYWxhbWFuZGVyL0RzNC5tcDNcIixcblx0XCIuL0RzNS5tcDNcIjogXCIuL3NyYy9zYWxhbWFuZGVyL0RzNS5tcDNcIixcblx0XCIuL0RzNi5tcDNcIjogXCIuL3NyYy9zYWxhbWFuZGVyL0RzNi5tcDNcIixcblx0XCIuL0RzNy5tcDNcIjogXCIuL3NyYy9zYWxhbWFuZGVyL0RzNy5tcDNcIixcblx0XCIuL0ZzMS5tcDNcIjogXCIuL3NyYy9zYWxhbWFuZGVyL0ZzMS5tcDNcIixcblx0XCIuL0ZzMi5tcDNcIjogXCIuL3NyYy9zYWxhbWFuZGVyL0ZzMi5tcDNcIixcblx0XCIuL0ZzMy5tcDNcIjogXCIuL3NyYy9zYWxhbWFuZGVyL0ZzMy5tcDNcIixcblx0XCIuL0ZzNC5tcDNcIjogXCIuL3NyYy9zYWxhbWFuZGVyL0ZzNC5tcDNcIixcblx0XCIuL0ZzNS5tcDNcIjogXCIuL3NyYy9zYWxhbWFuZGVyL0ZzNS5tcDNcIixcblx0XCIuL0ZzNi5tcDNcIjogXCIuL3NyYy9zYWxhbWFuZGVyL0ZzNi5tcDNcIixcblx0XCIuL0ZzNy5tcDNcIjogXCIuL3NyYy9zYWxhbWFuZGVyL0ZzNy5tcDNcIlxufTtcblxuXG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0dmFyIGlkID0gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSk7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTtcbn1cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0dmFyIGlkID0gbWFwW3JlcV07XG5cdGlmKCEoaWQgKyAxKSkgeyAvLyBjaGVjayBmb3IgbnVtYmVyIG9yIHN0cmluZ1xuXHRcdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0XHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdFx0dGhyb3cgZTtcblx0fVxuXHRyZXR1cm4gaWQ7XG59XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gXCIuL3NyYy9zYWxhbWFuZGVyIHN5bmMgcmVjdXJzaXZlIFxcXFwuKG1wMylcIjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/salamander sync recursive \\.(mp3)\n");

/***/ }),

/***/ "./src/salamander/A0.mp3":
/*!*******************************!*\
  !*** ./src/salamander/A0.mp3 ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"ae297c5adf385df57658e08f09c44e46.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9BMC5tcDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2FsYW1hbmRlci9BMC5tcDM/ODc5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJhZTI5N2M1YWRmMzg1ZGY1NzY1OGUwOGYwOWM0NGU0Ni5tcDNcIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/salamander/A0.mp3\n");

/***/ }),

/***/ "./src/salamander/A1.mp3":
/*!*******************************!*\
  !*** ./src/salamander/A1.mp3 ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"8a4cf5ae59d78ae1bf5d8ae2628cc7c0.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9BMS5tcDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2FsYW1hbmRlci9BMS5tcDM/OTcxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCI4YTRjZjVhZTU5ZDc4YWUxYmY1ZDhhZTI2MjhjYzdjMC5tcDNcIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/salamander/A1.mp3\n");

/***/ }),

/***/ "./src/salamander/A2.mp3":
/*!*******************************!*\
  !*** ./src/salamander/A2.mp3 ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"f30c6031e17463b32c6e8a3a8cf90fb4.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9BMi5tcDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2FsYW1hbmRlci9BMi5tcDM/ZDk0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJmMzBjNjAzMWUxNzQ2M2IzMmM2ZThhM2E4Y2Y5MGZiNC5tcDNcIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/salamander/A2.mp3\n");

/***/ }),

/***/ "./src/salamander/A3.mp3":
/*!*******************************!*\
  !*** ./src/salamander/A3.mp3 ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"d83805c080f80bcee94d817e375d224f.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9BMy5tcDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2FsYW1hbmRlci9BMy5tcDM/ZWY1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJkODM4MDVjMDgwZjgwYmNlZTk0ZDgxN2UzNzVkMjI0Zi5tcDNcIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/salamander/A3.mp3\n");

/***/ }),

/***/ "./src/salamander/A4.mp3":
/*!*******************************!*\
  !*** ./src/salamander/A4.mp3 ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"ac1793b11eb5472897c57a48897049ac.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9BNC5tcDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2FsYW1hbmRlci9BNC5tcDM/NmNmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJhYzE3OTNiMTFlYjU0NzI4OTdjNTdhNDg4OTcwNDlhYy5tcDNcIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/salamander/A4.mp3\n");

/***/ }),

/***/ "./src/salamander/A5.mp3":
/*!*******************************!*\
  !*** ./src/salamander/A5.mp3 ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"07a5bfc6f2d22a1f0ce18831131bc079.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9BNS5tcDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2FsYW1hbmRlci9BNS5tcDM/YTY1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCIwN2E1YmZjNmYyZDIyYTFmMGNlMTg4MzExMzFiYzA3OS5tcDNcIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/salamander/A5.mp3\n");

/***/ }),

/***/ "./src/salamander/A6.mp3":
/*!*******************************!*\
  !*** ./src/salamander/A6.mp3 ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"7a848d96c5a03ba7f5655f28a17df7df.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9BNi5tcDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2FsYW1hbmRlci9BNi5tcDM/YTFkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCI3YTg0OGQ5NmM1YTAzYmE3ZjU2NTVmMjhhMTdkZjdkZi5tcDNcIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/salamander/A6.mp3\n");

/***/ }),

/***/ "./src/salamander/A7.mp3":
/*!*******************************!*\
  !*** ./src/salamander/A7.mp3 ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"dfbb0274be3ec0e6e43dd24741523063.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9BNy5tcDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2FsYW1hbmRlci9BNy5tcDM/OWY0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJkZmJiMDI3NGJlM2VjMGU2ZTQzZGQyNDc0MTUyMzA2My5tcDNcIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/salamander/A7.mp3\n");

/***/ }),

/***/ "./src/salamander/C1.mp3":
/*!*******************************!*\
  !*** ./src/salamander/C1.mp3 ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"18e7a4f7075948ab503e70fc812e72c1.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9DMS5tcDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2FsYW1hbmRlci9DMS5tcDM/ZDBjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCIxOGU3YTRmNzA3NTk0OGFiNTAzZTcwZmM4MTJlNzJjMS5tcDNcIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/salamander/C1.mp3\n");

/***/ }),

/***/ "./src/salamander/C2.mp3":
/*!*******************************!*\
  !*** ./src/salamander/C2.mp3 ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"fea0b1f393117812f9a00519d59bdc73.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9DMi5tcDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2FsYW1hbmRlci9DMi5tcDM/MTQ5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJmZWEwYjFmMzkzMTE3ODEyZjlhMDA1MTlkNTliZGM3My5tcDNcIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/salamander/C2.mp3\n");

/***/ }),

/***/ "./src/salamander/C3.mp3":
/*!*******************************!*\
  !*** ./src/salamander/C3.mp3 ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"e2e4c48c62a94d3d3d0cc0b070d0c8bd.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9DMy5tcDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2FsYW1hbmRlci9DMy5tcDM/NGRkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJlMmU0YzQ4YzYyYTk0ZDNkM2QwY2MwYjA3MGQwYzhiZC5tcDNcIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/salamander/C3.mp3\n");

/***/ }),

/***/ "./src/salamander/C4.mp3":
/*!*******************************!*\
  !*** ./src/salamander/C4.mp3 ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"2f496ec3fdce5db3d2da548ce21be91d.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9DNC5tcDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2FsYW1hbmRlci9DNC5tcDM/MDdkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCIyZjQ5NmVjM2ZkY2U1ZGIzZDJkYTU0OGNlMjFiZTkxZC5tcDNcIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/salamander/C4.mp3\n");

/***/ }),

/***/ "./src/salamander/C5.mp3":
/*!*******************************!*\
  !*** ./src/salamander/C5.mp3 ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"0d1e316ab0853d4b25ad7009e5e71716.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9DNS5tcDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2FsYW1hbmRlci9DNS5tcDM/NWIwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCIwZDFlMzE2YWIwODUzZDRiMjVhZDcwMDllNWU3MTcxNi5tcDNcIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/salamander/C5.mp3\n");

/***/ }),

/***/ "./src/salamander/C6.mp3":
/*!*******************************!*\
  !*** ./src/salamander/C6.mp3 ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"8420f29f45dcb16e70d6e182c4f49154.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9DNi5tcDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2FsYW1hbmRlci9DNi5tcDM/Y2E4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCI4NDIwZjI5ZjQ1ZGNiMTZlNzBkNmUxODJjNGY0OTE1NC5tcDNcIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/salamander/C6.mp3\n");

/***/ }),

/***/ "./src/salamander/C7.mp3":
/*!*******************************!*\
  !*** ./src/salamander/C7.mp3 ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"a5d1aa5ac7e4a07e8b5d460bd0cc813f.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9DNy5tcDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2FsYW1hbmRlci9DNy5tcDM/YjUzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJhNWQxYWE1YWM3ZTRhMDdlOGI1ZDQ2MGJkMGNjODEzZi5tcDNcIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/salamander/C7.mp3\n");

/***/ }),

/***/ "./src/salamander/C8.mp3":
/*!*******************************!*\
  !*** ./src/salamander/C8.mp3 ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"cb23085ea092ccfc2bae4d15937329cc.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9DOC5tcDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2FsYW1hbmRlci9DOC5tcDM/ZjJiZCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJjYjIzMDg1ZWEwOTJjY2ZjMmJhZTRkMTU5MzczMjljYy5tcDNcIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/salamander/C8.mp3\n");

/***/ }),

/***/ "./src/salamander/Ds1.mp3":
/*!********************************!*\
  !*** ./src/salamander/Ds1.mp3 ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"f5208d1a95e8438193d2771b5e2b81a4.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9EczEubXAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NhbGFtYW5kZXIvRHMxLm1wMz9iMGNhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImY1MjA4ZDFhOTVlODQzODE5M2QyNzcxYjVlMmI4MWE0Lm1wM1wiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/salamander/Ds1.mp3\n");

/***/ }),

/***/ "./src/salamander/Ds2.mp3":
/*!********************************!*\
  !*** ./src/salamander/Ds2.mp3 ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"8bb122604c4241b5c470958303f7314e.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9EczIubXAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NhbGFtYW5kZXIvRHMyLm1wMz81MWUxIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjhiYjEyMjYwNGM0MjQxYjVjNDcwOTU4MzAzZjczMTRlLm1wM1wiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/salamander/Ds2.mp3\n");

/***/ }),

/***/ "./src/salamander/Ds3.mp3":
/*!********************************!*\
  !*** ./src/salamander/Ds3.mp3 ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"84bb9c0a39a515d87d90751ebd355085.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9EczMubXAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NhbGFtYW5kZXIvRHMzLm1wMz83NmZiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjg0YmI5YzBhMzlhNTE1ZDg3ZDkwNzUxZWJkMzU1MDg1Lm1wM1wiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/salamander/Ds3.mp3\n");

/***/ }),

/***/ "./src/salamander/Ds4.mp3":
/*!********************************!*\
  !*** ./src/salamander/Ds4.mp3 ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"88ae883ad007a298010a5974db74ba53.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9EczQubXAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NhbGFtYW5kZXIvRHM0Lm1wMz9jZDA3Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjg4YWU4ODNhZDAwN2EyOTgwMTBhNTk3NGRiNzRiYTUzLm1wM1wiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/salamander/Ds4.mp3\n");

/***/ }),

/***/ "./src/salamander/Ds5.mp3":
/*!********************************!*\
  !*** ./src/salamander/Ds5.mp3 ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"94e49f1403865e6e74b748bc206e32a6.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9EczUubXAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NhbGFtYW5kZXIvRHM1Lm1wMz9jZWNlIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjk0ZTQ5ZjE0MDM4NjVlNmU3NGI3NDhiYzIwNmUzMmE2Lm1wM1wiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/salamander/Ds5.mp3\n");

/***/ }),

/***/ "./src/salamander/Ds6.mp3":
/*!********************************!*\
  !*** ./src/salamander/Ds6.mp3 ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"93db6bd355ed9970ad4d6e3a4fe2860d.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9EczYubXAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NhbGFtYW5kZXIvRHM2Lm1wMz85NGZkIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjkzZGI2YmQzNTVlZDk5NzBhZDRkNmUzYTRmZTI4NjBkLm1wM1wiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/salamander/Ds6.mp3\n");

/***/ }),

/***/ "./src/salamander/Ds7.mp3":
/*!********************************!*\
  !*** ./src/salamander/Ds7.mp3 ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"0e00cb46fef90113657ee395ffd0d423.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9EczcubXAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NhbGFtYW5kZXIvRHM3Lm1wMz9kNDI5Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjBlMDBjYjQ2ZmVmOTAxMTM2NTdlZTM5NWZmZDBkNDIzLm1wM1wiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/salamander/Ds7.mp3\n");

/***/ }),

/***/ "./src/salamander/Fs1.mp3":
/*!********************************!*\
  !*** ./src/salamander/Fs1.mp3 ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"8380198ef0d1b1edc3b2390c51ecc6e8.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9GczEubXAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NhbGFtYW5kZXIvRnMxLm1wMz9iOGE4Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjgzODAxOThlZjBkMWIxZWRjM2IyMzkwYzUxZWNjNmU4Lm1wM1wiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/salamander/Fs1.mp3\n");

/***/ }),

/***/ "./src/salamander/Fs2.mp3":
/*!********************************!*\
  !*** ./src/salamander/Fs2.mp3 ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"86039a11bfdaf9ddfbba95a195c94d5b.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9GczIubXAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NhbGFtYW5kZXIvRnMyLm1wMz85M2YyIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjg2MDM5YTExYmZkYWY5ZGRmYmJhOTVhMTk1Yzk0ZDViLm1wM1wiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/salamander/Fs2.mp3\n");

/***/ }),

/***/ "./src/salamander/Fs3.mp3":
/*!********************************!*\
  !*** ./src/salamander/Fs3.mp3 ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"d9e8459da3320131e5a39155c2f86278.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9GczMubXAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NhbGFtYW5kZXIvRnMzLm1wMz9iZjI1Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImQ5ZTg0NTlkYTMzMjAxMzFlNWEzOTE1NWMyZjg2Mjc4Lm1wM1wiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/salamander/Fs3.mp3\n");

/***/ }),

/***/ "./src/salamander/Fs4.mp3":
/*!********************************!*\
  !*** ./src/salamander/Fs4.mp3 ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"210c4652fcf4a271a12d91fb3b1b7247.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9GczQubXAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NhbGFtYW5kZXIvRnM0Lm1wMz9jY2MzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjIxMGM0NjUyZmNmNGEyNzFhMTJkOTFmYjNiMWI3MjQ3Lm1wM1wiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/salamander/Fs4.mp3\n");

/***/ }),

/***/ "./src/salamander/Fs5.mp3":
/*!********************************!*\
  !*** ./src/salamander/Fs5.mp3 ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"3a213fc21fa03d96c5706f5c54353c10.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9GczUubXAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NhbGFtYW5kZXIvRnM1Lm1wMz84NzgyIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjNhMjEzZmMyMWZhMDNkOTZjNTcwNmY1YzU0MzUzYzEwLm1wM1wiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/salamander/Fs5.mp3\n");

/***/ }),

/***/ "./src/salamander/Fs6.mp3":
/*!********************************!*\
  !*** ./src/salamander/Fs6.mp3 ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"99903cce422eadff5f93ad762ba3502a.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9GczYubXAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NhbGFtYW5kZXIvRnM2Lm1wMz84ZDFkIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjk5OTAzY2NlNDIyZWFkZmY1ZjkzYWQ3NjJiYTM1MDJhLm1wM1wiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/salamander/Fs6.mp3\n");

/***/ }),

/***/ "./src/salamander/Fs7.mp3":
/*!********************************!*\
  !*** ./src/salamander/Fs7.mp3 ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"01e61f3e5216b85ad25c61a0b658ed3c.mp3\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2FsYW1hbmRlci9GczcubXAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NhbGFtYW5kZXIvRnM3Lm1wMz8xMTllIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjAxZTYxZjNlNTIxNmI4NWFkMjVjNjFhMGI2NThlZDNjLm1wM1wiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/salamander/Fs7.mp3\n");

/***/ }),

/***/ "./src/styles.css":
/*!************************!*\
  !*** ./src/styles.css ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../node_modules/css-loader!./styles.css */ \"./node_modules/css-loader/index.js!./src/styles.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3R5bGVzLmNzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zdHlsZXMuY3NzPzAyYWUiXSwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc3R5bGVzLmNzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zdHlsZXMuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zdHlsZXMuY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/styles.css\n");

/***/ })

/******/ });